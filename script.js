// Данные карточек (только предустановленные)
let cardsData = [
    {
        id: 1,
        title: "Цикл for",
        tag: "Цикл",
        shortDesc: "Объяснение принципа работы цикла for",
        code: `for i in range(1, 100): # Цикл от 1 до 99
    print(i) # Вывод текущего числа

# Итерация по элементам списка
fruits = ["яблоко", "банан", "вишня"]
for fruit in fruits:
    print(fruit)

# Использование enumerate для получения индекса
for index, fruit in enumerate(fruits):
    print(f"Индекс: {index}, Фрукт: {fruit}")

# Цикл for с условием continue
for i in range(10):
    if i % 2 == 0:  # Пропускаем четные числа
        continue
    print(f"Нечетное число: {i}")

# Цикл for с условием break
for i in range(100):
    if i > 50:  # Прерываем цикл при i > 50
        break
    print(i)`,
        description: "Цикл for в Python используется для итерации по элементам последовательности (список, кортеж, строка) или другого итерируемого объекта. Функция range() часто используется для генерации последовательности чисел. Важно помнить, что range(1, 100) генерирует числа от 1 до 99 (включительно). Ключевые слова break и continue позволяют управлять потоком выполнения цикла."
    },
    {
        id: 2,
        title: "Работа со списками",
        tag: "Списки",
        shortDesc: "Основные операции со списками в Python",
        code: `# Создание списка
my_list = [1, 2, 3, 4, 5]

# Добавление элементов
my_list.append(6)  # Добавить в конец
my_list.insert(0, 0)  # Вставить на позицию 0

# Удаление элементов
my_list.remove(3)  # Удалить элемент со значением 3
popped = my_list.pop()  # Удалить и вернуть последний элемент

# Срезы (slices)
first_three = my_list[:3]  # Первые три элемента
last_two = my_list[-2:]  # Последние два элемента
reversed_list = my_list[::-1]  # Развернутый список

# Генераторы списков
squares = [x**2 for x in range(10)]  # Квадраты чисел от 0 до 9
even_squares = [x**2 for x in range(10) if x % 2 == 0]  # Только четные

# Сортировка списка
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
numbers.sort()  # Сортировка на месте
sorted_numbers = sorted(numbers, reverse=True)  # Возвращает новый список

# Объединение списков
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined = list1 + list2  # [1, 2, 3, 4, 5, 6]`,
        description: "Списки в Python - это изменяемые упорядоченные коллекции, которые могут содержать элементы разных типов. Они поддерживают различные операции: добавление, удаление, срезы, сортировку и многое другое. Генераторы списков предоставляют лаконичный способ создания новых списков на основе существующих. Списки являются одним из наиболее часто используемых типов данных в Python благодаря своей гибкости и производительности."
    },
    {
        id: 3,
        title: "Функции с аргументами",
        tag: "Функции",
        shortDesc: "Создание функций с различными типами аргументов",
        code: `# Простая функция
def greet(name):
    return f"Привет, {name}!"

# Функция с аргументами по умолчанию
def greet_person(name, greeting="Здравствуйте"):
    return f"{greeting}, {name}!"

# Функция с произвольным числом аргументов
def sum_all(*args):
    return sum(args)

# Функция с произвольным числом ключевых аргументов
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

# Комбинирование разных типов аргументов
def complex_func(a, b=10, *args, **kwargs):
    result = a + b + sum(args)
    print(f"Результат: {result}")
    if kwargs:
        print("Дополнительные параметры:", kwargs)
    return result

# Аннотации типов
def add_numbers(a: int, b: int) -> int:
    """Складывает два числа и возвращает результат."""
    return a + b

# Лямбда-функции
square = lambda x: x ** 2
numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(square, numbers))

# Вызов функций
print(greet("Анна"))
print(greet_person("Иван", "Добрый день"))
print(sum_all(1, 2, 3, 4, 5))
print_info(name="Мария", age=25, city="Москва")
complex_func(5, 20, 1, 2, 3, option="test", flag=True)`,
        description: "В Python функции могут принимать различные типы аргументов: позиционные, аргументы по умолчанию, произвольное количество позиционных аргументов (*args) и произвольное количество ключевых аргументов (**kwargs). Это делает функции гибкими и мощными инструментами для структурирования кода. Аннотации типов помогают документировать код и улучшают поддержку в IDE. Лямбда-функции предоставляют способ создания анонимных функций для простых операций."
    },
    {
        id: 4,
        title: "Обработка исключений",
        tag: "Обработка ошибок",
        shortDesc: "Блоки try-except для обработки ошибок",
        code: `# Базовый try-except
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Ошибка: деление на ноль!")

# Несколько исключений
try:
    number = int(input("Введите число: "))
    result = 100 / number
    print(f"Результат: {result}")
except ValueError:
    print("Ошибка: введите корректное число!")
except ZeroDivisionError:
    print("Ошибка: нельзя делить на ноль!")
except Exception as e:
    print(f"Произошла ошибка: {e}")

# Блок else (выполняется если не было исключений)
try:
    file = open("example.txt", "r")
except FileNotFoundError:
    print("Файл не найден!")
else:
    content = file.read()
    print(content)
    file.close()

# Блок finally (выполняется всегда)
try:
    data = {"key": "value"}
    print(data["missing_key"])
except KeyError:
    print("Ключ не найден!")
finally:
    print("Этот код выполнится в любом случае")

# Создание собственных исключений
class NegativeNumberError(Exception):
    """Исключение при передаче отрицательного числа."""
    pass

def check_positive(number):
    if number < 0:
        raise NegativeNumberError("Число не должно быть отрицательным")
    return number

# Контекстный менеджер для обработки ошибок
from contextlib import suppress

with suppress(FileNotFoundError):
    with open("несуществующий_файл.txt") as f:
        content = f.read()`,
        description: "Обработка исключений в Python выполняется с помощью блоков try-except. Это позволяет программе корректно обрабатывать ошибки и продолжать выполнение. Можно обрабатывать конкретные типы исключений или все сразу. Блоки else и finally предоставляют дополнительный контроль над потоком выполнения. Создание собственных исключений позволяет лучше структурировать код и передавать информацию об ошибках. Контекстный менеджер suppress из модуля contextlib позволяет игнорировать определенные исключения."
    },
    {
        id: 5,
        title: "Работа со словарями",
        tag: "Словари",
        shortDesc: "Основные операции со словарями в Python",
        code: `# Создание словаря
person = {
    "name": "Иван",
    "age": 30,
    "city": "Москва"
}

# Доступ к элементам
print(person["name"])  # Иван
print(person.get("age"))  # 30
print(person.get("country", "Россия"))  # Россия (значение по умолчанию)

# Изменение и добавление элементов
person["age"] = 31  # Изменение
person["country"] = "Россия"  # Добавление

# Удаление элементов
del person["city"]  # Удаление ключа
age = person.pop("age")  # Удаление с возвратом значения
person.popitem()  # Удаление последней пары ключ-значение

# Итерация по словарю
for key in person:  # Только ключи
    print(key)

for value in person.values():  # Только значения
    print(value)

for key, value in person.items():  # Ключи и значения
    print(f"{key}: {value}")

# Генераторы словарей
squares = {x: x**2 for x in range(1, 6)}  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# Объединение словарей (Python 3.9+)
dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}
merged = dict1 | dict2  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}

# Вложенные словари
users = {
    "user1": {"name": "Анна", "age": 25},
    "user2": {"name": "Петр", "age": 30}
}

# Получение вложенного значения
print(users["user1"]["name"])  # Анна

# Метод setdefault
person.setdefault("email", "unknown@example.com")  # Устанавливает значение по умолчанию если ключа нет`,
        description: "Словари в Python - это неупорядоченные коллекции пар ключ-значение (начиная с Python 3.7 они сохраняют порядок вставки). Ключи должны быть уникальными и неизменяемыми (строки, числа, кортежи). Словари обеспечивают быстрый доступ к значениям по ключу. Методы get(), items(), keys(), values() и update() делают работу со словарями удобной и эффективной. Словари часто используются для хранения структурированных данных и конфигураций."
    },
    {
        id: 6,
        title: "Контекстные менеджеры",
        tag: "Шаблоны",
        shortDesc: "Использование with для работы с ресурсами",
        code: `# Работа с файлами (самый частый пример)
with open("example.txt", "r", encoding="utf-8") as file:
    content = file.read()
    print(content)
# Файл автоматически закроется здесь

# Запись в файл
with open("output.txt", "w") as file:
    file.write("Привет, мир!")

# Создание собственного контекстного менеджера с помощью класса
import time

class Timer:
    def __init__(self, name):
        self.name = name
    
    def __enter__(self):
        self.start = time.time()
        print(f"Запуск {self.name}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end = time.time()
        print(f"{self.name} выполнен за {self.end - self.start:.2f} секунд")
        return False  # Исключения не подавляются

# Использование собственного контекстного менеджера
with Timer("Операция"):
    time.sleep(1)  # Имитация длительной операции
    print("Выполняю операцию...")

# Контекстный менеджер для временного изменения состояния
import os

class ChangeDirectory:
    def __init__(self, new_path):
        self.new_path = new_path
        self.old_path = None
    
    def __enter__(self):
        self.old_path = os.getcwd()
        os.chdir(self.new_path)
        print(f"Переход в директорию: {self.new_path}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        os.chdir(self.old_path)
        print(f"Возврат в директорию: {self.old_path}")
        return False

# Использование
with ChangeDirectory("/tmp"):
    print("Содержимое директории:", os.listdir("."))`,
        description: "Контекстные менеджеры в Python позволяют корректно управлять ресурсами (файлы, сетевые соединения, блокировки) с использованием оператора with. Они гарантируют, что ресурсы будут освобождены даже при возникновении исключений. Можно создавать собственные контекстные менеджеры с помощью классов, реализующих методы __enter__ и __exit__. Контекстные менеджеры улучшают читаемость кода и предотвращают утечки ресурсов."
    },
    {
        "id": 7,
        "title": "Определение и вызов функции",
        "tag": "Функции",
        "shortDesc": "Базовый синтаксис создания и использования функций в Python",
        "code": `# Определение функции с помощью ключевого слова def
def greet(name):
    """
    Функция приветствия пользователя.
    Принимает один аргумент - имя (name).
    """
    # Тело функции начинается с отступа
    print(f"Привет, {name}! Рад тебя видеть.")
    # Функция может возвращать значение с помощью return
    return f"Приветствие для {name} отправлено."

# Вызов функции. Указываем её имя и передаём аргумент в скобках.
result = greet("Анна")  # Аргумент "Анна" будет присвоен параметру name внутри функции
print(result)  # Печатаем то, что вернула функция (return value)

# Функция может быть вызвана несколько раз с разными аргументами
greet("Петр")
greet("Мария")

# Функция с несколькими параметрами и значением по умолчанию
def introduce(name, age, city="Москва"):
    print(f"Меня зовут {name}, мне {age} лет, я из {city}.")

# Вызов с передачей всех аргументов по порядку (позиционные аргументы)
introduce("Сергей", 25, "Казань")

# Вызов с использованием именованных аргументов (keyword arguments)
introduce(age=30, name="Ольга", city="Санкт-Петербург")

# Вызов с использованием значения по умолчанию для city
introduce("Иван", 22)  # city будет равно "Москва"`,
        "description": "Функции — это блоки многократно используемого кода, предназначенные для выполнения конкретной задачи. Они определяются с помощью ключевого слова `def`, за которым следует имя функции и круглые скобки `()` с параметрами. Тело функции выделяется отступом. Функции могут принимать аргументы (позиционные или именованные), могут иметь параметры со значениями по умолчанию. Для возврата результата используется оператор `return`. Если `return` отсутствует, функция возвращает `None`. Вызов функции осуществляется по её имени с передачей необходимых аргументов."
    },
    {
        "id": 8,
        "title": "Создание и использование класса",
        "tag": "Класс",
        "shortDesc": "Основы объектно-ориентированного программирования: классы, объекты, атрибуты и методы",
        "code": `# Определение класса с помощью ключевого слова class
class Dog:
    """
    Класс, описывающий собаку.
    __init__ - это специальный метод (конструктор), который вызывается при создании нового объекта (экземпляра) класса.
    self - ссылка на сам создаваемый экземпляр, всегда первый параметр метода экземпляра.
    """
    def __init__(self, name, breed, age):
        # Инициализация атрибутов экземпляра
        # Атрибуты - это переменные, принадлежащие объекту.
        self.name = name   # Атрибут 'name'
        self.breed = breed # Атрибут 'breed'
        self.age = age     # Атрибут 'age'
        self.is_hungry = True  # Атрибут можно инициализировать константой

    # Метод экземпляра - функция, принадлежащая объекту класса.
    def bark(self):
        print(f"{self.name} говорит: Гав-гав!")

    def eat(self):
        if self.is_hungry:
            print(f"{self.name} кушает.")
            self.is_hungry = False  # Метод может менять состояние объекта
        else:
            print(f"{self.name} не голоден.")

    def info(self):
        # Метод имеет доступ ко всем атрибутам через self
        return f"Собака: {self.name}, Порода: {self.breed}, Возраст: {self.age}"

# Создание объектов (экземпляров) класса Dog
my_dog = Dog("Барсик", "Дворняжка", 5)  # Вызывается __init__
friends_dog = Dog("Рекс", "Овчарка", 3)

# Доступ к атрибутам объекта используя точечную нотацию
print(my_dog.name)  # Вывод: Барсик
print(friends_dog.breed)  # Вывод: Овчарка

# Вызов методов объекта
my_dog.bark()  # Вывод: Барсик говорит: Гав-гав!
friends_dog.bark()

print(my_dog.info())  # Вывод: Собака: Барсик, Порода: Дворняжка, Возраст: 5

# Изменение атрибута объекта напрямую
my_dog.age = 6
print(my_dog.info())  # Возраст обновился

# Работа с состоянием объекта через методы
print(my_dog.is_hungry)  # True
my_dog.eat()             # Барсик кушает.
print(my_dog.is_hungry)  # False
my_dog.eat()             # Барсик не голоден.`,
        "description": "Класс — это шаблон или чертеж для создания объектов. Он объединяет данные (атрибуты) и методы (функции), которые работают с этими данными. Объект (экземпляр) — это конкретная реализация класса. Метод `__init__` является конструктором и вызывается автоматически при создании нового объекта. Параметр `self` обязателен для методов экземпляра и ссылается на текущий объект. Атрибуты объекта хранят его состояние, а методы определяют его поведение. Принципы ООП, такие как инкапсуляция, здесь показаны через объединение данных и методов внутри класса."
    },
    {
        "id": 9,
        "title": "Базовые операции со списками",
        "tag": "Списки",
        "shortDesc": "Создание, индексация, срезы и основные методы для работы со списками",
        "code": `# Создание списка. Списки заключаются в квадратные скобки [].
fruits = ["яблоко", "банан", "апельсин", "киви", "груша"]
numbers = [1, 2, 3, 4, 5]
mixed_list = [10, "текст", True, 3.14]  # Список может содержать элементы разных типов

# Индексация (начинается с 0)
first_fruit = fruits[0]   # "яблоко" - первый элемент
second_fruit = fruits[1]  # "банан"  - второй элемент
last_fruit = fruits[-1]   # "груша"  - последний элемент (отрицательный индекс)
pre_last = fruits[-2]     # "киви"   - предпоследний элемент

print(f"Первый фрукт: {first_fruit}, Последний фрукт: {last_fruit}")

# Срезы (slicing) [start:stop:step]
# Возвращают новый список.
first_two = fruits[0:2]    # Элементы с индексами 0 и 1: ["яблоко", "банан"]
slice_middle = fruits[1:4] # Элементы с индексами 1, 2, 3: ["банан", "апельсин", "киви"]
copy_all = fruits[:]       # Копия всего списка
every_second = fruits[::2] # Каждый второй элемент: ["яблоко", "апельсин", "груша"]
reversed_list = fruits[::-1] # Список в обратном порядке

print(f"Срез [1:4]: {slice_middle}")
print(f"Реверс: {reversed_list}")

# Изменение элементов списка (списки изменяемы - mutable)
fruits[1] = "манго"  # Заменяем "банан" на "манго"
print(f"После замены: {fruits}")

# Основные методы списков
fruits.append("виноград")  # Добавляет элемент В КОНЕЦ списка
print(f"После append: {fruits}")

fruits.insert(2, "лимон")  # Вставляет "лимон" на позицию с индексом 2
print(f"После insert(2): {fruits}")

removed_item = fruits.pop()  # Удаляет и возвращает ПОСЛЕДНИЙ элемент
print(f"Удален pop(): {removed_item}, Список: {fruits}")

removed_by_index = fruits.pop(0)  # Удаляет и возвращает элемент по индексу 0
print(f"Удален pop(0): {removed_by_index}, Список: {fruits}")

fruits.remove("апельсин")  # Удаляет ПЕРВЫЙ найденный элемент "апельсин"
print(f"После remove('апельсин'): {fruits}")

# Поиск и сортировка
if "киви" in fruits:
    print("Киви есть в списке!")

index_of_kiwi = fruits.index("киви")  # Возвращает индекс первого вхождения "киви"
print(f"Индекс 'киви': {index_of_kiwi}")

fruits.sort()  # Сортирует список по возрастанию (на месте, меняет исходный)
print(f"После sort(): {fruits}")

numbers.reverse()  # Разворачивает список на месте
print(f"После reverse(): {numbers}")`,
        "description": "Список (list) — это упорядоченная, изменяемая коллекция произвольных объектов. Поддерживает индексацию (с нуля) и срезы `[start:stop:step]`. Списки имеют множество встроенных методов для добавления (`append`, `insert`), удаления (`pop`, `remove`, `clear`), поиска (`index`, `count`), сортировки (`sort`) и других операций. Списки являются изменяемыми (mutable), что позволяет модифицировать их содержимое после создания. Для создания копии списка (а не ссылки) используйте срез `list_copy = original_list[:]` или метод `list_copy = original_list.copy()`."
    },
    {
        "id": 10,
        "title": "Работа со словарями (dict)",
        "tag": "Словари",
        "shortDesc": "Создание, доступ, добавление, удаление элементов и методы словарей",
        "code": `# Создание словаря. Словарь состоит из пар ключ:значение в фигурных скобках {}.
student = {
    "name": "Иван Петров",
    "age": 20,
    "university": "МГУ",
    "course": 3,
    "has_scholarship": True
}
# Ключи должны быть неизменяемыми типами (строки, числа, кортежи).
# Значения могут быть любыми типами.

print(f"Весь словарь: {student}")

# Доступ к значению по ключу (через квадратные скобки)
name = student["name"]
age = student["age"]
print(f"Студент: {name}, Возраст: {age}")

# Метод get() - безопасный доступ. Возвращает None или значение по умолчанию, если ключа нет.
phone = student.get("phone")  # Ключа 'phone' нет -> вернёт None
phone_safe = student.get("phone", "не указан")  # Вернёт "не указан", если ключа нет
print(f"Телефон: {phone_safe}")

# Добавление новой пары ключ-значение или изменение существующей
student["phone"] = "+7-999-123-45-67"  # Добавляем новый ключ
student["age"] = 21                     # Изменяем значение существующего ключа
print(f"После обновления: {student}")

# Удаление элемента
del student["has_scholarship"]          # Удаление ключа оператором del
print(f"После del: {student}")

removed_value = student.pop("course")   # Удаление ключа с возвратом его значения
print(f"Удалён курс: {removed_value}. Теперь словарь: {student}")

# Методы для получения ключей, значений и пар
keys_list = list(student.keys())     # Получаем все ключи в виде объекта dict_keys, преобразуем в список
values_list = list(student.values()) # Получаем все значения в виде объекта dict_values
items_list = list(student.items())   # Получаем все пары (ключ, значение) в виде кортежей

print(f"Ключи: {keys_list}")
print(f"Значения: {values_list}")
print(f"Пары (items): {items_list}")

# Итерация по словарю
print("\nИтерация по ключам:")
for key in student:
    print(f"Ключ: {key}")

print("\nИтерация по значениям:")
for value in student.values():
    print(f"Значение: {value}")

print("\nИтерация по парам ключ-значение:")
for key, value in student.items():
    print(f"{key}: {value}")

# Проверка наличия ключа
if "university" in student:
    print(f"\nУниверситет студента: {student['university']}")

# Вложенные словари (словари внутри словаря)
library = {
    "book1": {"title": "Война и мир", "author": "Толстой", "year": 1869},
    "book2": {"title": "Преступление и наказание", "author": "Достоевский", "year": 1866}
}
print(f"\nАвтор первой книги: {library['book1']['author']}")`,
        "description": "Словарь (dict) — это неупорядоченная (до Python 3.7) / упорядоченная (с Python 3.7) коллекция пар «ключ-значение». Ключи должны быть уникальными и неизменяемыми (строки, числа, кортежи), значения — любые объекты. Доступ к значению осуществляется по ключу через оператор `[]` или безопасный метод `.get()`. Словари изменяемы: можно добавлять, изменять и удалять элементы. Основные методы: `.keys()`, `.values()`, `.items()` для получения представлений ключей, значений и пар; `.pop(key)` для удаления с возвратом значения; `.update()` для обновления. Итерация по словарю по умолчанию происходит по ключам."
    },
    {
        "id": 11,
        "title": "Обработка строк (текста)",
        "tag": "Текста",
        "shortDesc": "Методы строк, форматирование, поиск и замена подстрок",
        "code": `# Строка - неизменяемая (immutable) последовательность символов.
text = "  Привет, мир! Сегодня отличный день.  "

# Базовые методы изменения регистра
upper_text = text.upper()      # Все символы в верхний регистр
lower_text = text.lower()      # Все символы в нижний регистр
title_text = text.title()      # Первая буква каждого слова - заглавная
print(f"upper: {upper_text}")
print(f"title: {title_text}")

# Удаление пробелов и символов
stripped_text = text.strip()   # Удаляет пробелы с обоих концов
l_stripped = text.lstrip()     # Удаляет пробелы только слева (l - left)
r_stripped = text.rstrip()     # Удаляет пробелы только справа (r - right)
print(f"strip: '{stripped_text}'")
print(f"lstrip: '{l_stripped}'")

# Поиск и замена подстрок
index_of_mir = text.find("мир")      # Возвращает индекс ПЕРВОГО вхождения подстроки
print(f"Индекс 'мир': {index_of_mir}") # Если не найдено, вернёт -1

count_o = text.count("о")            # Считает количество вхождений подстроки
print(f"Количество букв 'о': {count_o}")

new_text = text.replace("день", "вечер")  # Заменяет ВСЕ вхождения 'день' на 'вечер'
print(f"После replace: {new_text}")

# Проверка начала и конца строки
if text.startswith("  Привет"):
    print("Строка начинается с '  Привет'")

if text.endswith("день.  "):
    print("Строка заканчивается на 'день.  '")

# Разделение строки на список подстрок
words = stripped_text.split()        # Разделение по пробелам (по умолчанию)
print(f"Список слов: {words}")

date_str = "2024-12-05"
parts = date_str.split("-")          # Разделение по указанному разделителю
print(f"Части даты: {parts}")

# Соединение списка строк в одну строку
new_date = "/".join(parts)           # Объединение элементов списка через '/'
print(f"Новая дата: {new_date}")

# Форматирование строк (f-strings, начиная с Python 3.6)
name = "Алексей"
score = 95.5
# Внутри f-строки в фигурных скобках можно писать выражения
formatted = f"Студент {name} набрал {score} баллов. Это {score/100:.1%} от максимума."
print(formatted)

# Многострочные строки и управляющие последовательности
multiline = """Это первая строка.
Это вторая строка.
А это третья, с табуляцией ->\tздесь.
И с новой строки ->\nздесь."""
print(f"\nМногострочная строка:\n{multiline}")

# Проверка содержимого строки
numeric_str = "12345"
alpha_str = "Hello"
print(f"'12345' состоит только из цифр? {numeric_str.isdigit()}")
print(f"'Hello' состоит только из букв? {alpha_str.isalpha()}")
print(f"'Hello123' состоит из букв и цифр? {'Hello123'.isalnum()}")`,
        "description": "Строка (str) — это неизменяемая последовательность Unicode-символов. Имеет богатый набор методов для работы: изменение регистра (`upper`, `lower`, `title`), удаление пробелов (`strip`), поиск (`find`, `index`, `count`), замена (`replace`), проверка (`startswith`, `endswith`, `isdigit`), разбиение на список (`split`) и объединение (`join`). Наиболее современный и удобный способ форматирования — f-строки (f\"...{выражение}...\"), которые позволяют встраивать выражения прямо в строку. Строки поддерживают индексацию и срезы, как и списки."
    },
    {
        "id": 12,
        "title": "Операции с числами и математический модуль",
        "tag": "Числа",
        "shortDesc": "Работа с целыми, вещественными числами, основные операции и использование модуля math",
        "code": `# Целые числа (int)
a = 10
b = 3

# Базовые арифметические операции
sum_ab = a + b    # Сложение
diff_ab = a - b   # Вычитание
prod_ab = a * b   # Умножение
div_ab = a / b    # Деление. Всегда возвращает float (даже если делится нацело)
floor_div = a // b # Целочисленное деление (отбрасывает дробную часть)
mod_ab = a % b    # Остаток от деления (модуль)
power_ab = a ** b # Возведение в степень (10^3)

print(f"a + b = {sum_ab}")
print(f"a / b = {div_ab} (тип: {type(div_ab)})")
print(f"a // b = {floor_div}")
print(f"a % b = {mod_ab}")
print(f"a ** b = {power_ab}")

# Вещественные числа (float)
x = 3.14
y = 2.5
print(f"\nx * y = {x * y}")

# Осторожно: погрешность вычислений с float
print(0.1 + 0.2)  # Выведет: 0.30000000000000004 (а не ровно 0.3)

# Преобразование типов
int_from_float = int(3.99)  # Дробная часть отбрасывается (не округление!)
float_from_int = float(7)
str_to_int = int("42")
# Важно: int("3.14") вызовет ошибку, нужно сначала преобразовать в float

print(f"int(3.99) = {int_from_float}")
print(f"float(7) = {float_from_int}")

# Модуль math для сложных математических операций
import math

print(f"\n--- Использование модуля math ---")
print(f"math.sqrt(16) = {math.sqrt(16)}")          # Квадратный корень
print(f"math.pow(2, 8) = {math.pow(2, 8)}")       # Возведение в степень (2^8)
print(f"math.fabs(-5.7) = {math.fabs(-5.7)}")     # Модуль числа (абсолютное значение)
print(f"math.floor(3.99) = {math.floor(3.99)}")   # Округление вниз
print(f"math.ceil(3.01) = {math.ceil(3.01)}")     # Округление вверх
print(f"math.pi = {math.pi}")                     # Константа π
print(f"math.sin(math.pi/2) = {math.sin(math.pi/2)}") # Синус 90 градусов

# Генерация случайных чисел (модуль random)
import random
print(f"\n--- Генерация случайных чисел ---")
rand_int = random.randint(1, 100)     # Случайное целое от 1 до 100 включительно
rand_float = random.random()          # Случайное float от 0.0 до 1.0
rand_choice = random.choice(['a', 'b', 'c']) # Случайный элемент последовательности

print(f"Случайное целое [1, 100]: {rand_int}")
print(f"Случайное float [0.0, 1.0): {rand_float}")
print(f"Случайный выбор из списка: {rand_choice}")`,
        "description": "Python поддерживает целые (`int`), вещественные (`float`) и комплексные числа. Основные арифметические операторы: `+`, `-`, `*`, `/` (всегда возвращает `float`), `//` (целочисленное деление), `%` (остаток), `**` (степень). Важно помнить о погрешности представления вещественных чисел в двоичном виде. Для сложных математических операций используется встроенный модуль `math`, предоставляющий функции (корень, тригонометрия, логарифмы) и константы (π, e). Для преобразования типов используются функции `int()`, `float()`. Модуль `random` используется для генерации случайных чисел."
    },
    {
        "id": 13,
        "title": "Создание и импорт собственных модулей",
        "tag": "Модули",
        "shortDesc": "Структура модуля, его импорт и использование",
        "code": `# ========== ФАЙЛ: geometry.py (наш создаваемый модуль) ==========
"""
Модуль geometry - содержит функции для вычисления геометрических величин.
Это строка документации (docstring) модуля.
"""

# Определение константы в модуле
PI = 3.141592653589793

def circle_area(radius):
    """Возвращает площадь круга по заданному радиусу."""
    return PI * (radius ** 2)

def rectangle_area(length, width):
    """Возвращает площадь прямоугольника."""
    return length * width

def triangle_area(base, height):
    """Возвращает площадь треугольника."""
    return 0.5 * base * height

# Этот код выполнится только если модуль запущен напрямую, а не импортирован.
# Позволяет тестировать модуль.
if __name__ == "__main__":
    print("Тестирование модуля geometry:")
    print(f"Площадь круга радиусом 5: {circle_area(5)}")
    print(f"Площадь прямоугольника 3x4: {rectangle_area(3, 4)}")

# ========== ФАЙЛ: main.py (основная программа) ==========
# Здесь показаны различные способы импорта созданного модуля geometry

# 1. Импорт всего модуля
import geometry

# Доступ к функциям и константам через имя модуля (точечная нотация)
area_circle = geometry.circle_area(10)
print(f"Площадь круга (радиус=10): {area_circle}")
print(f"Константа PI из модуля: {geometry.PI}")

# 2. Импорт с псевдонимом (alias) - удобно для длинных имён
import geometry as geom
area_rect = geom.rectangle_area(5, 6)
print(f"Площадь прямоугольника 5x6: {area_rect}")

# 3. Импорт конкретных функций/констант из модуля
from geometry import triangle_area, PI
# Теперь можно использовать их напрямую, без указания имени модуля
area_triangle = triangle_area(4, 7)
print(f"Площадь треугольника (осн=4, выс=7): {area_triangle}")
print(f"PI (импортированная константа): {PI}")

# 4. Импорт всего содержимого модуля (не рекомендуется из-за загрязнения пространства имён)
# from geometry import *
# print(circle_area(2))  # Работает, но может быть конфликт имен

# Проверка, как был запущен модуль geometry
print(f"\nИмя модуля geometry при импорте: {geometry.__name__}")
print(f"Имя текущего модуля (main.py): {__name__}")  # Будет "__main__"`,
        "description": "Модуль в Python — это просто файл с расширением `.py`, содержащий определения (функции, классы, переменные). Модули используются для структурирования кода и его повторного использования. Импорт модуля выполняется с помощью ключевого слова `import`. Существует несколько стилей импорта: импорт всего модуля (`import module_name`), импорт с псевдонимом (`import module_name as alias`), импорт конкретных объектов (`from module_name import func1, var1`). Специальная переменная `__name__` содержит имя модуля. Если модуль запущен как основная программа, `__name__` устанавливается в `\"__main__\"`, что позволяет писать код для тестирования модуля внутри условия `if __name__ == \"__main__\":`."
    },
    {
        "id": 14,
        "title": "Работа с датой и временем (datetime)",
        "tag": "Встроенные модули",
        "shortDesc": "Использование встроенного модуля datetime для работы с датами и временем",
        "code": `# Модуль datetime является частью стандартной библиотеки Python.
import datetime

# ========== ТЕКУЩАЯ ДАТА И ВРЕМЯ ==========
now = datetime.datetime.now()  # Возвращает объект datetime с текущей датой и временем
print(f"Текущие дата и время: {now}")
print(f"Только год: {now.year}")
print(f"Только месяц: {now.month}")
print(f"Только день: {now.day}")
print(f"Часы: {now.hour}")
print(f"Минуты: {now.minute}")
print(f"Секунды: {now.second}")

today = datetime.date.today()  # Возвращает объект date (только дата, без времени)
print(f"\nСегодняшняя дата: {today}")
print(f"День недели (0=Пн, 6=Вс): {today.weekday()}")  # 0 - понедельник
print(f"День недели (1=Пн, 7=Вс): {today.isoweekday()}") # 1 - понедельник

# ========== СОЗДАНИЕ ОБЪЕКТОВ ДАТЫ И ВРЕМЕНИ ==========
# Создание конкретной даты
some_date = datetime.date(2024, 12, 5)  # (год, месяц, день)
print(f"\nЗаданная дата: {some_date}")

# Создание конкретного времени
some_time = datetime.time(14, 30, 15)  # (часы, минуты, секунды)
print(f"Заданное время: {some_time}")

# Создание полного объекта datetime
new_year = datetime.datetime(2025, 1, 1, 0, 0, 0)
print(f"Дата и время Нового года 2025: {new_year}")

# ========== ОПЕРАЦИИ С ДАТАМИ (timedelta) ==========
# timedelta представляет разницу между двумя датами/временем
delta = datetime.timedelta(days=7, hours=3, minutes=30)
print(f"\ntimedelta: {delta} (7 дней, 3 часа, 30 минут)")

# Прибавление и вычитание timedelta из даты
week_later = today + datetime.timedelta(days=7)
yesterday = today - datetime.timedelta(days=1)
print(f"Через неделю от сегодня: {week_later}")
print(f"Вчера было: {yesterday}")

# Разница между двумя датами (возвращает timedelta)
date1 = datetime.date(2024, 1, 1)
date2 = datetime.date(2024, 12, 31)
difference = date2 - date1
print(f"\nМежду {date1} и {date2} прошло {difference.days} дней.")

# ========== ФОРМАТИРОВАНИЕ И ПАРСИНГ СТРОК ==========
# strftime (datetime -> string) - форматирование даты в строку
formatted_date = now.strftime("%d.%m.%Y %H:%M:%S")
print(f"\nФорматированная дата (strftime): {formatted_date}")
# %d - день (01-31), %m - месяц (01-12), %Y - год (4 цифры)
# %H - час (00-23), %M - минуты (00-59), %S - секунды (00-59)

# strptime (string -> datetime) - парсинг строки в дату
date_string = "25.12.2024 20:00"
parsed_date = datetime.datetime.strptime(date_string, "%d.%m.%Y %H:%M")
print(f"Распарсенная дата (strptime): {parsed_date}")

# ========== СРАВНЕНИЕ ДАТ ==========
if new_year > now:
    print(f"\nНовый год 2025 ещё не наступил!")
elif new_year < now:
    print(f"Новый год 2025 уже прошёл!")
else:
    print(f"Сейчас именно Новый год 2025!")`,
        "description": "Модуль `datetime` предоставляет классы для манипуляции датами и временем. Основные классы: `datetime` (дата и время вместе), `date` (только дата), `time` (только время), `timedelta` (разница между моментами времени, используется для арифметики с датами). Метод `datetime.now()` возвращает текущие дату и время. Метод `strftime(format)` преобразует объект datetime в строку по заданному формату. Метод `strptime(string, format)` выполняет обратное преобразование из строки в datetime. Класс `timedelta` позволяет прибавлять/вычитать интервалы времени. Объекты дат можно сравнивать операторами `>`, `<`, `==`."
    },
    {
        "id": 15,
        "title": "Обработка исключений (try/except/finally)",
        "tag": "Обработка ошибок",
        "shortDesc": "Конструкция try-except для перехвата и обработки ошибок (исключений)",
        "code": `# Исключения (exceptions) - это ошибки, возникающие во время выполнения программы.
# Без обработки исключений программа аварийно завершается.

# ========== БАЗОВАЯ КОНСТРУКЦИЯ try-except ==========
print("=== Пример 1: Деление на ноль ===")
try:
    # Код, который может вызвать исключение
    numerator = 10
    denominator = 0
    result = numerator / denominator  # Попытка деления на ноль -> ZeroDivisionError
    print(f"Результат: {result}")
except ZeroDivisionError:
    # Этот блок выполняется, если в блоке try возникло указанное исключение
    print("Ошибка! Нельзя делить на ноль.")

print("Программа продолжает работу после обработки ошибки.\n")

# ========== ОБРАБОТКА НЕСКОЛЬКИХ ИСКЛЮЧЕНИЙ ==========
print("=== Пример 2: Преобразование строки в число ===")
user_input = "abc"  # Не число
try:
    number = int(user_input)  # Может вызвать ValueError
    print(f"Введенное число: {number}")
except ValueError as e:
    # Переменная 'e' содержит объект исключения с информацией об ошибке
    print(f"Ошибка преобразования в число: {e}")
except TypeError:
    # Можно указать несколько блоков except для разных типов исключений
    print("Ошибка типа данных.")
except Exception as general_error:
    # Exception - базовый класс для всех встроенных исключений.
    # Ловит всё, что не поймали предыдущие except.
    print(f"Произошла неизвестная ошибка: {general_error}")
else:
    # Блок else выполняется ТОЛЬКО если в try не было исключений.
    print("Преобразование прошло успешно!")
finally:
    # Блок finally выполняется ВСЕГДА, независимо от того, было исключение или нет.
    # Часто используется для освобождения ресурсов (закрытие файлов, соединений).
    print("Блок finally: выполняется в любом случае.\n")

# ========== ВЫБРОС ИСКЛЮЧЕНИЙ С ПОМОЩЬЮ raise ==========
print("=== Пример 3: Проверка возраста ===")
def check_age(age):
    """Проверяет, является ли возраст допустимым."""
    if age < 0:
        # Создаём и выбрасываем исключение ValueError с пользовательским сообщением
        raise ValueError("Возраст не может быть отрицательным!")
    elif age > 150:
        raise ValueError("Слишком большой возраст!")
    else:
        print(f"Возраст {age} корректен.")
    return age

try:
    check_age(-5)  # Вызовет исключение
except ValueError as e:
    print(f"Поймали ошибку: {e}")

try:
    check_age(25)  # Выполнится успешно
except ValueError as e:
    print(f"Поймали ошибку: {e}")

# ========== СОЗДАНИЕ ПОЛЬЗОВАТЕЛЬСКОГО ИСКЛЮЧЕНИЯ ==========
print("\n=== Пример 4: Своё исключение ===")
# Пользовательские исключения создаются путём наследования от класса Exception
class NegativeBalanceError(Exception):
    """Исключение, вызываемое при отрицательном балансе."""
    pass  # Можно оставить пустым или добавить свою логику

def withdraw(balance, amount):
    if amount > balance:
        raise NegativeBalanceError(f"Недостаточно средств. Баланс: {balance}, запрошено: {amount}")
    balance -= amount
    print(f"Снято {amount}. Новый баланс: {balance}")
    return balance

try:
    account_balance = 100
    account_balance = withdraw(account_balance, 150)  # Вызовет наше исключение
except NegativeBalanceError as e:
    print(f"Ошибка операции: {e}")`,
        "description": "Обработка исключений — это механизм перехвата и обработки ошибок времени выполнения. Блок `try` содержит код, который может вызвать исключение. Блок `except` перехватывает исключение указанного типа (или его подклассы). Можно иметь несколько блоков `except` для разных типов исключений. Блок `else` выполняется, если исключения не было. Блок `finally` выполняется всегда, независимо от наличия исключения, и обычно используется для «очистки» (закрытие файлов, сетевых соединений). Исключения можно генерировать явно с помощью оператора `raise`. Можно создавать собственные классы исключений, наследуясь от `Exception` или его подклассов. Это позволяет структурировать ошибки логики приложения."
    },
    {
        "id": 16,
        "title": "Шаблоны строк (format и f-strings)",
        "tag": "Шаблоны",
        "shortDesc": "Различные способы форматирования строк: метод .format() и f-строки",
        "code": `# ========== МЕТОД .format() ==========
print("=== Метод str.format() ===")

# Простая подстановка по порядку
template1 = "{} любит {}.".format("Кот", "рыбу")
print(template1)  # Кот любит рыбу.

# Подстановка по позиционным индексам (начиная с 0)
template2 = "{0} предпочитает {1}, а {2} предпочитает {0}.".format("Собака", "кость", "Кот")
print(template2)  # Собака предпочитает кость, а Кот предпочитает Собаку.

# Подстановка по именованным аргументам (ключевым словам)
template3 = "Страна: {country}, Столица: {capital}, Население: {population} млн.".format(
    country="Франция",
    capital="Париж",
    population=67.4
)
print(template3)

# Комбинирование позиционных и именованных аргументов
template4 = "Пользователь {0} зарегистрирован {date}.".format("user123", date="05.12.2024")
print(template4)

# Форматирование чисел внутри .format()
# :.2f - округление до 2 знаков после запятой (float)
price = 19.9876
template5 = "Цена: $ {:.2f}".format(price)
print(template5)  # Цена: $19.99

# :d - целое число, :, - разделитель тысяч
big_number = 1000000
template6 = "Число: {:,d}".format(big_number)
print(template6)  # Число: 1,000,000

# Выравнивание текста
# {:<10} - выравнивание по левому краю в поле шириной 10 символов
# {:>10} - по правому краю
# {:^10} - по центру
name = "Иван"
template7 = "|{:<10}|{:^10}|{:>10}|".format(name, name, name)
print(template7)  # |Иван      |   Иван   |      Иван|

# ========== F-СТРОКИ (f-strings, Python 3.6+) ==========
print("\n=== F-строки (рекомендуемый способ) ===")

# Внутри f-строки в фигурных скобках {} можно писать ЛЮБЫЕ выражения Python
user = "Мария"
items = 3
total = 45.60

# Простая подстановка переменных
message1 = f"Покупатель {user} купил {items} товара на сумму {total}."
print(message1)

# Арифметические операции прямо в строке
discount = 0.15
message2 = f"Цена со скидкой: {total * (1 - discount):.2f} рублей."
print(message2)

# Вызов функций и методов
text = "привет мир"
message3 = f"Заглавные буквы: {text.upper()}"
print(message3)

# Условия (тернарный оператор) внутри f-строки
score = 85
message4 = f"Результат: {'Сдал' if score >= 60 else 'Не сдал'} ({score} баллов)"
print(message4)

# Форматирование чисел и дат (те же спецификаторы, что и в .format())
import datetime
now = datetime.datetime.now()
message5 = f"Текущее время: {now:%H:%M:%S %d.%m.%Y}"
print(message5)

balance = 1234567.89
message6 = f"Баланс: {balance:,.2f} руб."  # Разделитель тысяч и 2 знака после запятой
print(message6)

# Выравнивание в f-строках
product = "Ноутбук"
price_f = 75000
# < - по левому краю, ^ - по центру, > - по правому краю, число - ширина поля
message7 = f"|{product:<15}|{price_f:>10,.0f} руб.|"
print(message7)  # |Ноутбук        |    75,000 руб.|

# Многострочные f-строки (используются тройные кавычки)
summary = f"""
Итоговый отчёт
---------------
Пользователь: {user}
Количество позиций: {items}
Общая сумма: {total:.2f} руб.
Скидка применена: {discount:.0%}
"""
print(summary)`,
        "description": "Python предлагает несколько мощных способов форматирования строк. Метод `.format()` использует фигурные скобки `{}` как заполнители, которые заменяются аргументами метода (по позиции, индексу или ключевому слову). Внутри скобок можно указывать спецификаторы формата (`:.2f`, `:,d`, `<10` и т.д.) для управления представлением данных. Более современный и читаемый способ — f-строки (литералы форматированных строк), которые начинаются с `f` или `F` и позволяют вставлять выражения непосредственно в строку внутри `{}`. F-строки поддерживают все возможности `.format()`, включая спецификаторы формата, а также допускают использование любых допустимых выражений Python (вызовы функций, тернарные операторы, арифметика). F-строки работают быстрее и являются предпочтительным методом в Python 3.6+."
    },
    {
        "id": 17,
        "title": "Декораторы функций",
        "tag": "Декораторы",
        "shortDesc": "Синтаксис и создание декораторов для модификации поведения функций",
        "code": `# Декоратор — это функция, которая принимает другую функцию в качестве аргумента,
# добавляет какую-то функциональность и возвращает новую (модифицированную) функцию.
# Используется для изменения или расширения поведения функций без изменения их кода.

# ========== ПРОСТЕЙШИЙ ДЕКОРАТОР (ВРУЧНУЮ) ==========
print("=== Простой декоратор (принцип работы) ===")

def simple_decorator(func):
    """Декоратор, который выводит сообщение до и после вызова функции."""
    def wrapper():
        print(f"[Декоратор] Сейчас будет вызвана функция: {func.__name__}")
        func()  # Вызов оригинальной функции
        print(f"[Декоратор] Функция {func.__name__} завершила работу.\n")
    return wrapper

def say_hello():
    print("Привет, мир!")

# Применяем декоратор "вручную": передаём функцию в декоратор и получаем новую
decorated_function = simple_decorator(say_hello)
decorated_function()  # Вызываем уже декорированную функцию

# ========== СИНТАКСИС ДЕКОРАТОРА ЧЕРЕЗ @ ==========
print("=== Синтаксис @decorator ===")

def my_decorator(func):
    """Декоратор, измеряющий время выполнения функции (заглушка)."""
    def wrapper():
        print("--- Начало работы ---")
        func()
        print("--- Конец работы ---")
    return wrapper

# Применение декоратора к функции с помощью символа @ (синтаксический сахар)
@my_decorator
def show_message():
    print("Это важное сообщение.")

# Теперь при вызове show_message() автоматически будет вызван декорированный вариант
show_message()

# ========== ДЕКОРАТОР ДЛЯ ФУНКЦИЙ С АРГУМЕНТАМИ ==========
print("\n=== Декоратор для функций с аргументами ===")

def smart_decorator(func):
    """
    Универсальный декоратор.
    *args и **kwargs позволяют принимать любое количество позиционных и именованных аргументов.
    """
    def wrapper(*args, **kwargs):
        print(f"Вызов функции {func.__name__} с аргументами: {args}, {kwargs}")
        # Передаём все аргументы в оригинальную функцию
        result = func(*args, **kwargs)
        print(f"Функция вернула: {result}")
        return result  # Важно вернуть результат оригинальной функции!
    return wrapper

@smart_decorator
def add(a, b):
    return a + b

@smart_decorator
def greet_person(name, greeting="Здравствуй"):
    return f"{greeting}, {name}!"

# Декоратор корректно работает с функциями, принимающими разные аргументы
sum_result = add(5, 3)
print(f"Сумма: {sum_result}\n")

greeting_result = greet_person("Анна", greeting="Привет")
print(f"Приветствие: {greeting_result}\n")

# ========== ДЕКОРАТОР С СОБСТВЕННЫМИ АРГУМЕНТАМИ ==========
print("=== Декоратор с параметрами ===")

def repeat(times):
    """
    Декоратор, который вызывает функцию заданное количество раз.
    Это функция, которая возвращает настоящий декоратор.
    """
    def real_decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for i in range(times):
                print(f"Повтор {i+1}/{times}:")
                result = func(*args, **kwargs)
                results.append(result)
            return results  # Возвращаем список всех результатов
        return wrapper
    return real_decorator

# Применяем декоратор с аргументом times=3
@repeat(times=3)
def say_weather():
    return "Сегодня солнечно!"

weather_reports = say_weather()
print(f"Все отчёты: {weather_reports}")

# ========== СОХРАНЕНИЕ МЕТАДАННЫХ ФУНКЦИИ (functools.wraps) ==========
print("\n=== Сохранение метаданных функции ===")
import functools

def preserving_decorator(func):
    """
    Декоратор, который сохраняет имя и документацию оригинальной функции.
    Использует functools.wraps.
    """
    @functools.wraps(func)  # Магический декоратор, который копирует метаданные
    def wrapper(*args, **kwargs):
        print(f"Вызывается {func.__name__}...")
        return func(*args, **kwargs)
    return wrapper

@preserving_decorator
def example_function():
    """Это пример функции с документацией."""
    return "Результат"

print(f"Имя функции: {example_function.__name__}")      # example_function (а не wrapper)
print(f"Документация: {example_function.__doc__}")      # Это пример функции с документацией.
print(f"Результат вызова: {example_function()}")`,
        "description": "Декоратор — это паттерн проектирования, позволяющий динамически изменять или расширять поведение функций или методов без изменения их исходного кода. В Python декоратор — это функция, которая принимает другую функцию в качестве аргумента и возвращает новую функцию (обычно обёртку — `wrapper`). Синтаксис `@decorator_name` применяет декоратор к функции, определённой ниже. Для создания универсальных декораторов, работающих с функциями, имеющими разные сигнатуры, используется `*args` и `**kwargs` внутри функции-обёртки. Декораторы могут иметь и собственные аргументы, для этого создаётся функция, возвращающая настоящий декоратор. Важно использовать `functools.wraps(func)` для сохранения метаданных (имя, документация) оригинальной функции, иначе они будут заменены данными обёртки."
    },
    {
        "id": 18,
        "title": "Генераторы и выражение-генератор (yield)",
        "tag": "Генераторы",
        "shortDesc": "Создание функций-генераторов с yield и генераторных выражений для эффективной работы с последовательностями",
        "code": `# Генератор — это функция, которая возвращает итератор.
# Она может приостанавливать своё выполнение, запоминая состояние, и возобновлять с того же места.
# Ключевое слово yield используется для возврата значения и приостановки функции.

print("=== Функция-генератор (yield) ===")

def simple_generator():
    """Простейший генератор, yield'ящий три значения."""
    print("Генератор запущен.")
    yield 1  # При первом вызове next() выполнится код до этого yield и вернётся 1
    print("Продолжение после первого yield.")
    yield 2  # При следующем вызове next() выполнение продолжится отсюда и вернётся 2
    print("Продолжение после второго yield.")
    yield 3
    print("Генератор завершён.")  # После последнего yield при следующем next() будет StopIteration

# Создание объекта-генератора
gen = simple_generator()
print(f"gen - это объект генератора: {gen}")

# Получение значений по одному с помощью next()
print("\nПолучаем значения через next():")
value1 = next(gen)  # Выполняется до первого yield, печатает "Генератор запущен.", возвращает 1
print(f"Получили: {value1}")
value2 = next(gen)  # Продолжает со строки после первого yield, печатает сообщение, возвращает 2
print(f"Получили: {value2}")
value3 = next(gen)
print(f"Получили: {value3}")

# Попытка следующего вызова next() вызовет исключение StopIteration, так как значений больше нет
# next(gen)  # Раскомментируйте, чтобы увидеть StopIteration

# ========== ПРАКТИЧЕСКИЙ ПРИМЕР: ГЕНЕРАТОР ДЛЯ БОЛЬШИХ ПОСЛЕДОВАТЕЛЬНОСТЕЙ ==========
print("\n=== Генератор для последовательности чисел (экономия памяти) ===")

def countdown(n):
    """Генератор, который возвращает числа от n до 1."""
    print(f"Начало отсчёта с {n}")
    while n > 0:
        yield n  # Возвращает текущее значение n и приостанавливается
        n -= 1   # При следующем вызове next() выполнение продолжится отсюда
    print("Отсчёт завершён!")

# Генератор не хранит всю последовательность в памяти, он вычисляет значения «на лету».
for number in countdown(5):
    print(f"Обратный отсчёт: {number}")

# ========== ГЕНЕРАТОР БЕСКОНЕЧНОЙ ПОСЛЕДОВАТЕЛЬНОСТИ ==========
print("\n=== Бесконечный генератор (например, чисел Фибоначчи) ===")

def fibonacci_generator(limit=None):
    """
    Генератор чисел Фибоначчи.
    Если limit задан, остановится после limit чисел.
    """
    a, b = 0, 1
    count = 0
    while True:
        if limit is not None and count >= limit:
            return  # Завершает генератор
        yield a
        a, b = b, a + b
        count += 1

print("Первые 10 чисел Фибоначчи:")
# Используем генератор в цикле for. Цикл сам обрабатывает StopIteration.
for i, fib_num in enumerate(fibonacci_generator(10)):
    print(f"F({i}) = {fib_num}")

# ========== ВЫРАЖЕНИЕ-ГЕНЕРАТОР (GENERATOR EXPRESSION) ==========
print("\n=== Выражение-генератор (похоже на list comprehension) ===")

# Лист компрехеншн (создаёт список в памяти сразу)
squares_list = [x**2 for x in range(1, 6)]
print(f"Список квадратов: {squares_list} (тип: {type(squares_list)})")

# Выражение-генератор (создаёт генератор, не занимая память под весь список)
squares_gen = (x**2 for x in range(1, 6))  # Круглые скобки вместо квадратных!
print(f"Выражение-генератор: {squares_gen} (тип: {type(squares_gen)})")

# Получаем значения из генератора по одному
print("Значения из генератора:")
for square in squares_gen:
    print(square, end=" ")
print()

# Можно передавать генератор в функции, которые принимают итераторы
print(f"Сумма квадратов через выражение-генератор: {sum(x**2 for x in range(1, 6))}")

# ========== ОТПРАВКА ДАННЫХ В ГЕНЕРАТОР (send) ==========
print("\n=== Отправка данных в генератор с помощью .send() ===")

def interactive_generator():
    """Генератор, который может получать данные извне."""
    total = 0
    while True:
        value = yield total  # yield может не только отдавать, но и принимать значение
        if value is not None:
            total += value
        else:
            total += 1

gen2 = interactive_generator()
next(gen2)  # Необходимо «протолкнуть» генератор до первого yield (это называется priming)
print(f"Текущее total: {gen2.send(None)}")  # send(None) эквивалентно next()
print(f"Текущее total: {gen2.send(5)}")     # Отправляем 5 в генератор, value станет 5, total=5
print(f"Текущее total: {gen2.send(10)}")    # Отправляем 10, total=15
print(f"Текущее total: next(gen2) -> {next(gen2)}")  # value = None, total=16`,
        "description": "Генераторы — это специальный тип функций, которые возвращают итератор и могут приостанавливать своё выполнение с помощью ключевого слова `yield`. При вызове `next()` генератор выполняет код до следующего `yield`, возвращает значение и замирает, сохраняя всё своё состояние. Следующий вызов `next()` возобновляет выполнение с того же места. Это позволяет эффективно работать с огромными или бесконечными последовательностями, не загружая их полностью в память. Генераторные выражения `(x for x in iterable)` — это компактный синтаксис для создания простых генераторов «на лету», похожий на list comprehension, но с круглыми скобками. Генераторы могут также получать данные с помощью метода `.send(value)`. Цикл `for` неявно вызывает `next()` и обрабатывает `StopIteration`. Функции-генераторы являются основой для работы с корутинами и асинхронным программированием."
    },
    {
        "id": 19,
        "title": "Асинхронность: async/await",
        "tag": "Асинхронность",
        "shortDesc": "Базовые понятия асинхронного программирования с использованием async/await",
        "code": `# Асинхронное программирование позволяет выполнять ввод-вывод (сеть, файлы) без блокировки потока.
# Ключевые слова: async, await. Основано на цикле событий (event loop).

print("=== Синхронный (обычный) код ===")
import time

def sync_task(name, delay):
    """Обычная (синхронная) функция, которая блокирует выполнение."""
    print(f"[{name}] Задача началась. Будет спать {delay} сек.")
    time.sleep(delay)  # Блокирует ВЕСЬ поток выполнения
    print(f"[{name}] Задача завершена.")
    return f"Результат {name}"

# Выполняем последовательно (одна задача блокирует другую)
start = time.time()
sync_task("Задача 1", 2)
sync_task("Задача 2", 1)
print(f"Общее время синхронного выполнения: {time.time() - start:.2f} сек.\n")

print("=== Асинхронный код с asyncio ===")
import asyncio

async def async_task(name, delay):
    """
    Асинхронная функция (корутина).
    Внутри можно использовать await для неблокирующего ожидания.
    """
    print(f"[{name}] Асинхронная задача началась. Будет ждать {delay} сек.")
    await asyncio.sleep(delay)  # Неблокирующее ожидание. Управление вернётся в цикл событий.
    print(f"[{name}] Асинхронная задача завершена.")
    return f"Асинхронный результат {name}"

async def main_async():
    """Основная асинхронная функция, которая управляет другими корутинами."""
    print("Запуск асинхронных задач параллельно (concurrently)...")
    # Создаём задачи (Task) из корутин. Они начинают выполняться.
    task1 = asyncio.create_task(async_task("А-Задача 1", 2))
    task2 = asyncio.create_task(async_task("А-Задача 2", 1))

    # Ждём завершения обеих задач параллельно.
    # Пока task1 ждёт (await asyncio.sleep), выполняется task2, и наоборот.
    results = await asyncio.gather(task1, task2)
    print(f"Все асинхронные задачи завершены. Результаты: {results}")

# Запуск асинхронного кода. asyncio.run() создаёт и управляет циклом событий.
start_async = time.time()
asyncio.run(main_async())
print(f"Общее время асинхронного выполнения: {time.time() - start_async:.2f} сек.\n")

print("=== Работа с асинхронными HTTP-запросами (aiohttp) ===")
# В реальности чаще всего асинхронность используют для сетевых запросов.
# Для примера показана структура кода (запуск требует установки библиотеки aiohttp).

async def fetch_url(session, url):
    """Асинхронная функция для получения HTML страницы."""
    try:
        # Имитация асинхронного запроса (без реальной библиотеки)
        print(f"Начинаем запрос к {url}")
        await asyncio.sleep(1)  # Имитация сетевой задержки
        print(f"Завершён запрос к {url}")
        return f"Данные с {url}"
    except Exception as e:
        return f"Ошибка при запросе {url}: {e}"

async def fetch_multiple_urls():
    """Запускаем несколько запросов одновременно."""
    urls = [
        "https://api.example.com/data1",
        "https://api.example.com/data2",
        "https://api.example.com/data3",
    ]
    # Предположим, что у нас есть асинхронная HTTP-сессия (например, aiohttp.ClientSession())
    # tasks = [fetch_url(session, url) for url in urls]
    # results = await asyncio.gather(*tasks)

    # Вместо реальных запросов создадим имитацию
    tasks = []
    for i, url in enumerate(urls):
        # Создаём задачу для каждого URL. Все они начнут выполняться конкурентно.
        task = asyncio.create_task(fetch_url(None, url))
        tasks.append(task)

    # Ждём завершения всех задач
    results = await asyncio.gather(*tasks)
    print(f"\nВсе URL получены. Результаты: {results}")

# Запуск имитации асинхронных HTTP-запросов
print("Имитация параллельных HTTP-запросов:")
asyncio.run(fetch_multiple_urls())

print("\n=== Важные понятия ===")
print("""
1. Корутина (coroutine) — функция, определённая с async def. Её вызов возвращает объект-корутину, а не результат.
2. await — ключевое слово для приостановки выполнения корутины до завершения другой корутины или Future.
3. Задача (Task) — обёртка вокруг корутины, которая планирует её выполнение в цикле событий.
4. Цикл событий (Event Loop) — ядро асинхронной программы. Управляет выполнением задач.
5. asyncio.run(main()) — удобная функция для запуска асинхронной программы.
6. asyncio.gather() — запускает несколько корутин конкурентно и ждёт все результаты.
7. Асинхронность выгодна при операциях ввода-вывода (I/O-bound), а не при вычислениях (CPU-bound).
""")`,
        "description": "Асинхронное программирование в Python (через `asyncio`) позволяет писать конкурентный код, который эффективно выполняет множество операций ввода-вывода (сетевые запросы, чтение файлов) без блокировки потока выполнения. Ключевое слово `async` определяет корутину — специальный тип функции, которая может приостанавливаться. Ключевое слово `await` приостанавливает выполнение корутины до завершения другой корутины или объекта `Future` (например, `await asyncio.sleep(1)`). Для запуска асинхронных функций используется цикл событий, который управляет выполнением задач (`Tasks`). Функция `asyncio.run(main_coro())` создаёт цикл событий, запускает переданную корутину и закрывает цикл. `asyncio.create_task(coro)` оборачивает корутину в задачу и планирует её выполнение. `asyncio.gather(*coros)` запускает несколько корутин параллельно и собирает результаты. Асинхронность не делает код быстрее для CPU-задач, но позволяет эффективно обслуживать множество медленных I/O-операций."
    },
    {
        "id": 20,
        "title": "Контекстный менеджер (with)",
        "tag": "Другое",
        "shortDesc": "Использование оператора with и создание собственных контекстных менеджеров",
        "code": `# Контекстный менеджер — это объект, который определяет методы __enter__ и __exit__.
# Оператор with гарантирует, что ресурсы будут правильно захвачены и освобождены
# (например, файлы будут закрыты, соединения разорваны).

print("=== Использование with для работы с файлами ===")
# Классический пример: работа с файлом
file_path = "example.txt"

# БЕЗ контекстного менеджера (нужно помнить о закрытии файла)
print("1. Стандартный способ (без with):")
f = open(file_path, 'w', encoding='utf-8')
try:
    f.write("Первая строка.\n")
    f.write("Вторая строка.\n")
finally:
    f.close()  # Обязательно закрыть файл, даже если возникла ошибка
print("   Файл записан и закрыт в блоке finally.")

# С контекстным менеджером (автоматическое закрытие)
print("\n2. Способ с оператором with:")
with open(file_path, 'r', encoding='utf-8') as file:  # file = __enter__()
    # Внутри этого блока файл открыт
    content = file.read()
    print(f"   Содержимое файла:\n{content}")
# Здесь, за пределами блока with, файл уже автоматически закрыт (вызван __exit__)
print("   Файл автоматически закрыт после выхода из блока with.")

print("\n=== Создание собственного контекстного менеджера через класс ===")

class Timer:
    """Контекстный менеджер для измерения времени выполнения блока кода."""
    def __enter__(self):
        # Этот метод выполняется при входе в блок with.
        import time
        self.start_time = time.time()
        print(f"Таймер запущен в {self.start_time:.4f}")
        return self  # Объект, который будет присвоен переменной после 'as'

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Этот метод выполняется при выходе из блока with.
        # Параметры exc_* содержат информацию об исключении, если оно произошло.
        import time
        self.end_time = time.time()
        elapsed = self.end_time - self.start_time
        print(f"Таймер остановлен в {self.end_time:.4f}")
        print(f"Затраченное время: {elapsed:.4f} секунд")
        # Если вернуть True, исключение будет подавлено (не выброшено дальше).
        # Если вернуть False или None, исключение будет выброшено.
        return False

# Использование нашего контекстного менеджера
print("Запуск таймера:")
with Timer() as timer:
    # Имитируем работу
    import time
    time.sleep(0.5)  # Спим полсекунды
    print("   Работа внутри блока with...")
print("Блок with завершён.\n")

print("=== Создание контекстного менеджера с помощью contextlib ===")
from contextlib import contextmanager
import sys

# Декоратор @contextmanager позволяет создать контекстный менеджер из функции-генератора.
@contextmanager
def redirect_stdout(new_target):
    """
    Контекстный менеджер для временного перенаправления вывода (sys.stdout).
    """
    old_target = sys.stdout  # Сохраняем оригинальный поток вывода
    sys.stdout = new_target  # Перенаправляем stdout на новый объект
    try:
        yield  # Здесь выполняется код внутри блока with
    finally:
        sys.stdout = old_target  # Восстанавливаем оригинальный поток в любом случае

# Использование: перенаправляем вывод в строку (StringIO)
from io import StringIO

output_buffer = StringIO()  # Буфер в памяти, который ведёт себя как файл

print("Обычный вывод до блока with.")
with redirect_stdout(output_buffer):
    # Весь вывод внутри этого блока пойдёт в output_buffer, а не на экран.
    print("Это сообщение НЕ видно на экране (оно в буфере).")
    print("И это тоже.")
    x = 10 + 15
    print(f"Результат вычислений: {x}")

print("Обычный вывод после блока with.")
# Получаем содержимое буфера
captured_output = output_buffer.getvalue()
print(f"Захваченный вывод из буфера:\n{captured_output}")

print("\n=== Контекстный менеджер для транзакции БД (упрощённо) ===")

class DatabaseConnection:
    """Упрощённая модель подключения к БД с контекстным менеджером."""
    def __init__(self, db_name):
        self.db_name = db_name
        self.connected = False

    def __enter__(self):
        print(f"[{self.db_name}] Подключение к базе данных...")
        # Здесь был бы реальный код подключения
        self.connected = True
        return self  # Возвращаем само подключение для работы внутри блока

    def execute_query(self, query):
        if self.connected:
            print(f"[{self.db_name}] Выполняем запрос: {query}")
            # Возвращаем заглушку результата
            return [{"id": 1, "name": "Запись"}]
        else:
            raise ConnectionError("Нет подключения к БД!")

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"[{self.db_name}] Закрытие подключения к базе данных...")
        self.connected = False
        if exc_type:
            print(f"[{self.db_name}] В блоке with произошла ошибка: {exc_val}")
        # Не подавляем ошибку (возвращаем False)

# Использование
with DatabaseConnection("my_database") as db:
    results = db.execute_query("SELECT * FROM users;")
    print(f"Результаты: {results}")
    # Файл (подключение) закроется автоматически здесь, даже если произойдёт ошибка.

print("Работа с БД завершена.")`,
        "description": "Контекстный менеджер — это объект, который управляет ресурсами в рамках блока кода, гарантируя их корректное получение и освобождение. Синтаксис `with context_manager as var:` автоматически вызывает метод `__enter__()` контекстного менеджера при входе в блок и метод `__exit__()` при выходе (даже если выход произошёл из-за исключения). Это избавляет от необходимости вручную закрывать файлы, соединения и т.д. Стандартные объекты Python, такие как файлы (`open(...)`), уже являются контекстными менеджерами. Создать собственный менеджер можно двумя способами: 1) Определить класс с методами `__enter__` и `__exit__`. 2) Использовать декоратор `@contextmanager` из модуля `contextlib`, который превращает функцию-генератор в контекстный менеджер (всё до `yield` — это `__enter__`, после `yield` в `finally` — это `__exit__`). Контекстные менеджеры делают код чище и безопаснее."
    },
    {
        "id": 21,
        "title": "Множества (set) и операции над ними",
        "tag": "Другое",
        "shortDesc": "Работа с множествами: создание, добавление, операции объединения, пересечения, разности",
        "code": `# Множество (set) — это неупорядоченная коллекция УНИКАЛЬНЫХ элементов.
# Элементы множества должны быть неизменяемыми (хэшируемыми): числа, строки, кортежи.

print("=== Создание множеств ===")
# Пустое множество
empty_set = set()  # Нельзя использовать {}, так как это создаст пустой словарь.
print(f"Пустое множество: {empty_set} (тип: {type(empty_set)})")

# Множество с элементами
fruits = {"яблоко", "банан", "апельсин", "яблоко", "киви"}  # Дубликаты автоматически удаляются!
print(f"Множество фруктов: {fruits}")  # Порядок может быть любым

# Создание множества из списка (удаление дубликатов из списка)
numbers_list = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = set(numbers_list)
print(f"Множество из списка (без дубликатов): {unique_numbers}")

# Множество из строки (множество уникальных символов)
chars_set = set("абракадабра")
print(f"Уникальные буквы в 'абракадабра': {chars_set}")

print("\n=== Добавление и удаление элементов ===")
colors = {"красный", "зеленый", "синий"}

# Добавление одного элемента
colors.add("желтый")
print(f"После add('желтый'): {colors}")

# Добавление нескольких элементов (из итерируемого объекта)
colors.update(["оранжевый", "фиолетовый", "зеленый"])  # 'зеленый' уже есть, дубликат не добавится
print(f"После update(['оранжевый', ...]): {colors}")

# Удаление элемента
colors.remove("синий")  # Удаляет элемент. Если его нет — KeyError
print(f"После remove('синий'): {colors}")

colors.discard("черный")  # Удаляет элемент, если он есть. Если нет — НЕ вызывает ошибку.
print(f"После discard('черный') (элемента нет): {colors}")

removed_item = colors.pop()  # Удаляет и возвращает СЛУЧАЙНЫЙ элемент (т.к. множество неупорядочено)
print(f"pop() удалил случайный элемент: '{removed_item}'. Осталось: {colors}")

colors.clear()  # Полностью очищает множество
print(f"После clear(): {colors}")

print("\n=== ОПЕРАЦИИ НАД МНОЖЕСТВАМИ ===")
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}

print(f"Множество A: {A}")
print(f"Множество B: {B}")

# ОБЪЕДИНЕНИЕ (union) — элементы, которые есть хотя бы в одном из множеств.
union_set = A.union(B)  # Или используйте оператор |
print(f"Объединение A | B: {union_set}")
print(f"То же через оператор |: {A | B}")

# ПЕРЕСЕЧЕНИЕ (intersection) — элементы, которые есть в ОБОИХ множествах.
intersection_set = A.intersection(B)  # Или оператор &
print(f"Пересечение A & B: {intersection_set}")
print(f"То же через оператор &: {A & B}")

# РАЗНОСТЬ (difference) — элементы, которые есть в A, но отсутствуют в B.
difference_set = A.difference(B)  # Или оператор -
print(f"Разность A - B: {difference_set}")
print(f"Разность B - A: {B - A}")

# СИММЕТРИЧЕСКАЯ РАЗНОСТЬ (symmetric_difference) — элементы, которые есть только в одном из множеств (исключая общие).
sym_diff_set = A.symmetric_difference(B)  # Или оператор ^
print(f"Симметрическая разность A ^ B: {sym_diff_set}")

print("\n=== СРАВНЕНИЕ МНОЖЕСТВ ===")
X = {1, 2, 3}
Y = {1, 2, 3, 4, 5}
Z = {1, 2}

# Является ли подмножеством (subset)
print(f"X ⊆ Y? (X является подмножеством Y): {X.issubset(Y)}")  # True
print(f"Z ⊆ X? {Z.issubset(X)}")  # True
print(f"Y ⊆ X? {Y.issubset(X)}")  # False
# То же через оператор <=
print(f"Z <= X? {Z <= X}")  # True

# Является ли надмножеством (superset)
print(f"Y ⊇ X? (Y является надмножеством X): {Y.issuperset(X)}")  # True
print(f"X ⊇ Z? {X.issuperset(Z)}")  # True
# То же через оператор >=
print(f"Y >= X? {Y >= X}")  # True

# НЕ ИМЕЮТ ОБЩИХ ЭЛЕМЕНТОВ (disjoint)
print(f"Множества {X} и {sym_diff_set} не пересекаются? {X.isdisjoint(sym_diff_set)}")

print("\n=== ПРИМЕНЕНИЕ: УДАЛЕНИЕ ДУБЛИКАТОВ И ФИЛЬТРАЦИЯ ===")
# Удаление дубликатов из списка
data = [10, 20, 30, 20, 10, 40, 50, 10]
unique_data = list(set(data))  # Преобразуем в множество и обратно в список
print(f"Список с дубликатами: {data}")
print(f"Список без дубликатов (порядок может измениться): {unique_data}")

# Поиск общих элементов в двух списках
list1 = ["Python", "Java", "C++", "JavaScript"]
list2 = ["C++", "C#", "Python", "Go"]
common_languages = set(list1).intersection(list2)
print(f"\nОбщие языки в двух списках: {common_languages}")`,
        "description": "Множество (`set`) — это неупорядоченная коллекция уникальных и неизменяемых (хэшируемых) элементов. Множества полезны для удаления дубликатов, проверки принадлежности (оператор `in` работает очень быстро), а также для математических операций над множествами: объединение (`union`, `|`), пересечение (`intersection`, `&`), разность (`difference`, `-`), симметрическая разность (`symmetric_difference`, `^`). Множества изменяемы (`mutable`), но сами элементы должны быть неизменяемыми. Существует также неизменяемая версия — `frozenset`. Методы `.add()`, `.remove()`, `.discard()`, `.pop()`, `.clear()` изменяют множество. Методы `.issubset()`, `.issuperset()`, `.isdisjoint()` используются для сравнения множеств. Создать пустое множество можно только с помощью `set()`, так как `{}` создаёт пустой словарь."
    },
    {
        "id": 22,
        "title": "Цикл while и итераторы",
        "tag": "Цикл",
        "shortDesc": "Использование цикла while, работа с итераторами вручную",
        "code": `# Цикл while выполняет блок кода ПОКА условие истинно (True).
print("=== БАЗОВЫЙ ЦИКЛ while ===")

# Пример 1: Счётчик
counter = 0
while counter < 5:
    print(f"Счётчик: {counter}")
    counter += 1  # ОБЯЗАТЕЛЬНО изменять условие, иначе цикл станет бесконечным!
print("Цикл завершён.\n")

# Пример 2: Чтение пользовательского ввода до определённого значения
print("Введите числа. Для выхода введите 'stop'.")
total = 0
user_input = ""
while user_input != "stop":
    user_input = input("Введите число или 'stop': ")
    if user_input != "stop":
        try:
            number = float(user_input)
            total += number
            print(f"Текущая сумма: {total}")
        except ValueError:
            print("Ошибка! Введите число или 'stop'.")
print(f"Итоговая сумма: {total}\n")

# Пример 3: while с условием break и continue
print("=== while с break и continue ===")
number = 0
while True:  # Бесконечный цикл - выход только через break
    number += 1
    if number % 2 == 0:
        continue  # Пропускаем чётные числа, переходим к следующей итерации
    print(f"Нечётное число: {number}")
    if number >= 9:
        break  # Прерываем цикл при достижении 9
print("Цикл прерван break.\n")

# Пример 4: while-else (редко используется)
print("=== while-else конструкция ===")
attempt = 0
max_attempts = 3
secret_code = "1234"
while attempt < max_attempts:
    guess = input(f"Попытка {attempt + 1}/{max_attempts}. Введите код: ")
    if guess == secret_code:
        print("Доступ разрешён!")
        break  # Выход из цикла, блок else НЕ выполнится
    attempt += 1
else:
    # Блок else выполняется ТОЛЬКО если цикл завершился НЕ через break
    print("Доступ заблокирован! Превышено количество попыток.")
print("\n")

# ========== РАБОТА С ИТЕРАТОРАМИ ВРУЧНУЮ ==========
print("=== Итераторы (протокол iterator) ===")

# Любая коллекция, по которой можно итерироваться, имеет метод __iter__()
my_list = [10, 20, 30]
iterator = iter(my_list)  # или my_list.__iter__() - создаёт объект-итератор

# У итератора есть метод __next__(), который возвращает следующий элемент
print("Ручная итерация через next():")
try:
    print(next(iterator))  # 10
    print(next(iterator))  # 20
    print(next(iterator))  # 30
    print(next(iterator))  # Вызовет StopIteration - нет больше элементов
except StopIteration:
    print("Достигнут конец итератора (StopIteration).")

# Цикл for под капотом делает то же самое:
# for element in my_list:
#     print(element)
# Преобразуется в:
# iterator = iter(my_list)
# while True:
#     try:
#         element = next(iterator)
#         print(element)
#     except StopIteration:
#         break

print("\n=== Создание собственного итератора через класс ===")

class Countdown:
    """Класс-итератор для обратного отсчёта."""
    def __init__(self, start):
        self.current = start
    
    def __iter__(self):
        # Метод должен возвращать сам объект итератора
        return self
    
    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        value = self.current
        self.current -= 1
        return value

# Использование нашего итератора в цикле for
print("Обратный отсчёт от 5:")
for num in Countdown(5):
    print(f"Осталось: {num}")

# Или вручную
cd = Countdown(3)
print(f"Ручной next: {next(cd)}")
print(f"Ручной next: {next(cd)}")
print(f"Ручной next: {next(cd)}")`,
        "description": "Цикл `while` повторяет блок кода, пока условие истинно. Важно изменять переменные в условии внутри цикла, чтобы избежать бесконечного цикла. Ключевые слова `break` (немедленный выход из цикла) и `continue` (переход к следующей итерации) позволяют управлять потоком. Конструкция `while-else` выполняется, если цикл завершился естественно (без `break`). Итератор — это объект, реализующий протокол итерации: методы `__iter__()` (возвращает сам итератор) и `__next__()` (возвращает следующий элемент или вызывает `StopIteration`). Цикл `for` неявно создаёт итератор и обрабатывает `StopIteration`. Любой класс можно сделать итерируемым, реализовав эти методы."
    },
    {
        "id": 23,
        "title": "Работа с файлами: чтение и запись",
        "tag": "Встроенные модули",
        "shortDesc": "Открытие, чтение, запись и управление файлами разных форматов",
        "code": `# Работа с файлами — одна из самых частых задач в программировании.
print("=== ОТКРЫТИЕ ФАЙЛОВ (open) ===")

# ========== ОСНОВНЫЕ РЕЖИМЫ ОТКРЫТИЯ ФАЙЛА ==========
# 'r'  - чтение (по умолчанию). Файл должен существовать.
# 'w'  - запись. Создаёт файл или перезаписывает существующий.
# 'a'  - добавление в конец файла. Создаёт файл, если не существует.
# 'x'  - эксклюзивное создание. Если файл существует — ошибка.
# 'b'  - бинарный режим (например, 'rb', 'wb').
# 't'  - текстовый режим (по умолчанию).
# '+'  - открытие для чтения и записи (например, 'r+', 'w+').

# ========== ЧТЕНИЕ ФАЙЛА ==========
print("\n--- Чтение всего файла ---")
# Рекомендуется использовать контекстный менеджер with
with open('example.txt', 'w', encoding='utf-8') as f:
    f.write("Первая строка.\nВторая строка.\nТретья строка.\n")

with open('example.txt', 'r', encoding='utf-8') as file:
    # 1. read() - читает весь файл как одну строку
    content = file.read()
    print(f"read():\n{content}")

with open('example.txt', 'r', encoding='utf-8') as file:
    # 2. readline() - читает файл построчно
    print("\nreadline():")
    line1 = file.readline()  # Читает первую строку (включая символ \n)
    line2 = file.readline()  # Читает вторую строку
    print(f"Строка 1: {line1.rstrip()}")  # rstrip() удаляет пробелы и \n справа
    print(f"Строка 2: {line2.rstrip()}")

with open('example.txt', 'r', encoding='utf-8') as file:
    # 3. readlines() - читает все строки и возвращает список
    lines = file.readlines()
    print(f"\nreadlines(): {lines}")

with open('example.txt', 'r', encoding='utf-8') as file:
    # 4. Итерация по файлу построчно (наиболее эффективно по памяти)
    print("\nИтерация по файлу:")
    for line_num, line in enumerate(file, 1):
        print(f"Строка {line_num}: {line.rstrip()}")

# ========== ЗАПИСЬ В ФАЙЛ ==========
print("\n--- Запись в файл ---")
# Режим 'w' - перезапись (старое содержимое удаляется)
with open('output.txt', 'w', encoding='utf-8') as file:
    file.write("Это первая строка.\n")
    file.write("Это вторая строка.\n")
    # writelines() принимает список строк
    lines_to_write = ["Третья строка.\n", "Четвёртая строка.\n"]
    file.writelines(lines_to_write)

print("Файл output.txt записан в режиме 'w'.")

# Режим 'a' - добавление в конец
with open('output.txt', 'a', encoding='utf-8') as file:
    file.write("--- Это добавленная строка. ---\n")

print("Строка добавлена в конец файла в режиме 'a'.")

# ========== БИНАРНЫЕ ФАЙЛЫ ==========
print("\n--- Работа с бинарными файлами ---")
# Библиотека struct может использоваться для работы с бинарными данными
import struct

# Запись бинарных данных
with open('data.bin', 'wb') as bin_file:
    # pack форматирует данные в байты: 'i' - integer (4 байта), 'f' - float (4 байта)
    data = struct.pack('i f', 42, 3.14)  # Упаковываем целое и вещественное число
    bin_file.write(data)

# Чтение бинарных данных
with open('data.bin', 'rb') as bin_file:
    data = bin_file.read()
    # unpack распаковывает байты обратно в числа
    unpacked_data = struct.unpack('i f', data)
    print(f"Распакованные данные: {unpacked_data}")

# ========== РАБОТА С JSON-ФАЙЛАМИ ==========
print("\n--- Работа с JSON (важный частный случай) ---")
import json

# Данные для сохранения в JSON
data_to_save = {
    "имя": "Иван",
    "возраст": 30,
    "город": "Москва",
    "хобби": ["программирование", "чтение", "путешествия"],
    "стаж_работы": 7.5
}

# Запись в JSON файл
with open('user.json', 'w', encoding='utf-8') as json_file:
    json.dump(data_to_save, json_file, ensure_ascii=False, indent=2)
print("Данные сохранены в user.json")

# Чтение из JSON файла
with open('user.json', 'r', encoding='utf-8') as json_file:
    loaded_data = json.load(json_file)
    print(f"Загруженные данные:\n{json.dumps(loaded_data, ensure_ascii=False, indent=2)}")

# ========== ПРОВЕРКА СУЩЕСТВОВАНИЯ ФАЙЛА ==========
print("\n--- Проверка существования файла ---")
import os
import sys

filename = 'example.txt'
if os.path.exists(filename):
    print(f"Файл '{filename}' существует.")
    # Получение информации о файле
    file_stats = os.stat(filename)
    print(f"Размер: {file_stats.st_size} байт")
    print(f"Время изменения: {file_stats.st_mtime}")
else:
    print(f"Файл '{filename}' не существует.")
    sys.exit(1)

# ========== РАБОТА С ПУТЯМИ (модуль os.path) ==========
print("\n--- Работа с путями ---")
current_file = __file__  # Текущий файл скрипта
print(f"Текущий файл: {current_file}")
print(f"Имя файла: {os.path.basename(current_file)}")
print(f"Директория файла: {os.path.dirname(current_file)}")
print(f"Абсолютный путь: {os.path.abspath(current_file)}")
print(f"Объединение путей: {os.path.join('папка', 'подпапка', 'файл.txt')}")`,
        "description": "Работа с файлами осуществляется через функцию `open()`, которая возвращает файловый объект. Основные режимы: `'r'` (чтение), `'w'` (запись, перезаписывает файл), `'a'` (добавление в конец), `'x'` (эксклюзивное создание). Добавление `'b'` открывает файл в бинарном режиме (для изображений, исполняемых файлов). Всегда рекомендуется использовать контекстный менеджер `with`, который гарантирует закрытие файла даже при ошибке. Для чтения используются методы: `.read()` (весь файл), `.readline()` (одна строка), `.readlines()` (список строк), итерация по файловому объекту (наиболее эффективно). Для записи: `.write()` и `.writelines()`. Модуль `json` предоставляет удобные методы `json.dump()` и `json.load()` для работы с JSON-файлами. Модуль `os` и `os.path` используются для проверки существования файлов, получения информации о них и манипуляций с путями."
    },
    {
        "id": 24,
        "title": "Регулярные выражения (модуль re)",
        "tag": "Встроенные модули",
        "shortDesc": "Использование регулярных выражений для поиска, замены и валидации текста",
        "code": `# Регулярные выражения (regex) — мощный инструмент для поиска и манипуляции текстом.
import re

print("=== БАЗОВЫЙ СИНТАКСИС РЕГУЛЯРОК ===")
# Специальные символы:
# .       - любой символ, кроме новой строки
# \d      - цифра [0-9]
# \D      - НЕ цифра
# \w      - буква, цифра или подчёркивание [a-zA-Z0-9_]
# \W      - НЕ буква, цифра или подчёркивание
# \s      - пробельный символ (пробел, табуляция, новая строка)
# \S      - НЕ пробельный символ
# ^       - начало строки
# $       - конец строки
# []      - набор символов, например [aeiou] - любая гласная
# [^]     - отрицание набора, [^0-9] - не цифра
# |       - или (alternation)
# ()      - группа захвата

# Квантификаторы (указывают количество повторений):
# *       - 0 или более раз
# +       - 1 или более раз
# ?       - 0 или 1 раз
# {n}     - ровно n раз
# {n,}    - n или более раз
# {n,m}   - от n до m раз

# Экранирование специальных символов: \. \* \+ \? \\ и т.д.

print("\n=== ПОИСК (search) ===")
text = "Мой телефон: +7-999-123-45-67, рабочий: +7-495-555-88-99"
pattern = r"\+\d-\d{3}-\d{3}-\d{2}-\d{2}"  # r перед строкой - raw string (сырая строка)

# search() находит ПЕРВОЕ совпадение в тексте
match = re.search(pattern, text)
if match:
    print(f"Найден номер: {match.group()}")  # group() возвращает найденную подстроку
    print(f"Начальная позиция: {match.start()}")
    print(f"Конечная позиция: {match.end()}")
    print(f"Интервал: {match.span()}")
else:
    print("Номер не найден.")

print("\n=== ПОИСК ВСЕХ СОВПАДЕНИЙ (findall) ===")
all_matches = re.findall(pattern, text)
print(f"Все номера в тексте: {all_matches}")

# finditer() возвращает итератор объектов match
print("Поиск через finditer():")
for match_obj in re.finditer(pattern, text):
    print(f"Найден '{match_obj.group()}' на позициях {match_obj.span()}")

print("\n=== ГРУППЫ ЗАХВАТА (capturing groups) ===")
# Круглые скобки создают группы захвата
phone_pattern = r"(\+\d)-(\d{3})-(\d{3}-\d{2}-\d{2})"
text2 = "Позвони по +7-912-345-67-89"
match2 = re.search(phone_pattern, text2)
if match2:
    print(f"Полное совпадение: {match2.group(0)}")  # group(0) - вся найденная строка
    print(f"Код страны: {match2.group(1)}")         # group(1) - первая группа
    print(f"Код оператора: {match2.group(2)}")      # group(2) - вторая группа
    print(f"Остальной номер: {match2.group(3)}")    # group(3) - третья группа
    print(f"Все группы: {match2.groups()}")         # Кортеж всех групп

print("\n=== ИМЕНОВАННЫЕ ГРУППЫ ===")
# (?P<name>...) создаёт именованную группу
named_pattern = r"(?P<country>\+\d)-(?P<operator>\d{3})-(?P<number>\d{3}-\d{2}-\d{2})"
match3 = re.search(named_pattern, text2)
if match3:
    print(f"Код страны: {match3.group('country')}")
    print(f"Код оператора: {match3.group('operator')}")
    print(f"Словарь всех групп: {match3.groupdict()}")

print("\n=== ЗАМЕНА ТЕКСТА (sub) ===")
# sub() заменяет все совпадения на указанную строку
censored_text = re.sub(r"\d", "*", "Мой пароль: 12345")  # Заменяем все цифры на *
print(f"После замены цифр: {censored_text}")

# Можно использовать группы в замене
text3 = "Иванов Иван, Петров Петр"
# Меняем местами имя и фамилию
swapped = re.sub(r"(\ w+) (\ w+)", r"\ 2 \ 1", text3)  # \ 1, \ 2 - ссылки на группы
print(f"Поменяли местами: {swapped}")

# Более сложная замена с помощью функции
def double_number(match):
    num = int(match.group())
    return str(num * 2)

text4 = "Цены: 100, 200, 300"
result = re.sub(r"\d+", double_number, text4)
print(f"Удвоенные цены: {result}")

print("\n=== РАЗБИЕНИЕ СТРОКИ (split) ===")
# split() разделяет строку по шаблону
data = "apple,banana;cherry orange"
# Разделяем по запятой, точке с запятой или пробелу
parts = re.split(r"[,;\s]+", data)
print(f"Разделённые части: {parts}")

print("\n=== КОМПИЛЯЦИЯ РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ ===")
# Если одно выражение используется многократно, его лучше скомпилировать
compiled_pattern = re.compile(r"\b\w{5}\b")  # Слова ровно из 5 букв
text5 = "Hello world from Python regex example"
matches = compiled_pattern.findall(text5)
print(f"Слова из 5 букв: {matches}")

print("\n=== ПРАКТИЧЕСКИЕ ПРИМЕРЫ ===")
# Валидация email
email_pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
emails = ["test@example.com", "invalid.email", "user@domain.co.uk", "@no_username.com"]
print("Валидация email:")
for email in emails:
    if re.match(email_pattern, email):
        print(f"  ✓ {email}")
    else:
        print(f"  ✗ {email}")

# Извлечение даты
date_text = "Событие произошло 15.12.2024 года, а затем 01-01-2025."
date_matches = re.findall(r"\b\d{2}[.-]\d{2}[.-]\d{4}\b", date_text)
print(f"Даты в тексте: {date_matches}")

# Удаление HTML-тегов
html = "<h1>Заголовок</h1><p>Текст <b>жирный</b> и <i>курсив</i>.</p>"
clean_text = re.sub(r"<[^>]+>", "", html)
print(f"Текст без HTML-тегов: {clean_text}")`,
        "description": "Модуль `re` предоставляет поддержку регулярных выражений в Python. Основные функции: `re.search()` (поиск первого совпадения), `re.findall()` (все совпадения как список строк), `re.finditer()` (итератор объектов Match), `re.match()` (поиск только в начале строки), `re.sub()` (замена), `re.split()` (разделение строки). Шаблоны описываются с помощью специального синтаксиса: `.` (любой символ), `\d` (цифра), `\w` (буква/цифра), `*` (0+ раз), `+` (1+ раз), `?` (0 или 1 раз), `{n,m}` (от n до m раз). Группы захвата `()` позволяют выделять части совпадения и ссылаться на них в заменах (`\\1`, `\\2`). Именованные группы `(?P<name>...)` делают код более читаемым. Для многократного использования шаблона его следует компилировать с помощью `re.compile()`. Регулярные выражения мощны, но сложны — для валидации email/URL часто лучше использовать специализированные библиотеки."
    },
    {
        "id": 25,
        "title": "Модуль collections: полезные структуры данных",
        "tag": "Встроенные модули",
        "shortDesc": "Использование Counter, defaultdict, deque, OrderedDict и других коллекций",
        "code": `# Модуль collections содержит специализированные типы данных-контейнеры.
from collections import Counter, defaultdict, deque, OrderedDict, namedtuple

print("=== Counter: счётчик элементов ===")
# Counter удобно использовать для подсчёта частоты элементов

# Создание Counter из последовательности
words = ["apple", "banana", "apple", "orange", "banana", "apple", "apple"]
word_counts = Counter(words)
print(f"Счётчик слов: {word_counts}")
print(f"Сколько раз 'apple': {word_counts['apple']}")
print(f"Сколько раз 'pear' (нет в Counter): {word_counts['pear']}")  # 0, не KeyError

# Методы Counter
print(f"\n3 самых частых слова: {word_counts.most_common(3)}")
print(f"Уникальные слова: {list(word_counts.elements())}")  # "развернёт" Counter

# Операции с Counter
counter1 = Counter(a=3, b=2, c=1)
counter2 = Counter(a=1, b=2, c=3, d=4)
print(f"\nCounter1: {counter1}")
print(f"Counter2: {counter2}")
print(f"Сложение: {counter1 + counter2}")
print(f"Вычитание: {counter1 - counter2}")  # Отрицательные значения игнорируются
print(f"Пересечение (минимум): {counter1 & counter2}")
print(f"Объединение (максимум): {counter1 | counter2}")

print("\n=== defaultdict: словарь со значением по умолчанию ===")
# defaultdict автоматически создаёт значение для отсутствующего ключа

# Пример 1: Группировка элементов
items = [("fruit", "apple"), ("fruit", "banana"), ("vegetable", "carrot"), ("fruit", "orange")]
grouped = defaultdict(list)  # При обращении к отсутствующему ключу создаст пустой список
for category, item in items:
    grouped[category].append(item)

print(f"Сгруппированные элементы: {dict(grouped)}")

# Пример 2: Подсчёт с defaultdict
text = "hello world hello python world"
word_freq = defaultdict(int)  # Значение по умолчанию 0
for word in text.split():
    word_freq[word] += 1
print(f"Частота слов: {dict(word_freq)}")

# Пример 3: Сложное значение по умолчанию
def default_value():
    return {"count": 0, "total": 0}

stats = defaultdict(default_value)
stats["apple"]["count"] += 1
stats["apple"]["total"] += 100
print(f"Статистика: {dict(stats)}")

print("\n=== deque: двусторонняя очередь ===")
# deque (double-ended queue) оптимизирована для быстрой вставки/удаления с обоих концов
d = deque([1, 2, 3])
print(f"Исходная deque: {d}")

# Добавление элементов
d.append(4)           # Добавить в конец
d.appendleft(0)       # Добавить в начало
print(f"После добавления: {d}")

# Удаление элементов
right_item = d.pop()          # Удалить с конца
left_item = d.popleft()       # Удалить с начала
print(f"Удалён справа: {right_item}, слева: {left_item}")
print(f"После удаления: {d}")

# Полезные методы
d.extend([5, 6, 7])          # Расширить конец
d.extendleft([-1, -2])       # Расширить начало (элементы добавляются в обратном порядке!)
print(f"После extend: {d}")
d.rotate(2)                  # Циклический сдвиг вправо на 2 позиции
print(f"После rotate(2): {d}")
d.rotate(-1)                 # Циклический сдвиг влево на 1 позицию
print(f"После rotate(-1): {d}")

# Ограничение максимальной длины
limited_deque = deque(maxlen=3)
for i in range(5):
    limited_deque.append(i)
    print(f"Добавили {i}: {limited_deque}")  # Старые элементы автоматически выталкиваются

print("\n=== namedtuple: именованный кортеж ===")
# Создаёт подкласс кортежа с именованными полями
Point = namedtuple("Point", ["x", "y"])  # Создаём класс Point с полями x и y
p = Point(10, 20)
print(f"Точка: {p}")
print(f"Координата x: {p.x}, y: {p.y}")  # Доступ по именам, а не индексам
print(f"Индекс x: {p[0]}")               # Доступ по индексу тоже работает

# namedtuple неизменяем, но можно создать новую с изменениями
p_new = p._replace(x=15)  # Создаёт новую точку с изменённым x
print(f"Новая точка: {p_new}")

# Преобразование в словарь и обратно
p_dict = p._asdict()
print(f"Как словарь: {p_dict}")
p_from_dict = Point(**p_dict)
print(f"Из словаря обратно: {p_from_dict}")

print("\n=== OrderedDict: упорядоченный словарь ===")
# В Python 3.7+ обычные dict тоже сохраняют порядок, но OrderedDict имеет дополнительные методы
od = OrderedDict()
od["z"] = 1
od["a"] = 2
od["c"] = 3
print(f"OrderedDict: {od}")

# Перемещение элемента в конец или начало
od.move_to_end("z")          # Переместить 'z' в конец
print(f"После move_to_end('z'): {od}")
od.move_to_end("a", last=False)  # Переместить 'a' в начало
print(f"После move_to_end('a', last=False): {od}")

# OrderedDict полезен при сравнении с учётом порядка
od1 = OrderedDict([("a", 1), ("b", 2)])
od2 = OrderedDict([("b", 2), ("a", 1)])
print(f"od1 == od2 (с учётом порядка): {od1 == od2}")

print("\n=== ChainMap: объединение словарей ===")
from collections import ChainMap

dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}  # При конфликте берётся значение из первого словаря
chain = ChainMap(dict1, dict2)
print(f"ChainMap: {chain}")
print(f"chain['a']: {chain['a']}")   # Из dict1
print(f"chain['b']: {chain['b']}")   # Из dict1 (первое вхождение)
print(f"chain['c']: {chain['c']}")   # Из dict2

# ChainMap полезен для работы с контекстами (например, переменные окружения + пользовательские)`,
        "description": "Модуль `collections` предоставляет специализированные типы данных, расширяющие стандартные коллекции. `Counter` — удобный счётчик элементов, поддерживает арифметические операции. `defaultdict` — словарь, который автоматически создаёт значения для отсутствующих ключей с помощью фабричной функции. `deque` — высокопроизводительная двусторонняя очередь, оптимизированная для быстрых операций с обоих концов, поддерживает ограничение длины и вращение. `namedtuple` — создаёт легковесные неизменяемые объекты с именованными полями, удобные для замены простых классов данных. `OrderedDict` — словарь, сохраняющий порядок добавления элементов (в Python 3.7+ обычные dict тоже упорядочены, но OrderedDict имеет дополнительные методы). `ChainMap` — группирует несколько словарей в одно представление для поиска. Эти структуры данных решают множество практических задач более эффективно и элегантно, чем стандартные коллекции."
    },
    {
        "id": 26,
        "title": "Многопоточность (threading)",
        "tag": "Другое",
        "shortDesc": "Базовое использование потоков для параллельного выполнения задач",
        "code": `# Многопоточность позволяет выполнять несколько задач "одновременно" в одном процессе.
# В Python из-за GIL (Global Interpreter Lock) потоки эффективны только для I/O-bound задач.
import threading
import time
import random

print("=== СОЗДАНИЕ И ЗАПУСК ПОТОКОВ ===")

# ========== СПОСОБ 1: Наследование от threading.Thread ==========
class MyThread(threading.Thread):
    def __init__(self, name, delay):
        super().__init__()
        self.name = name
        self.delay = delay
    
    def run(self):
        """Метод run содержит код, который будет выполняться в потоке."""
        print(f"[{self.name}] Поток запущен. Задержка: {self.delay} сек.")
        time.sleep(self.delay)
        print(f"[{self.name}] Поток завершён.")

# Создаём и запускаем потоки
print("Запуск потоков через класс:")
thread1 = MyThread("Поток-А", 2)
thread2 = MyThread("Поток-Б", 1)

thread1.start()  # Запускает поток (вызывает метод run в отдельном потоке)
thread2.start()

# join() блокирует основной поток, пока целевой поток не завершится
thread1.join()
thread2.join()
print("Оба потока завершены.\n")

# ========== СПОСОБ 2: Передача функции в Thread ==========
def worker(thread_id, iterations):
    """Функция, которая будет выполняться в потоке."""
    for i in range(iterations):
        print(f"[Поток {thread_id}] Итерация {i+1}/{iterations}")
        time.sleep(0.5)  # Имитация работы
    print(f"[Поток {thread_id}] Задача выполнена.")

print("Запуск потоков через функцию:")
# Создаём объекты потоков, передавая target=функция
threads = []
for i in range(3):
    t = threading.Thread(target=worker, args=(i+1, 3))
    threads.append(t)
    t.start()  # Запускаем поток сразу

# Ожидаем завершения всех потоков
for t in threads:
    t.join()
print("Все рабочие потоки завершены.\n")

print("=== СИНХРОНИЗАЦИЯ ПОТОКОВ (блокировки) ===")
# Без синхронизации несколько потоков могут конфликтовать при доступе к общим ресурсам.

# Пример: два потока пытаются изменить одну переменную
shared_counter = 0
iterations = 100000

def increment_without_lock():
    global shared_counter
    for _ in range(iterations):
        shared_counter += 1  # Неатомарная операция!

def decrement_without_lock():
    global shared_counter
    for _ in range(iterations):
        shared_counter -= 1

# Запускаем потоки без блокировки
print("Тест БЕЗ блокировки:")
shared_counter = 0
t1 = threading.Thread(target=increment_without_lock)
t2 = threading.Thread(target=decrement_without_lock)

t1.start()
t2.start()
t1.join()
t2.join()
print(f"Итоговое значение счётчика (должно быть 0): {shared_counter}")

# Решение: используем Lock (блокировку)
lock = threading.Lock()
shared_counter = 0

def increment_with_lock():
    global shared_counter
    for _ in range(iterations):
        with lock:  # Контекстный менеджер автоматически захватывает и освобождает lock
            shared_counter += 1

def decrement_with_lock():
    global shared_counter
    for _ in range(iterations):
        with lock:
            shared_counter -= 1

print("\nТест С блокировкой (Lock):")
shared_counter = 0
t3 = threading.Thread(target=increment_with_lock)
t4 = threading.Thread(target=decrement_with_lock)

t3.start()
t4.start()
t3.join()
t4.join()
print(f"Итоговое значение счётчика (должно быть 0): {shared_counter}")

print("\n=== ОЧЕРЕДЬ ДЛЯ МЕЖПОТОКОВОГО ВЗАИМОДЕЙСТВИЯ ===")
# Очередь (queue) — потокобезопасный способ обмена данными между потоками.
import queue

def producer(q, items):
    """Производитель: кладёт элементы в очередь."""
    for item in items:
        print(f"[Производитель] Добавляю {item} в очередь")
        q.put(item)
        time.sleep(random.uniform(0.1, 0.3))
    q.put(None)  # Сигнал завершения

def consumer(q):
    """Потребитель: забирает элементы из очереди."""
    while True:
        item = q.get()  # Блокируется, пока в очереди не появится элемент
        if item is None:  # Сигнал завершения
            q.task_done()
            break
        print(f"[Потребитель] Обрабатываю {item}")
        time.sleep(random.uniform(0.2, 0.4))
        q.task_done()  # Помечаем элемент как обработанный

# Создаём очередь
q = queue.Queue()
items_to_produce = ["яблоко", "банан", "вишня", "дыня", "эскимо"]

# Создаём и запускаем потоки
prod_thread = threading.Thread(target=producer, args=(q, items_to_produce))
cons_thread = threading.Thread(target=consumer, args=(q,))

prod_thread.start()
cons_thread.start()

# Ждём завершения производителя и добавляем None в очередь
prod_thread.join()
cons_thread.join()
print("Производитель и потребитель завершили работу.")

print("\n=== СЕМАФОРЫ И УСЛОВНЫЕ ПЕРЕМЕННЫЕ ===")
# Semaphore ограничивает количество потоков, которые могут одновременно получить доступ к ресурсу.
semaphore = threading.Semaphore(2)  # Одновременно могут работать только 2 потока

def limited_worker(worker_id):
    with semaphore:
        print(f"[Рабочий {worker_id}] Начал работу (семафор захвачен)")
        time.sleep(1)
        print(f"[Рабочий {worker_id}] Завершил работу (семафор освобождён)")

print("Работа с семафором (лимит 2 потока):")
workers = []
for i in range(5):
    t = threading.Thread(target=limited_worker, args=(i+1,))
    workers.append(t)
    t.start()

for t in workers:
    t.join()

print("\n=== ПОТОКИ-ДЕМОНЫ ===")
# Демон-поток завершается автоматически при завершении основного потока
def daemon_worker():
    count = 0
    while True:
        print(f"[Демон] Работаю уже {count} секунд...")
        time.sleep(1)
        count += 1
        if count >= 5:
            print("[Демон] Демон-поток завершается (обычно он бы работал вечно)")
            break

daemon_thread = threading.Thread(target=daemon_worker)
daemon_thread.daemon = True  # Устанавливаем флаг демона
daemon_thread.start()

print("Основной поток продолжает работу...")
time.sleep(3)
print("Основной поток завершается -> демон-поток тоже завершится.")
# Демон-поток будет принудительно завершён, даже если не закончил работу`,
        "description": "Многопоточность в Python реализуется с помощью модуля `threading`. Поток — это легковесный процесс выполнения внутри одного процесса. Из-за GIL (Global Interpreter Lock) потоки в Python эффективны в основном для I/O-bound задач (сетевые запросы, чтение файлов), а не для CPU-bound вычислений. Потоки создаются либо через наследование от `threading.Thread` (переопределение метода `run()`), либо через передачу целевой функции в конструктор `Thread(target=func, args=...)`. Метод `start()` запускает поток, `join()` ожидает его завершения. Для синхронизации доступа к общим ресурсам используются блокировки (`Lock`), семафоры (`Semaphore`) и условные переменные (`Condition`). Модуль `queue` предоставляет потокобезопасные очереди для обмена данными между потоками. Потоки-демоны (`daemon=True`) автоматически завершаются при завершении основного потока. Важно помнить о возможных состояниях гонки (race conditions) и правильно синхронизировать потоки."
    },
    {
        "id": 27,
        "title": "Многопроцессорность (multiprocessing)",
        "tag": "Другое",
        "shortDesc": "Использование процессов для параллельных вычислений, обход GIL",
        "code": `# Многопроцессорность позволяет использовать несколько ядер CPU для параллельных вычислений.
# Каждый процесс имеет свою собственную память и свой интерпретатор Python (обход GIL).
import multiprocessing
import time
import os

print("=== БАЗОВОЕ ИСПОЛЬЗОВАНИЕ ПРОЦЕССОВ ===")

# Простая функция, которая будет выполняться в процессе
def worker_process(name, duration):
    """Функция, выполняемая в отдельном процессе."""
    print(f"[Процесс {name}] PID: {os.getpid()}, запущен")
    print(f"[Процесс {name}] Родительский PID: {os.getppid()}")
    time.sleep(duration)
    print(f"[Процесс {name}] Завершён после {duration} сек.")
    return f"Результат от {name}"

print("Запуск процессов напрямую:")
# Создаём объекты процессов
p1 = multiprocessing.Process(target=worker_process, args=("Alpha", 2))
p2 = multiprocessing.Process(target=worker_process, args=("Beta", 1))

# Запускаем процессы
p1.start()
p2.start()

print(f"Основной процесс PID: {os.getpid()}, ждёт завершения дочерних...")

# Ожидаем завершения процессов
p1.join()
p2.join()
print("Оба процесса завершены.\n")

print("=== ПУЛ ПРОЦЕССОВ (Process Pool) ===")
# Пул процессов удобен для параллельного выполнения одной функции на разных данных
from multiprocessing import Pool

def cpu_intensive_task(number):
    """Имитация CPU-интенсивной задачи (например, вычисления)."""
    print(f"[Задача {number}] Выполняется в процессе {os.getpid()}")
    result = sum(i * i for i in range(number))
    time.sleep(0.5)  # Имитация долгой работы
    return result

if __name__ == "__main__":  # Важно для безопасности при создании процессов на Windows/Mac
    print("Использование Pool.map() для параллельной обработки:")
    numbers = [1000, 2000, 3000, 4000, 5000]
    
    # Создаём пул из 3 процессов
    with Pool(processes=3) as pool:
        # map распределяет задачи по процессам пула
        start_time = time.time()
        results = pool.map(cpu_intensive_task, numbers)
        elapsed = time.time() - start_time
    
    print(f"Результаты: {results}")
    print(f"Время выполнения с пулом (3 процесса): {elapsed:.2f} сек.")
    
    # Для сравнения: последовательное выполнение
    print("\nПоследовательное выполнение для сравнения:")
    start_time = time.time()
    sequential_results = [cpu_intensive_task(n) for n in numbers]
    elapsed_seq = time.time() - start_time
    print(f"Время последовательного выполнения: {elapsed_seq:.2f} сек.")
    print(f"Ускорение: {elapsed_seq/elapsed:.1f}x\n")

print("=== ОБМЕН ДАННЫМИ МЕЖДУ ПРОЦЕССАМИ ===")
# Процессы не разделяют память, поэтому нужны специальные механизмы обмена данными

# 1. Очередь (Queue) — потокобезопасная очередь для обмена данными
def producer_process(q, items):
    for item in items:
        print(f"[Производитель] Отправляю {item}")
        q.put(item)
        time.sleep(0.1)
    q.put(None)  # Сигнал завершения

def consumer_process(q):
    while True:
        item = q.get()
        if item is None:
            break
        print(f"[Потребитель] Получил {item}")
        time.sleep(0.2)

if __name__ == "__main__":
    # Очередь для межпроцессного взаимодействия
    mp_queue = multiprocessing.Queue()
    
    items = ["A", "B", "C", "D"]
    
    p_prod = multiprocessing.Process(target=producer_process, args=(mp_queue, items))
    p_cons = multiprocessing.Process(target=consumer_process, args=(mp_queue,))
    
    p_prod.start()
    p_cons.start()
    
    p_prod.join()
    p_cons.join()
    print("Обмен данными через очередь завершён.\n")

# 2. Разделяемая память (Value, Array)
def modify_shared_data(shared_value, shared_array, index):
    """Изменяет разделяемые данные."""
    with shared_value.get_lock():  # Блокировка для атомарного изменения
        shared_value.value += 1
    
    shared_array[index] = index * 10  # Изменение элемента массива
    print(f"[Процесс {index}] Изменил shared_value на {shared_value.value}")
    print(f"[Процесс {index}] Установил shared_array[{index}] = {shared_array[index]}")

if __name__ == "__main__":
    # Value создаёт разделяемую переменную указанного типа
    shared_counter = multiprocessing.Value("i", 0)  # "i" = integer
    
    # Array создаёт разделяемый массив указанного типа и размера
    shared_arr = multiprocessing.Array("i", 5)  # Массив из 5 целых чисел
    
    processes = []
    for i in range(3):
        p = multiprocessing.Process(target=modify_shared_data, args=(shared_counter, shared_arr, i))
        processes.append(p)
        p.start()
    
    for p in processes:
        p.join()
    
    print(f"\nИтоговое значение shared_counter: {shared_counter.value}")
    print(f"Итоговый массив shared_arr: {list(shared_arr)}")

print("\n=== ПРОЦЕССЫ-ДЕМОНЫ ===")
def daemon_worker():
    count = 0
    while True:
        print(f"[Демон-процесс] Работаю... {count}")
        time.sleep(1)
        count += 1
        if count >= 3:
            break  # В реальности демон мог бы работать вечно

if __name__ == "__main__":
    daemon_proc = multiprocessing.Process(target=daemon_worker)
    daemon_proc.daemon = True  # Устанавливаем флаг демона
    daemon_proc.start()
    
    print("Основной процесс продолжает работу...")
    time.sleep(2)
    print("Основной процесс завершается -> демон-процесс тоже завершится.")
    # Демон-процесс будет принудительно завершён

print("\n=== МЕНЕДЖЕР ОБЪЕКТОВ (Manager) ===")
# Manager позволяет создавать разделяемые объекты более сложных типов
def manager_worker(shared_dict, shared_list, key):
    shared_dict[key] = os.getpid()
    shared_list.append(key * 10)
    print(f"[Процесс {key}] Добавил данные в разделяемые структуры")

if __name__ == "__main__":
    with multiprocessing.Manager() as manager:
        # Создаём разделяемые структуры через менеджера
        shared_dict = manager.dict()
        shared_list = manager.list()
        
        processes = []
        for i in range(3):
            p = multiprocessing.Process(target=manager_worker, args=(shared_dict, shared_list, i))
            processes.append(p)
            p.start()
        
        for p in processes:
            p.join()
        
        print(f"Разделяемый словарь: {dict(shared_dict)}")
        print(f"Разделяемый список: {list(shared_list)}")`,
        "description": "Модуль `multiprocessing` позволяет создавать параллельные процессы для эффективного использования многоядерных процессоров. В отличие от потоков, каждый процесс имеет собственное пространство памяти и свой интерпретатор Python, что позволяет обойти ограничение GIL для CPU-bound задач. Процессы создаются через `multiprocessing.Process()`. Для параллельной обработки данных удобно использовать пулы процессов (`Pool.map()`, `Pool.apply_async()`). Поскольку процессы не разделяют память, для обмена данными используются: `Queue` (очередь), `Pipe` (канал), `Value` и `Array` (разделяемая память с блокировками), `Manager` (менеджер объектов для сложных структур). Процессы-демоны (`daemon=True`) завершаются при завершении основного процесса. Многопроцессорность требует больше ресурсов, чем многопоточность, но эффективна для задач, интенсивно использующих процессор. Важно оборачивать код в `if __name__ == '__main__':` для корректной работы на Windows и macOS."
    },
    {
        "id": 28,
        "title": "Работа с аргументами командной строки",
        "tag": "Встроенные модули",
        "shortDesc": "Обработка параметров командной строки с помощью argparse и sys.argv",
        "code": `# Программы часто получают параметры из командной строки.
# Есть два основных способа обработки: простой (sys.argv) и продвинутый (argparse).

print("=== ПРОСТОЙ СПОСОБ: sys.argv ===")
import sys

# sys.argv - список аргументов командной строки.
# argv[0] - имя скрипта, argv[1:] - переданные аргументы.

print(f"Все аргументы: {sys.argv}")
print(f"Имя скрипта: {sys.argv[0] if len(sys.argv) > 0 else 'не указано'}")

# Пример обработки
if len(sys.argv) > 1:
    print("Переданные аргументы:")
    for i, arg in enumerate(sys.argv[1:], 1):
        print(f"  Аргумент {i}: {arg}")
else:
    print("Аргументы не переданы.")

# Пример: простой калькулятор через командную строку
def simple_calculator():
    if len(sys.argv) != 4:
        print("Использование: python script.py <число1> <операция> <число2>")
        print("Операции: +, -, *, /")
        sys.exit(1)
    
    try:
        num1 = float(sys.argv[1])
        operation = sys.argv[2]
        num2 = float(sys.argv[3])
        
        if operation == "+":
            result = num1 + num2
        elif operation == "-":
            result = num1 - num2
        elif operation == "*":
            result = num1 * num2
        elif operation == "/":
            if num2 == 0:
                print("Ошибка: деление на ноль!")
                sys.exit(1)
            result = num1 / num2
        else:
            print(f"Неизвестная операция: {operation}")
            sys.exit(1)
        
        print(f"Результат: {num1} {operation} {num2} = {result}")
    except ValueError:
        print("Ошибка: аргументы должны быть числами!")
        sys.exit(1)

# Раскомментируйте для теста:
# simple_calculator()

print("\n=== ПРОДВИНУТЫЙ СПОСОБ: argparse ===")
import argparse

# argparse создаёт профессиональный интерфейс командной строки с автоматической генерацией справки.

# Создаём парсер
parser = argparse.ArgumentParser(
    prog="myprogram.py",
    description="Программа для демонстрации модуля argparse",
    epilog="Примеры использования: python myprogram.py --name Иван --age 30"
)

# Добавляем аргументы

# Позиционные аргументы (обязательные)
parser.add_argument("input_file", 
                   help="Путь к входному файлу")

# Опциональные аргументы (с префиксами - или --)
parser.add_argument("-o", "--output", 
                   default="output.txt",
                   help="Путь к выходному файлу (по умолчанию: output.txt)")

parser.add_argument("-v", "--verbose", 
                   action="store_true",  # Флаг (булево значение)
                   help="Подробный вывод")

parser.add_argument("--count", 
                   type=int, 
                   default=1,
                   help="Количество повторений (по умолчанию: 1)")

# Аргумент с выбором из ограниченного списка
parser.add_argument("--mode", 
                   choices=["fast", "normal", "slow"], 
                   default="normal",
                   help="Режим работы (fast, normal, slow)")

# Аргумент, который можно передать несколько раз
parser.add_argument("-a", "--add", 
                   action="append", 
                   default=[],
                   help="Добавить значение (можно использовать несколько раз)")

# Взаимоисключающие аргументы
group = parser.add_mutually_exclusive_group()
group.add_argument("--enable", action="store_true", help="Включить функцию")
group.add_argument("--disable", action="store_true", help="Выключить функцию")

# Парсинг аргументов
# В реальном скрипте аргументы берутся из sys.argv автоматически
# Для демонстрации создадим искусственные аргументы
test_args = ["input.txt", "-o", "result.txt", "--count", "5", "--verbose", "--mode", "fast", "-a", "val1", "-a", "val2"]
args = parser.parse_args(test_args)

print("Результат парсинга аргументов:")
print(f"  Входной файл: {args.input_file}")
print(f"  Выходной файл: {args.output}")
print(f"  Подробный вывод: {args.verbose}")
print(f"  Количество повторений: {args.count}")
print(f"  Режим работы: {args.mode}")
print(f"  Добавленные значения: {args.add}")
print(f"  Включить: {args.enable}")
print(f"  Выключить: {args.disable}")

# Генерация справки
print("\nАвтоматически сгенерированная справка:")
parser.print_help()

print("\n=== ПРИМЕР: ПРОГРАММА ДЛЯ РАБОТЫ С ФАЙЛАМИ ===")

def create_file_processor():
    """Создаёт парсер для программы обработки файлов."""
    parser = argparse.ArgumentParser(description="Обработчик текстовых файлов")
    
    parser.add_argument("files", 
                       nargs="+",  # Один или несколько файлов
                       help="Файлы для обработки")
    
    parser.add_argument("--encoding", 
                       default="utf-8",
                       help="Кодировка файлов (по умолчанию: utf-8)")
    
    parser.add_argument("--lines", 
                       type=int,
                       help="Ограничить количество выводимых строк")
    
    parser.add_argument("--search", 
                       help="Поиск строк, содержащих указанный текст")
    
    parser.add_argument("--replace", 
                       nargs=2,  # Ожидает 2 аргумента: старый_текст новый_текст
                       metavar=("OLD", "NEW"),
                       help="Замена текста в файлах")
    
    return parser

# Демонстрация парсинга для файлового процессора
file_args = ["file1.txt", "file2.txt", "--encoding", "cp1251", "--lines", "10", "--search", "error"]
file_parser = create_file_processor()

try:
    parsed = file_parser.parse_args(file_args)
    print("\nПарсинг аргументов файлового процессора:")
    print(f"  Файлы: {parsed.files}")
    print(f"  Кодировка: {parsed.encoding}")
    print(f"  Ограничение строк: {parsed.lines}")
    print(f"  Поиск: {parsed.search}")
    print(f"  Замена: {parsed.replace}")
except SystemExit:
    pass  # argparse сам выходит при ошибке

print("\n=== ПРИМЕР: КАЛЬКУЛЯТОР С argparse ===")

def calculator_args():
    parser = argparse.ArgumentParser(description="Калькулятор")
    
    parser.add_argument("x", type=float, help="Первое число")
    parser.add_argument("y", type=float, help="Второе число")
    
    parser.add_argument("--operation", "-op", 
                       choices=["add", "sub", "mul", "div"],
                       default="add",
                       help="Операция: add, sub, mul, div (по умолчанию: add)")
    
    return parser

calc_parser = calculator_args()
calc_args = ["10", "5", "--operation", "mul"]
parsed_calc = calc_parser.parse_args(calc_args)

print("Аргументы калькулятора:")
print(f"  x = {parsed_calc.x}")
print(f"  y = {parsed_calc.y}")
print(f"  операция = {parsed_calc.operation}")

# Выполнение операции
if parsed_calc.operation == "add":
    result = parsed_calc.x + parsed_calc.y
elif parsed_calc.operation == "sub":
    result = parsed_calc.x - parsed_calc.y
elif parsed_calc.operation == "mul":
    result = parsed_calc.x * parsed_calc.y
elif parsed_calc.operation == "div":
    result = parsed_calc.x / parsed_calc.y

print(f"  Результат: {result}")`,
        "description": "Обработка аргументов командной строки — важная часть создания консольных утилит. Простой способ использует `sys.argv` — список, содержащий переданные аргументы (`sys.argv[0]` — имя скрипта). Более продвинутый и рекомендуемый способ — модуль `argparse`, который предоставляет автоматическую генерацию справки, проверку типов, поддержку позиционных и опциональных аргументов, флагов, выбор из ограниченного списка (`choices`), взаимно исключающие аргументы и многое другое. Основные шаги: 1) Создать `ArgumentParser`, 2) Добавить аргументы через `add_argument()`, 3) Вызвать `parse_args()` для получения объекта с аргументами. `argparse` автоматически генерирует справку при вызове с `-h` или `--help`. Для простых скриптов можно использовать `sys.argv`, для сложных утилит с множеством параметров обязательно используйте `argparse`."
    },
    {
        "id": 29,
        "title": "Создание и активация виртуальных окружений",
        "tag": "Модули",
        "shortDesc": "Изоляция проектов Python с помощью venv и virtualenv",
        "code": `# Виртуальные окружения позволяют изолировать зависимости разных проектов.
# Это предотвращает конфликты версий пакетов между проектами.

print("=== ЗАЧЕМ НУЖНЫ ВИРТУАЛЬНЫЕ ОКРУЖЕНИЯ ===")
print("""
1. Изоляция зависимостей: каждый проект имеет свои собственные пакеты.
2. Разные версии пакетов: Project A может использовать Django 3.x, Project B - Django 4.x.
3. Чистая система: не загрязняется глобальное пространство Python.
4. Воспроизводимость: легко переносить проект с указанием зависимостей.
""")

print("=== СОЗДАНИЕ ВИРТУАЛЬНОГО ОКРУЖЕНИЯ (venv) ===")
# venv - встроенный модуль Python 3.3+ для создания виртуальных окружений.

import os
import sys
import subprocess

# Для демонстрации создадим виртуальное окружение в текущей директории
venv_name = "my_venv_demo"

print(f"Создаём виртуальное окружение '{venv_name}'...")

# Способ 1: Использование модуля venv напрямую (рекомендуется)
try:
    import venv
    builder = venv.EnvBuilder(with_pip=True)
    builder.create(venv_name)
    print(f"Виртуальное окружение '{venv_name}' создано с помощью venv.")
except ImportError:
    print("Модуль venv не найден (возможно, Python 2?).")

print("\nСтруктура созданного окружения:")
print(f"  {venv_name}/")
print(f"    ├── bin/ (или Scripts/ на Windows) - исполняемые файлы")
print(f"    │   ├── python - интерпретатор Python")
print(f"    │   ├── pip - менеджер пакетов")
print(f"    │   └── activate - скрипт активации")
print(f"    ├── lib/ - установленные пакеты")
print(f"    └── pyvenv.cfg - конфигурация окружения")

print("\n=== АКТИВАЦИЯ ВИРТУАЛЬНОГО ОКРУЖЕНИЯ ===")
print("""
Для активации виртуального окружения выполните команду в терминале:

На Linux/Mac:
    source my_venv_demo/bin/activate

На Windows (Command Prompt):
    my_venv_demo\\Scripts\\activate.bat

На Windows (PowerShell):
    my_venv_demo\\Scripts\\Activate.ps1
    (Может потребоваться: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser)

После активации приглашение терминала изменится, например:
    (my_venv_demo) user@computer:~$
""")

print("=== РАБОТА В АКТИВИРОВАННОМ ОКРУЖЕНИИ ===")
print("""
В активированном окружении:
1. Команда 'python' запускает интерпретатор из виртуального окружения.
2. Команда 'pip' устанавливает пакеты только в это окружение.
3. Все импорты пакетов будут идти из изолированного окружения.

Примеры команд после активации:
    pip list                     # Показать установленные пакеты (пусто в новом окружении)
    pip install requests         # Установить пакет requests
    pip install django==4.0      # Установить конкретную версию
    pip freeze > requirements.txt # Сохранить зависимости в файл
    pip install -r requirements.txt # Установить зависимости из файла
""")

print("\n=== ДЕАКТИВАЦИЯ ОКРУЖЕНИЯ ===")
print("""
Для деактивации выполните команду:
    deactivate

После этого терминал вернётся к использованию глобального Python.
""")

print("=== СОЗДАНИЕ ТРЕБОВАНИЙ (requirements.txt) ===")
# requirements.txt - файл со списком зависимостей проекта.

requirements_content = """# Файл requirements.txt
# Список зависимостей проекта с указанием версий

# Конкретная версия
Django==4.0.6

# Версия не ниже указанной
requests>=2.25.0

# Версия из определённого диапазона
numpy>=1.20,<1.23

# Без указания версии (последняя доступная)
pandas

# Зависимости из репозитория Git
# git+https://github.com/user/repo.git@branch

# Локальный пакет
# ./packages/mypackage

# Из других источников
# --index-url https://pypi.org/simple/
"""

print("Содержимое файла requirements.txt:")
print(requirements_content)

print("\n=== КОМАНДЫ ДЛЯ РАБОТЫ С ЗАВИСИМОСТЯМИ ===")
commands = """
# Создать файл requirements.txt на основе установленных пакетов
pip freeze > requirements.txt

# Установить все зависимости из requirements.txt
pip install -r requirements.txt

# Установить зависимости для разработки (обычно requirements/dev.txt)
pip install -r requirements/dev.txt

# Обновить пакет
pip install --upgrade package_name

# Удалить пакет
pip uninstall package_name

# Показать информацию о пакете
pip show package_name

# Поиск пакетов
pip search "query"
"""

print(commands)

print("\n=== virtualenv vs venv ===")
print("""
venv (встроенный в Python 3.3+):
    - Часть стандартной библиотеки Python
    - Более простой, меньше функций
    - Только для Python 3

virtualenv (сторонний пакет):
    - Устанавливается через pip: pip install virtualenv
    - Более функциональный (копирование пакетов, хуки)
    - Работает с Python 2 и 3
    - Можно указать версию Python: virtualenv -p python3.9 myenv

Для новых проектов на Python 3 рекомендуется использовать venv.
""")

print("\n=== PYTHONPATH И ИМПОРТЫ ===")
print("""
При активированном виртуальном окружении Python ищет пакеты в:
1. Директории lib/site-packages внутри виртуального окружения
2. Пути, указанном в PYTHONPATH (если установлен)
3. Стандартных путях Python

Это означает, что импорт 'import requests' будет использовать версию из виртуального окружения,
а не глобальную, даже если глобально requests тоже установлен.
""")

print("\n=== АВТОМАТИЧЕСКАЯ АКТИВАЦИЯ (direnv, autoenv) ===")
print("""
Для удобства можно настроить автоматическую активацию виртуального окружения
при входе в директорию проекта:

1. Использовать direnv (кроссплатформенный):
   - Установить: brew install direnv (Mac) или apt-get install direnv (Linux)
   - Добавить в ~/.bashrc: eval "$(direnv hook bash)"
   - Создать .envrc в директории проекта: echo "source venv/bin/activate" > .envrc
   - Разрешить: direnv allow

2. Использовать autoenv (более простой):
   - Установить: pip install autoenv
   - Добавить в ~/.bashrc: source /path/to/autoenv/activate.sh
   - Создать .env в директории проекта: source venv/bin/activate

3. Использование в IDE (PyCharm, VSCode):
   - В PyCharm: File → Settings → Project → Python Interpreter → выбрать интерпретатор из venv
   - В VSCode: Ctrl+Shift+P → Python: Select Interpreter → выбрать из venv
""")

print("\n=== ПРАКТИЧЕСКИЙ ПРИМЕР РАБОЧЕГО ПРОЦЕССА ===")
workflow = """
# 1. Создание нового проекта
mkdir myproject
cd myproject

# 2. Создание виртуального окружения
python -m venv venv

# 3. Активация окружения
# На Linux/Mac:
source venv/bin/activate
# На Windows:
# venv\\Scripts\\activate

# 4. Установка зависимостей
pip install django==4.0.6
pip install requests
pip install pandas

# 5. Сохранение зависимостей
pip freeze > requirements.txt

# 6. Разработка проекта...
# Создаём файлы, пишем код...

# 7. При переносе проекта на другой компьютер:
# git clone <репозиторий>
# cd project
# python -m venv venv
# source venv/bin/activate
# pip install -r requirements.txt
# Готово к работе!
"""

print(workflow)`,
        "description": "Виртуальные окружения — это изолированные среды Python, которые позволяют управлять зависимостями для отдельных проектов. Основной инструмент — модуль `venv` (встроен в Python 3.3+). Создание: `python -m venv имя_окружения`. Активация зависит от ОС: `source venv/bin/activate` (Linux/Mac), `venv\\Scripts\\activate` (Windows). Деактивация: команда `deactivate`. В активированном окружении команды `python` и `pip` ссылаются на изолированные версии. Зависимости сохраняются в `requirements.txt` с помощью `pip freeze > requirements.txt` и восстанавливаются через `pip install -r requirements.txt`. Виртуальные окружения предотвращают конфликты версий пакетов между проектами и обеспечивают воспроизводимость окружения. Для более сложных случаев можно использовать `virtualenv` (сторонний пакет) или `conda` (для научных вычислений). Интеграция с IDE (PyCharm, VSCode) позволяет выбирать интерпретатор из виртуального окружения."
    },
    {
        "id": 30,
        "title": "Метаклассы и метапрограммирование",
        "tag": "Класс",
        "shortDesc": "Продвинутая тема: создание классов динамически, метаклассы, __new__, __init_subclass__",
        "code": `# Метаклассы — это «классы классов». Они определяют, как создаются классы.
# Это продвинутая тема, используемая в фреймворках (Django, SQLAlchemy).

print("=== КАК СОЗДАЮТСЯ КЛАССЫ (обычный способ) ===")

class SimpleClass:
    """Обычный класс."""
    class_attribute = "value"
    
    def __init__(self, name):
        self.name = name
    
    def method(self):
        return f"Hello, {self.name}"

# То же самое можно сделать динамически с помощью type()
print("Создание класса через type():")
# type(name, bases, dict) — встроенная функция для создания классов
DynamicClass = type(
    "DynamicClass",               # Имя класса
    (object,),                    # Кортеж базовых классов
    {                             # Словарь атрибутов и методов
        "class_attribute": "dynamic_value",
        "__init__": lambda self, name: setattr(self, "name", name),
        "method": lambda self: f"Dynamic hello, {self.name}"
    }
)

# Оба класса работают одинаково
obj1 = SimpleClass("Alice")
obj2 = DynamicClass("Bob")

print(f"SimpleClass: {obj1.method()}")
print(f"DynamicClass: {obj2.method()}")
print(f"type(SimpleClass) = {type(SimpleClass)}")  # <class 'type'>
print(f"type(DynamicClass) = {type(DynamicClass)}")  # <class 'type'>
print()

print("=== МЕТАКЛАССЫ (наследование от type) ===")

class MyMeta(type):
    """
    Метакласс — это класс, унаследованный от type.
    Он может переопределять поведение создания классов.
    """
    
    def __new__(mcs, name, bases, attrs):
        """
        Вызывается ДО создания класса.
        mcs - сам метакласс (MyMeta)
        name - имя создаваемого класса
        bases - кортеж базовых классов
        attrs - словарь атрибутов класса
        Возвращает новый класс.
        """
        print(f"[MyMeta.__new__] Создаётся класс: {name}")
        
        # Модифицируем атрибуты: добавляем префикс ко всем именам методов
        modified_attrs = {}
        for attr_name, attr_value in attrs.items():
            if callable(attr_value) and not attr_name.startswith("__"):
                # Если это метод (кроме магических), добавляем префикс
                new_name = f"my_{attr_name}"
                modified_attrs[new_name] = attr_value
            else:
                modified_attrs[attr_name] = attr_value
        
        # Автоматически добавляем атрибут
        modified_attrs["created_by_meta"] = True
        modified_attrs["__module__"] = "__main__"
        
        # Создаём класс с помощью type.__new__
        return super().__new__(mcs, name, bases, modified_attrs)
    
    def __init__(cls, name, bases, attrs):
        """
        Вызывается ПОСЛЕ создания класса.
        cls - созданный класс (не объект!)
        """
        print(f"[MyMeta.__init__] Класс {name} инициализирован")
        super().__init__(name, bases, attrs)
    
    def __call__(cls, *args, **kwargs):
        """
        Вызывается при создании ЭКЗЕМПЛЯРА класса.
        Позволяет контролировать создание объектов.
        """
        print(f"[MyMeta.__call__] Создаётся экземпляр класса {cls.__name__}")
        
        # Можно добавить логику до создания объекта
        if "forbidden_arg" in kwargs:
            raise ValueError("Недопустимый аргумент!")
        
        # Создаём экземпляр
        instance = super().__call__(*args, **kwargs)
        
        # Можно добавить логику после создания объекта
        instance.created_at = "2024-12-05"
        return instance

# Использование метакласса
print("Создание класса с метаклассом MyMeta:")
class MyClass(metaclass=MyMeta):
    """Класс, созданный с помощью MyMeta."""
    
    class_var = 100
    
    def __init__(self, value):
        self.value = value
    
    def show(self):
        return f"Value: {self.value}"
    
    def display(self):
        return f"Displaying: {self.value}"

print(f"Атрибуты класса MyClass: {[a for a in dir(MyClass) if not a.startswith('__')]}")
print(f"MyClass.created_by_meta = {MyClass.created_by_meta}")

# Создание экземпляра (вызовет MyMeta.__call__)
obj = MyClass(42)
print(f"obj.value = {obj.value}")
print(f"obj.created_at = {obj.created_at}")
print(f"obj.my_show() = {obj.my_show()}")  # Метод переименован!
print()

print("=== ПРАКТИЧЕСКИЙ ПРИМЕР: Регистрация подклассов ===")

class PluginRegistry(type):
    """Метакласс для автоматической регистрации плагинов."""
    
    registry = {}  # Словарь для хранения зарегистрированных плагинов
    
    def __new__(mcs, name, bases, attrs):
        new_class = super().__new__(mcs, name, bases, attrs)
        
        # Регистрируем класс, если он не является базовым
        if name != "BasePlugin":
            PluginRegistry.registry[name] = new_class
            print(f"[PluginRegistry] Зарегистрирован плагин: {name}")
        
        return new_class

class BasePlugin(metaclass=PluginRegistry):
    """Базовый класс для всех плагинов."""
    
    def execute(self):
        raise NotImplementedError

class PluginA(BasePlugin):
    def execute(self):
        return "Выполнен PluginA"

class PluginB(BasePlugin):
    def execute(self):
        return "Выполнен PluginB"

print(f"\nЗарегистрированные плагины: {list(PluginRegistry.registry.keys())}")

# Использование зарегистрированных плагинов
plugin_name = "PluginA"
if plugin_name in PluginRegistry.registry:
    plugin_class = PluginRegistry.registry[plugin_name]
    plugin_instance = plugin_class()
    print(f"Результат выполнения {plugin_name}: {plugin_instance.execute()}")
print()

print("=== __init_subclass__ (альтернатива метаклассам) ===")
# Начиная с Python 3.6, есть более простой способ — __init_subclass__

class BaseWithRegistry:
    """Базовый класс с регистрацией подклассов через __init_subclass__."""
    
    registry = {}
    
    def __init_subclass__(cls, **kwargs):
        """Вызывается при создании подкласса."""
        super().__init_subclass__(**kwargs)
        BaseWithRegistry.registry[cls.__name__] = cls
        print(f"[BaseWithRegistry] Зарегистрирован подкласс: {cls.__name__}")

class SubClass1(BaseWithRegistry):
    pass

class SubClass2(BaseWithRegistry):
    pass

print(f"Зарегистрированные подклассы: {list(BaseWithRegistry.registry.keys())}")
print()

print("=== ДЕКОРАТОР КЛАССОВ ===")
# Иногда вместо метакласса достаточно декоратора класса

def class_decorator(cls):
    """Декоратор, который модифицирует класс."""
    original_init = cls.__init__
    
    def new_init(self, *args, **kwargs):
        print(f"[Декоратор] Создаётся объект {cls.__name__}")
        original_init(self, *args, **kwargs)
        self.decorated = True
    
    cls.__init__ = new_init
    
    # Добавляем метод
    cls.extra_method = lambda self: "Дополнительный метод"
    
    return cls

@class_decorator
class DecoratedClass:
    def __init__(self, value):
        self.value = value
    
    def show(self):
        return f"Value: {self.value}"

obj_decorated = DecoratedClass(100)
print(f"obj_decorated.value = {obj_decorated.value}")
print(f"obj_decorated.decorated = {obj_decorated.decorated}")
print(f"obj_decorated.extra_method() = {obj_decorated.extra_method()}")
print()

print("=== ПРИМЕНЕНИЕ МЕТАКЛАССОВ В РЕАЛЬНОМ МИРЕ ===")
print("""
1. ORM (Object-Relational Mapping) - SQLAlchemy, Django ORM
   class User(Base):
       id = Column(Integer)
       name = Column(String)
   # Base использует метакласс для создания таблиц

2. Валидация данных - pydantic
   class User(BaseModel):
       name: str
       age: int
   # Метакласс проверяет аннотации типов

3. Регистрация плагинов/команд
   class Command(metaclass=CommandMeta):
       pass
   
   class StartCommand(Command):
       def execute(self):
           ...

4. Singleton паттерн
   class SingletonMeta(type):
       _instances = {}
       def __call__(cls, *args, **kwargs):
           if cls not in cls._instances:
               cls._instances[cls] = super().__call__(*args, **kwargs)
           return cls._instances[cls]
""")`,
        "description": "Метаклассы — это классы, которые создают классы. Все классы в Python являются экземплярами `type` (или его подклассов). Метакласс определяется как подкласс `type` и может переопределять методы: `__new__` (создание класса), `__init__` (инициализация класса), `__call__` (создание экземпляра). Метаклассы используются для: 1) автоматической регистрации классов (плагины, команды), 2) проверки/модификации атрибутов класса (ORM, валидация), 3) реализации паттернов (Singleton), 4) добавления функциональности всем подклассам. Более простые альтернативы: `__init_subclass__` (Python 3.6+) для реакции на создание подклассов, декораторы классов. Метаклассы — мощный, но сложный инструмент; используйте их только когда более простые решения недостаточны. Они активно применяются в фреймворках (Django, SQLAlchemy, Pydantic) для создания декларативных API."
    },
    {
        "id": 31,
        "title": "Тестирование: unittest и pytest",
        "tag": "Другое",
        "shortDesc": "Написание и запуск тестов для Python-кода с использованием unittest и pytest",
        "code": `# Тестирование — важная часть разработки. Python предоставляет встроенный модуль unittest.
# Также популярна библиотека pytest, которая предлагает более простой синтаксис.

print("=== МОДУЛЬ unittest (встроенный) ===")
import unittest

# Класс для тестирования
def add(a, b):
    """Простая функция для тестирования."""
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("Деление на ноль!")
    return a / b

class StringUtils:
    """Класс с методами для работы со строками."""
    
    @staticmethod
    def reverse_string(s):
        return s[::-1]
    
    @staticmethod
    def is_palindrome(s):
        s = s.lower().replace(" ", "")
        return s == s[::-1]

# Создаём тестовый класс, наследующийся от unittest.TestCase
class TestMathFunctions(unittest.TestCase):
    """Тесты для математических функций."""
    
    # Методы setUp и tearDown выполняются перед и после КАЖДОГО теста
    def setUp(self):
        """Подготовка перед каждым тестом."""
        print(f"\n[setUp] Подготовка к тесту: {self._testMethodName}")
        self.test_data = [(1, 2, 3), (0, 0, 0), (-1, 5, 4), (3.5, 2.5, 6.0)]
    
    def tearDown(self):
        """Очистка после каждого теста."""
        print(f"[tearDown] Очистка после теста: {self._testMethodName}")
    
    # Тестовые методы должны начинаться с test_
    def test_add_positive_numbers(self):
        """Тест сложения положительных чисел."""
        self.assertEqual(add(2, 3), 5)  # Проверка равенства
        self.assertEqual(add(0, 0), 0)
    
    def test_add_with_test_data(self):
        """Тест сложения с использованием подготовленных данных."""
        for a, b, expected in self.test_data:
            with self.subTest(a=a, b=b, expected=expected):
                result = add(a, b)
                self.assertEqual(result, expected)
    
    def test_add_negative_numbers(self):
        """Тест сложения отрицательных чисел."""
        self.assertEqual(add(-5, -3), -8)
        self.assertNotEqual(add(-1, -1), 0)  # Проверка НЕравенства
    
    def test_divide_normal(self):
        """Тест нормального деления."""
        self.assertEqual(divide(10, 2), 5)
        self.assertAlmostEqual(divide(1, 3), 0.333333, places=5)  # Приблизительное равенство
    
    def test_divide_by_zero(self):
        """Тест деления на ноль (ожидаем исключение)."""
        with self.assertRaises(ValueError) as context:
            divide(10, 0)
        self.assertEqual(str(context.exception), "Деление на ноль!")
    
    def test_types(self):
        """Тесты проверки типов."""
        self.assertIsInstance(add(1, 2), (int, float))  # Результат - int или float
        self.assertIsNot(add, divide)  # Проверка, что это разные объекты

# Тесты для класса StringUtils
class TestStringUtils(unittest.TestCase):
    
    def test_reverse_string(self):
        self.assertEqual(StringUtils.reverse_string("hello"), "olleh")
        self.assertEqual(StringUtils.reverse_string(""), "")
        self.assertEqual(StringUtils.reverse_string("a"), "a")
    
    def test_is_palindrome(self):
        self.assertTrue(StringUtils.is_palindrome("racecar"))
        self.assertTrue(StringUtils.is_palindrome("А роза упала на лапу Азора"))
        self.assertFalse(StringUtils.is_palindrome("hello"))
        self.assertTrue(StringUtils.is_palindrome(""))

# Запуск тестов unittest
print("Запуск тестов unittest:")
# unittest.main() запускает все тесты, но мы запустим их вручную для демонстрации
loader = unittest.TestLoader()
suite = loader.loadTestsFromTestCase(TestMathFunctions)
runner = unittest.TextTestRunner(verbosity=2)
print("\n" + "="*50)
result = runner.run(suite)
print("="*50 + "\n")

print("=== БИБЛИОТЕКА pytest (устанавливается отдельно) ===")
# pytest — популярная библиотека для тестирования.
# Установка: pip install pytest
# Тесты — это просто функции с префиксом test_ в файлах с префиксом test_

# Пример тестовых функций для pytest
def test_add():
    """Простой тест для функции add."""
    assert add(2, 3) == 5
    assert add(0, 0) == 0
    assert add(-1, 1) == 0

def test_divide():
    assert divide(10, 2) == 5
    
    # Проверка исключений в pytest
    import pytest
    with pytest.raises(ValueError, match="Деление на ноль!"):
        divide(10, 0)

# Фикстуры (fixtures) в pytest — мощный инструмент для подготовки данных
# @pytest.fixture
# def sample_data():
#     return {"a": 1, "b": 2, "expected": 3}
# 
# def test_with_fixture(sample_data):
#     assert add(sample_data["a"], sample_data["b"]) == sample_data["expected"]

print("""
Для запуска тестов pytest в терминале:
    pytest test_file.py                # Запуск всех тестов в файле
    pytest test_file.py::test_add      # Запуск конкретного теста
    pytest -v                          # Подробный вывод
    pytest -x                          # Остановка при первой ошибке
    pytest --cov=my_module             # Покрытие кода (нужен pytest-cov)
""")

print("\n=== МОКИРОВАНИЕ (mock) ===")
# Мокирование позволяет подменять реальные объекты на тестовые
from unittest.mock import Mock, MagicMock, patch

def test_with_mocks():
    """Демонстрация моков."""
    
    # Создание мок-объекта
    mock_obj = Mock()
    mock_obj.method.return_value = 42  # Задаём возвращаемое значение
    
    print(f"Мок-объект: {mock_obj.method()}")
    print(f"Метод вызван? {mock_obj.method.called}")
    print(f"Сколько раз вызван? {mock_obj.method.call_count}")
    
    # Мок с побочным эффектом
    mock_with_side_effect = Mock(side_effect=[1, 2, 3])
    print(f"side_effect 1: {mock_with_side_effect()}")
    print(f"side_effect 2: {mock_with_side_effect()}")
    
    # Патчинг (временная замена объекта)
    with patch('builtins.len', return_value=100):
        # Внутри этого блока len() всегда возвращает 100
        print(f"Запатченный len('hello'): {len('hello')}")
    
    print(f"Обычный len('hello'): {len('hello')}")

test_with_mocks()
print()

print("=== ТЕСТИРОВАНИЕ КЛАССОВ И ИСКЛЮЧЕНИЙ ===")

class BankAccount:
    """Класс банковского счёта для тестирования."""
    
    def __init__(self, balance=0):
        self.balance = balance
    
    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Сумма должна быть положительной")
        self.balance += amount
        return self.balance
    
    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Сумма должна быть положительной")
        if amount > self.balance:
            raise ValueError("Недостаточно средств")
        self.balance -= amount
        return self.balance

class TestBankAccount(unittest.TestCase):
    
    def setUp(self):
        self.account = BankAccount(100)
    
    def test_initial_balance(self):
        self.assertEqual(self.account.balance, 100)
    
    def test_deposit_positive(self):
        new_balance = self.account.deposit(50)
        self.assertEqual(new_balance, 150)
        self.assertEqual(self.account.balance, 150)
    
    def test_deposit_negative(self):
        with self.assertRaises(ValueError) as context:
            self.account.deposit(-10)
        self.assertIn("положительной", str(context.exception))
    
    def test_withdraw_success(self):
        new_balance = self.account.withdraw(30)
        self.assertEqual(new_balance, 70)
    
    def test_withdraw_insufficient_funds(self):
        with self.assertRaises(ValueError) as context:
            self.account.withdraw(200)
        self.assertIn("Недостаточно средств", str(context.exception))
    
    def test_withdraw_negative(self):
        with self.assertRaises(ValueError):
            self.account.withdraw(-10)

print("\n=== ПАРАМЕТРИЗОВАННЫЕ ТЕСТЫ ===")
# Параметризованные тесты позволяют запускать один тест с разными данными

class TestParameterized(unittest.TestCase):
    
    # В unittest можно использовать subTest
    def test_add_parameterized(self):
        test_cases = [
            (1, 2, 3),
            (0, 0, 0),
            (-1, 1, 0),
            (3.5, 2.5, 6.0),
        ]
        
        for a, b, expected in test_cases:
            with self.subTest(a=a, b=b, expected=expected):
                result = add(a, b)
                self.assertEqual(result, expected)

# В pytest есть декоратор @pytest.mark.parametrize
# @pytest.mark.parametrize("a,b,expected", [
#     (1, 2, 3),
#     (0, 0, 0),
#     (-1, 1, 0),
# ])
# def test_parametrized_add(a, b, expected):
#     assert add(a, b) == expected

print("\n=== ЛУЧШИЕ ПРАКТИКИ ТЕСТИРОВАНИЯ ===")
best_practices = """
1. Имена тестов должны быть описательными: test_function_name_scenario_expected
2. Каждый тест должен проверять одну вещь (Single Responsibility Principle)
3. Используйте setUp для подготовки общих данных, tearDown для очистки
4. Тесты должны быть независимыми и идемпотентными
5. Тестируйте не только «счастливый путь», но и граничные случаи, ошибки
6. Используйте моки для внешних зависимостей (API, базы данных)
7. Стремитесь к высокому покрытию кода (code coverage), но не гонитесь за 100%
8. Тесты должны быть быстрыми — не тестируйте ввод/вывод без необходимости
9. Рефакторите тесты вместе с кодом
10. Автоматизируйте запуск тестов (CI/CD)

Популярные инструменты:
- unittest: встроенный, хорош для начала
- pytest: более мощный и удобный синтаксис
- nose2: альтернатива unittest
- coverage.py: измерение покрытия кода
- tox: тестирование в разных окружениях
- hypothesis: property-based тестирование
"""

print(best_practices)`,
        "description": "Тестирование — ключевая практика разработки ПО. Python предоставляет встроенный модуль `unittest`, основанный на концепциях xUnit. Тесты организуются в классы, наследующие от `unittest.TestCase`. Методы `setUp()` и `tearDown()` выполняются перед и после каждого теста. Тестовые методы должны начинаться с `test_`. Основные методы проверок (assert): `assertEqual(a, b)`, `assertTrue(x)`, `assertRaises(exception)`, `assertAlmostEqual(a, b)`. `pytest` — популярная сторонняя библиотека, предлагающая более простой синтаксис (тесты как функции), мощные фикстуры (`@pytest.fixture`), параметризацию (`@pytest.mark.parametrize`). Модуль `unittest.mock` позволяет создавать мок-объекты, подменять реальные объекты (`patch`) и проверять вызовы. Тестирование должно покрывать основные сценарии, граничные случаи и обработку ошибок. Автоматизированные тесты — основа CI/CD и регрессионного тестирования."
    },
    {
        "id": 32,
        "title": "Наследование классов и метод super()",
        "tag": "Класс",
        "shortDesc": "Базовое и многоуровневое наследование, переопределение методов, использование super() для доступа к родительскому классу",
        "code": `# Наследование позволяет создавать новый класс на основе существующего (родительского).
# Дочерний класс наследует атрибуты и методы родительского класса и может их расширять или изменять.

print("=== БАЗОВОЕ НАСЛЕДОВАНИЕ ===")

class Animal:
    """Родительский (базовый) класс для всех животных."""
    
    def __init__(self, name, species):
        self.name = name
        self.species = species
        self.is_alive = True
        print(f"[Animal.__init__] Создано животное: {name} ({species})")
    
    def speak(self):
        return "Животное издает звук"
    
    def eat(self, food):
        print(f"{self.name} ест {food}")
    
    def sleep(self):
        print(f"{self.name} спит")
        return "zzz..."

class Dog(Animal):  # Dog наследует от Animal
    """Дочерний класс Dog, расширяющий класс Animal."""
    
    def __init__(self, name, breed):
        # Вызываем конструктор родительского класса для инициализации общих атрибутов
        super().__init__(name, species="Собака")  # super() возвращает объект-посредник для доступа к методам родителя
        self.breed = breed  # Добавляем новый атрибут, специфичный для собак
        self.tricks = []    # И еще один
        print(f"[Dog.__init__] Порода: {breed}")
    
    # Переопределение метода родительского класса
    def speak(self):
        # Полностью заменяем реализацию
        return f"{self.name} говорит: Гав-гав!"
    
    def wag_tail(self):
        # Новый метод, которого нет у родительского класса
        print(f"{self.name} виляет хвостом")
        return "Счастлив!"
    
    # Расширение метода родителя (дополнение, а не замена)
    def eat(self, food):
        # Сначала вызываем метод родителя
        super().eat(food)  # Вызываем eat из Animal
        # Затем добавляем свою логику
        print(f"{self.name} благодарно виляет хвостом после еды")
        return "Наелся"

# Создаем объект дочернего класса
my_dog = Dog("Барсик", "Дворняжка")
print(f"\nИмя собаки: {my_dog.name}")      # Унаследовано от Animal
print(f"Вид: {my_dog.species}")          # Унаследовано от Animal
print(f"Порода: {my_dog.breed}")         # Собственный атрибут Dog
print(f"Звук: {my_dog.speak()}")         # Используется переопределенный метод
print(f"Сон: {my_dog.sleep()}")          # Унаследованный метод без изменений

# Вызов расширенного метода
print(f"\nКормление собаки:")
result = my_dog.eat("косточку")
print(f"Результат: {result}")

# Вызов собственного метода дочернего класса
happiness = my_dog.wag_tail()
print(f"Реакция: {happiness}")

print("\n=== МНОГОУРОВНЕВОЕ НАСЛЕДОВАНИЕ ===")

class WorkingDog(Dog):
    """Класс, наследуемый от Dog (внук Animal)."""
    
    def __init__(self, name, breed, job):
        super().__init__(name, breed)  # Вызываем конструктор Dog
        self.job = job
        print(f"[WorkingDog.__init__] Работа: {job}")
    
    # Переопределяем метод speak еще раз
    def speak(self):
        # Можно вызвать метод родителя (Dog.speak()), а можно сделать свою реализацию
        return f"{self.name} ({self.job}) говорит: Тяв-тяв! К работе готов!"
    
    def work(self):
        print(f"{self.name} выполняет свою работу: {self.job}")
        return "Работа выполнена"

# Создаем объект класса-внука
shepherd = WorkingDog("Рекс", "Овчарка", "охрана территории")
print(f"\nРабочая собака: {shepherd.name}, порода: {shepherd.breed}, работа: {shepherd.job}")
print(f"Звук: {shepherd.speak()}")
print(f"Спит: {shepherd.sleep()}")  # Метод унаследован от Animal через Dog

# Цепочка вызовов методов через super()
print(f"\nКормление рабочей собаки:")
shepherd.eat("спецпаек")  # Вызовет Dog.eat(), который вызовет Animal.eat()

print("\n=== ПРОВЕРКА ТИПОВ И ИЕРАРХИИ ===")

# Проверка принадлежности классу
print(f"shepherd является WorkingDog? {isinstance(shepherd, WorkingDog)}")
print(f"shepherd является Dog? {isinstance(shepherd, Dog)}")
print(f"shepherd является Animal? {isinstance(shepherd, Animal)}")
print(f"shepherd является object? {isinstance(shepherd, object)}")

# Проверка наследования
print(f"\nWorkingDog является подклассом Dog? {issubclass(WorkingDog, Dog)}")
print(f"WorkingDog является подклассом Animal? {issubclass(WorkingDog, Animal)}")
print(f"Dog является подклассом Animal? {issubclass(Dog, Animal)}")

# Полиморфизм: функция, работающая с любым Animal
def animal_sound(animal):
    """Демонстрация полиморфизма: функция работает с любым объектом Animal."""
    print(f"Звук: {animal.speak()}")

print("\nПолиморфизм в действии:")
animal_sound(Animal("Неизвестно", "неизвестно"))
animal_sound(my_dog)
animal_sound(shepherd)

print("\n=== РАСШИРЕННОЕ ИСПОЛЬЗОВАНИЕ super() ===")

class Base:
    def __init__(self):
        print("Base.__init__")
        self.base_value = 10

class Middle(Base):
    def __init__(self):
        print("Middle.__init__ (до super())")
        super().__init__()  # Вызываем Base.__init__
        print("Middle.__init__ (после super())")
        self.middle_value = 20

class Child(Middle):
    def __init__(self):
        print("Child.__init__ (до super())")
        super().__init__()  # Вызывает Middle.__init__, который вызовет Base.__init__
        print("Child.__init__ (после super())")
        self.child_value = 30

print("\nСоздаем объект Child:")
obj = Child()
print(f"Атрибуты: base_value={obj.base_value}, middle_value={obj.middle_value}, child_value={obj.child_value}")

# super() работает динамически - учитывает MRO (Method Resolution Order)
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method (до super())")
        super().method()
        print("B.method (после super())")

class C(A):
    def method(self):
        print("C.method (до super())")
        super().method()
        print("C.method (после super())")

class D(B, C):
    def method(self):
        print("D.method (до super())")
        super().method()
        print("D.method (после super())")

print("\nМножественное наследование и super():")
d = D()
d.method()
print(f"MRO класса D: {D.__mro__}")  # Порядок разрешения методов`,
        "description": "Наследование — один из ключевых принципов ООП, позволяющий создавать иерархии классов. Дочерний класс наследует все атрибуты и методы родительского класса и может: 1) добавлять новые атрибуты/методы, 2) переопределять существующие методы, 3) расширять методы родителя с помощью `super()`. `super()` возвращает объект-посредник, делегирующий вызовы методов родительскому классу. Он особенно важен в конструкторах для правильной инициализации. Многоуровневое наследование создает цепочки классов. Python поддерживает полиморфизм: объекты разных классов с общим родителем могут использоваться взаимозаменяемо, если они реализуют одинаковые методы. Функции `isinstance()` и `issubclass()` проверяют принадлежность объектов классам и отношения наследования. `super()` автоматически определяет порядок вызовов в соответствии с MRO (Method Resolution Order)."
    },
    {
        "id": 33,
        "title": "Множественное наследование и миксины",
        "tag": "Класс",
        "shortDesc": "Наследование от нескольких классов, Method Resolution Order (MRO), создание и использование миксинов",
        "code": `# Множественное наследование позволяет классу наследовать от нескольких родительских классов.
# Миксины (mixins) — специальные классы, предназначенные для добавления функциональности другим классам.

print("=== МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ: ОСНОВЫ ===")

class Engine:
    """Класс, представляющий двигатель."""
    
    def __init__(self, horsepower):
        self.horsepower = horsepower
    
    def start(self):
        print(f"Двигатель запущен ({self.horsepower} л.с.)")
        return "Врум-врум"
    
    def stop(self):
        print("Двигатель остановлен")

class ElectricSystem:
    """Класс, представляющий электрическую систему."""
    
    def __init__(self, voltage):
        self.voltage = voltage
        self.battery_level = 100
    
    def charge(self, amount):
        self.battery_level = min(100, self.battery_level + amount)
        print(f"Заряжено на {amount}%. Уровень: {self.battery_level}%")
    
    def power_on(self):
        if self.battery_level > 10:
            print(f"Электрическая система включена ({self.voltage}V)")
            return True
        else:
            print("Недостаточно заряда!")
            return False

# Класс с множественным наследованием
class HybridCar(Engine, ElectricSystem):
    """Класс, наследуемый от Engine и ElectricSystem."""
    
    def __init__(self, model, horsepower, voltage):
        # Важно правильно инициализировать оба родительских класса
        Engine.__init__(self, horsepower)
        ElectricSystem.__init__(self, voltage)
        self.model = model
    
    def hybrid_start(self):
        """Запуск гибридной системы."""
        print(f"Запуск {self.model}...")
        electric_ok = self.power_on()  # Метод из ElectricSystem
        if electric_ok:
            self.start()  # Метод из Engine
            return "Гибридная система запущена"
        else:
            return "Ошибка запуска"

# Создаем объект класса с множественным наследованием
prius = HybridCar("Toyota Prius", 120, 220)
print(f"Модель: {prius.model}")
print(f"Мощность: {prius.horsepower} л.с.")  # Из Engine
print(f"Напряжение: {prius.voltage}V")        # Из ElectricSystem
print(f"Уровень заряда: {prius.battery_level}%")  # Из ElectricSystem

print("\nЗапуск гибридной системы:")
result = prius.hybrid_start()
print(f"Результат: {result}")

prius.charge(30)  # Метод из ElectricSystem
prius.stop()      # Метод из Engine

print("\n=== METHOD RESOLUTION ORDER (MRO) ===")
# MRO определяет порядок поиска методов при множественном наследовании

class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")

class C(A):
    def method(self):
        print("C.method")

class D(B, C):
    pass

print(f"MRO класса D: {D.__mro__}")
# Вывод: (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

d = D()
d.method()  # Вызовет B.method (первый в MRO)

# Алгоритм C3 линеаризации (используется в Python)
print("\nПроверка MRO для разных иерархий:")
print(f"MRO HybridCar: {HybridCar.__mro__}")

# Конфликт имен методов
print("\n=== РАЗРЕШЕНИЕ КОНФЛИКТОВ ИМЕН ===")

class Parent1:
    def common_method(self):
        print("Parent1.common_method")

class Parent2:
    def common_method(self):
        print("Parent2.common_method")

class Child(Parent1, Parent2):
    def use_common(self):
        # Явно вызываем метод определенного родителя
        Parent1.common_method(self)
        Parent2.common_method(self)
        
        # Или используем super() - вызовется метод первого родителя в MRO
        super().common_method()

child = Child()
print("Вызов методов с одинаковыми именами:")
child.use_common()

print("\n=== МИКСИНЫ (MIXINS) ===")
# Миксины — классы, которые не предназначены для самостоятельного использования,
# а добавляют функциональность другим классам через множественное наследование.

# Миксины обычно не имеют своего состояния (__init__) или вызывают super().__init__()
# Их имена часто заканчиваются на Mixin

class JSONSerializableMixin:
    """Миксин для добавления JSON-сериализации."""
    
    def to_json(self):
        import json
        # Собираем все атрибуты объекта в словарь
        data = {key: value for key, value in self.__dict__.items() 
                if not key.startswith('_')}
        return json.dumps(data, ensure_ascii=False, indent=2)
    
    @classmethod
    def from_json(cls, json_string):
        import json
        data = json.loads(json_string)
        return cls(**data)

class LoggingMixin:
    """Миксин для добавления логирования действий."""
    
    def log(self, message):
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        class_name = self.__class__.__name__
        print(f"[{timestamp}] {class_name}: {message}")

class EqualsMixin:
    """Миксин для добавления сравнения объектов по атрибутам."""
    
    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__
    
    def __ne__(self, other):
        return not self.__eq__(other)

# Используем миксины для создания класса
class Product(JSONSerializableMixin, LoggingMixin, EqualsMixin):
    """Класс продукта с функциональностью из миксинов."""
    
    def __init__(self, name, price, category):
        self.name = name
        self.price = price
        self.category = category
        self.log(f"Создан продукт: {name}")  # Используем метод из миксина
    
    def apply_discount(self, percent):
        old_price = self.price
        self.price *= (1 - percent / 100)
        self.log(f"Скидка {percent}% применена: {old_price} -> {self.price}")

# Создаем и используем продукт с функциональностью миксинов
print("Создание продукта с миксинами:")
laptop = Product("Ноутбук", 1000, "Электроника")
laptop.apply_discount(10)

print(f"\nJSON представление продукта:\n{laptop.to_json()}")

# Создаем второй продукт для сравнения
laptop2 = Product("Ноутбук", 900, "Электроника")
print(f"\nСравнение продуктов (==): {laptop == laptop2}")
print(f"Сравнение продуктов (!=): {laptop != laptop2}")

print("\n=== МИКСИНЫ С НАСЛЕДОВАНИЕМ И SUPER() ===")

class BaseClass:
    def __init__(self):
        print("BaseClass.__init__")
        self.base_value = "base"

class Mixin1:
    def __init__(self):
        print("Mixin1.__init__")
        super().__init__()  # Важно вызывать super() в миксинах!
        self.mixin1_value = "mixin1"

class Mixin2:
    def __init__(self):
        print("Mixin2.__init__")
        super().__init__()
        self.mixin2_value = "mixin2"

class CombinedClass(Mixin1, Mixin2, BaseClass):
    def __init__(self):
        print("CombinedClass.__init__ (до super())")
        super().__init__()
        print("CombinedClass.__init__ (после super())")
        self.combined_value = "combined"

print("\nСоздание объекта с миксинами и super():")
obj = CombinedClass()
print(f"MRO CombinedClass: {CombinedClass.__mro__}")
print(f"Атрибуты: {obj.__dict__}")

print("\n=== ПРАКТИЧЕСКОЕ ПРИМЕНЕНИЕ МИКСИНОВ ===")

# Миксины часто используются в Django, SQLAlchemy и других фреймворках
class TimestampMixin:
    """Добавляет временные метки создания и обновления."""
    
    def __init__(self, *args, **kwargs):
        import time
        super().__init__(*args, **kwargs)
        self.created_at = time.time()
        self.updated_at = time.time()
    
    def update(self):
        import time
        self.updated_at = time.time()

class SlugMixin:
    """Добавляет slug (человеко-читаемый URL) на основе названия."""
    
    def generate_slug(self):
        import re
        if hasattr(self, 'name'):
            slug = re.sub(r'[^\\w\\s-]', '', self.name.lower())
            slug = re.sub(r'[-\\s]+', '-', slug).strip('-')
            self.slug = slug
            return slug
        return None

class Article(TimestampMixin, SlugMixin):
    def __init__(self, title, content):
        self.name = title  # Для SlugMixin
        self.title = title
        self.content = content
        super().__init__()  # Инициализируем миксины
    
    def __repr__(self):
        return f"Article('{self.title}', создана: {self.created_at})"

article = Article("Новости Python 3.12", "Вышла новая версия Python...")
print(f"Статья: {article}")
print(f"Slug: {article.generate_slug()}")
print(f"Временные метки: создана {article.created_at}, обновлена {article.updated_at}")

# Обновляем статью
article.update()
print(f"После обновления: {article.updated_at}")`,
        "description": "Множественное наследование позволяет классу наследовать функциональность от нескольких родительских классов одновременно. При этом важен порядок наследования, который определяет MRO (Method Resolution Order) — алгоритм C3 линеаризации в Python. `super()` автоматически работает в соответствии с MRO, вызывая методы родителей в правильном порядке. Миксины — это специальные классы, предназначенные не для самостоятельного использования, а для добавления определенной функциональности другим классам через множественное наследование. Миксины обычно: 1) не имеют собственного состояния или вызывают `super().__init__()`, 2) добавляют конкретную функциональность (сериализация, логирование, сравнение), 3) имеют имена с суффиксом `Mixin`. Миксины широко используются в фреймворках (Django, SQLAlchemy) для создания гибких, модульных классов. Важно правильно проектировать миксины, чтобы они корректно работали с `super()` и не конфликтовали между собой."
    },
    {
        "id": 34,
        "title": "Цепочка обязанностей (Chain of Responsibility)",
        "tag": "Шаблоны",
        "shortDesc": "Паттерн проектирования для создания цепочки обработчиков, где каждый решает, может ли он обработать запрос",
        "code": `# Паттерн "Цепочка обязанностей" позволяет передавать запрос по цепочке обработчиков.
# Каждый обработчик решает, может ли он обработать запрос, и либо обрабатывает его, либо передаёт дальше.

print("=== БАЗОВАЯ РЕАЛИЗАЦИЯ ЦЕПОЧКИ ОБЯЗАННОСТЕЙ ===")

class Handler:
    """
    Абстрактный базовый класс для всех обработчиков в цепочке.
    Определяет интерфейс для обработки запросов и связь с следующим обработчиком.
    """
    
    def __init__(self):
        self._next_handler = None  # Ссылка на следующий обработчик в цепочке
    
    def set_next(self, handler):
        """Устанавливает следующий обработчик в цепочке."""
        self._next_handler = handler
        # Возвращаем handler для создания fluent interface (handler1.set_next(handler2).set_next(handler3))
        return handler
    
    def handle(self, request):
        """
        Обрабатывает запрос или передаёт его следующему обработчику.
        Этот метод должен быть переопределен в подклассах.
        """
        if self._next_handler:
            return self._next_handler.handle(request)
        # Если следующего обработчика нет - запрос не обработан
        print(f"Запрос '{request}' не был обработан")
        return None
    
    def _can_handle(self, request):
        """
        Проверяет, может ли данный обработчик обработать запрос.
        Должен быть реализован в конкретных обработчиках.
        """
        raise NotImplementedError("Подклассы должны реализовать этот метод")

class ConcreteHandlerA(Handler):
    """Конкретный обработчик, который обрабатывает запросы типа 'A'."""
    
    def _can_handle(self, request):
        return request.get('type') == 'A' or 'A' in str(request)
    
    def handle(self, request):
        print(f"[ConcreteHandlerA] Проверяю запрос: {request}")
        if self._can_handle(request):
            print(f"[ConcreteHandlerA] Обрабатываю запрос типа A: {request}")
            return f"Запрос A обработан: {request}"
        else:
            print(f"[ConcreteHandlerA] Не могу обработать, передаю дальше...")
            return super().handle(request)

class ConcreteHandlerB(Handler):
    """Конкретный обработчик, который обрабатывает запросы типа 'B'."""
    
    def _can_handle(self, request):
        return request.get('type') == 'B' or 'B' in str(request)
    
    def handle(self, request):
        print(f"[ConcreteHandlerB] Проверяю запрос: {request}")
        if self._can_handle(request):
            print(f"[ConcreteHandlerB] Обрабатываю запрос типа B: {request}")
            return f"Запрос B обработан: {request}"
        else:
            print(f"[ConcreteHandlerB] Не могу обработать, передаю дальше...")
            return super().handle(request)

class ConcreteHandlerC(Handler):
    """Конкретный обработчик, который обрабатывает все остальные запросы."""
    
    def _can_handle(self, request):
        return True  # Этот обработчик обрабатывает всё
    
    def handle(self, request):
        print(f"[ConcreteHandlerC] Проверяю запрос: {request}")
        if self._can_handle(request):
            print(f"[ConcreteHandlerC] Обрабатываю запрос (универсальный): {request}")
            return f"Запрос C обработан: {request}"
        else:
            print(f"[ConcreteHandlerC] Не могу обработать, передаю дальше...")
            return super().handle(request)

# Создаём цепочку обработчиков
print("Создаём цепочку обработчиков A -> B -> C:")
handler_a = ConcreteHandlerA()
handler_b = ConcreteHandlerB()
handler_c = ConcreteHandlerC()

# Собираем цепочку
handler_a.set_next(handler_b).set_next(handler_c)

# Тестируем цепочку с разными запросами
print("\n=== ТЕСТИРОВАНИЕ ЦЕПОЧКИ ===")

test_requests = [
    {"type": "A", "data": "Данные для A"},
    {"type": "B", "data": "Данные для B"},
    {"type": "D", "data": "Неизвестный тип"},
    "Просто строка с буквой A",
    "Просто строка с буквой B",
    "Строка без специальных букв"
]

for request in test_requests:
    print(f"\n{'='*50}")
    print(f"Обрабатываем запрос: {request}")
    result = handler_a.handle(request)
    print(f"Результат: {result}")

print("\n=== ПРИМЕР: СИСТЕМА АУТЕНТИФИКАЦИИ И АВТОРИЗАЦИИ ===")

class AuthRequest:
    """Класс, представляющий запрос на аутентификацию."""
    
    def __init__(self, username, password, resource, role_required=None):
        self.username = username
        self.password = password
        self.resource = resource
        self.role_required = role_required
        self.authenticated = False
        self.authorized = False
        self.user_roles = []

class AuthHandler:
    """Базовый класс для обработчиков аутентификации/авторизации."""
    
    def __init__(self):
        self.next_handler = None
    
    def set_next(self, handler):
        self.next_handler = handler
        return handler
    
    def handle(self, request):
        if self.next_handler:
            return self.next_handler.handle(request)
        return request

class InputValidationHandler(AuthHandler):
    """Проверяет корректность входных данных."""
    
    def handle(self, request):
        print(f"[InputValidation] Проверяю входные данные...")
        
        if not request.username or not request.password:
            print(f"[InputValidation] Ошибка: имя пользователя или пароль пусты")
            return None
        
        if len(request.password) < 6:
            print(f"[InputValidation] Ошибка: пароль слишком короткий")
            return None
        
        print(f"[InputValidation] Входные данные корректны")
        return super().handle(request)

class AuthenticationHandler(AuthHandler):
    """Проверяет логин и пароль."""
    
    # В реальной системе здесь была бы проверка в базе данных
    VALID_USERS = {
        "admin": "admin123",
        "user": "password123",
        "guest": "guest123"
    }
    
    USER_ROLES = {
        "admin": ["admin", "user", "guest"],
        "user": ["user", "guest"],
        "guest": ["guest"]
    }
    
    def handle(self, request):
        print(f"[Authentication] Проверяю аутентификацию для {request.username}...")
        
        if request.username in self.VALID_USERS:
            if request.password == self.VALID_USERS[request.username]:
                request.authenticated = True
                request.user_roles = self.USER_ROLES[request.username]
                print(f"[Authentication] Пользователь {request.username} аутентифицирован")
                print(f"[Authentication] Роли пользователя: {request.user_roles}")
            else:
                print(f"[Authentication] Неверный пароль для {request.username}")
                return None
        else:
            print(f"[Authentication] Пользователь {request.username} не найден")
            return None
        
        return super().handle(request)

class AuthorizationHandler(AuthHandler):
    """Проверяет права доступа к ресурсу."""
    
    def handle(self, request):
        if not request.authenticated:
            print(f"[Authorization] Ошибка: пользователь не аутентифицирован")
            return None
        
        print(f"[Authorization] Проверяю авторизацию для доступа к {request.resource}...")
        
        if request.role_required:
            # Проверяем, есть ли у пользователя необходимая роль
            if request.role_required in request.user_roles:
                request.authorized = True
                print(f"[Authorization] Доступ к {request.resource} разрешен")
            else:
                print(f"[Authorization] Отказано в доступе к {request.resource}. "
                      f"Требуется роль: {request.role_required}, доступные: {request.user_roles}")
                return None
        else:
            # Если роль не требуется, доступ разрешен
            request.authorized = True
            print(f"[Authorization] Доступ к {request.resource} разрешен (роль не требуется)")
        
        return super().handle(request)

class LoggingHandler(AuthHandler):
    """Логирует результат обработки запроса."""
    
    def handle(self, request):
        print(f"\n[Logging] ИТОГ ОБРАБОТКИ ЗАПРОСА:")
        print(f"  Пользователь: {request.username}")
        print(f"  Ресурс: {request.resource}")
        print(f"  Аутентифицирован: {request.authenticated}")
        print(f"  Авторизован: {request.authorized}")
        print(f"  Роли: {request.user_roles}")
        
        if request.authenticated and request.authorized:
            print(f"  РЕЗУЛЬТАТ: Доступ разрешен!")
        else:
            print(f"  РЕЗУЛЬТАТ: Доступ запрещен!")
        
        return request

# Создаём цепочку для системы аутентификации
print("\nСоздаём цепочку аутентификации:")
validation = InputValidationHandler()
auth = AuthenticationHandler()
authorization = AuthorizationHandler()
logging = LoggingHandler()

# Собираем цепочку: проверка ввода -> аутентификация -> авторизация -> логирование
validation.set_next(auth).set_next(authorization).set_next(logging)

# Тестируем систему
print("\n" + "="*60)
print("ТЕСТ 1: Корректный администратор")
request1 = AuthRequest("admin", "admin123", "/admin-panel", "admin")
result1 = validation.handle(request1)

print("\n" + "="*60)
print("ТЕСТ 2: Обычный пользователь пытается получить доступ к админ-панели")
request2 = AuthRequest("user", "password123", "/admin-panel", "admin")
result2 = validation.handle(request2)

print("\n" + "="*60)
print("ТЕСТ 3: Гостевой доступ к публичной странице")
request3 = AuthRequest("guest", "guest123", "/public-page")
result3 = validation.handle(request3)

print("\n" + "="*60)
print("ТЕСТ 4: Неверный пароль")
request4 = AuthRequest("admin", "wrongpassword", "/admin-panel", "admin")
result4 = validation.handle(request4)

print("\n=== ДИНАМИЧЕСКОЕ СОЗДАНИЕ ЦЕПОЧЕК ===")

class HandlerFactory:
    """Фабрика для создания цепочек обработчиков."""
    
    @staticmethod
    def create_chain(handler_classes):
        """Создаёт цепочку из переданных классов обработчиков."""
        if not handler_classes:
            return None
        
        # Создаём первый обработчик
        first_handler = handler_classes[0]()
        current_handler = first_handler
        
        # Добавляем остальные обработчики в цепочку
        for handler_class in handler_classes[1:]:
            next_handler = handler_class()
            current_handler.set_next(next_handler)
            current_handler = next_handler
        
        return first_handler

# Динамическое создание цепочки
print("\nДинамическое создание цепочки обработчиков:")
chain = HandlerFactory.create_chain([
    ConcreteHandlerA,
    ConcreteHandlerB,
    ConcreteHandlerC
])

# Используем созданную цепочку
test_request = {"type": "B", "data": "Динамический запрос"}
print(f"Обрабатываем запрос через динамическую цепочку: {test_request}")
result = chain.handle(test_request)
print(f"Результат: {result}")`,
        "description": "Паттерн 'Цепочка обязанностей' (Chain of Responsibility) позволяет создавать цепочку обработчиков для обработки запросов. Каждый обработчик в цепочке решает, может ли он обработать запрос. Если может — обрабатывает, если нет — передаёт следующему обработчику. Это позволяет: 1) уменьшить связанность между отправителем и получателем запроса, 2) гибко настраивать порядок обработки, 3) динамически добавлять или удалять обработчики. Паттерн часто используется в системах аутентификации/авторизации, middleware веб-фреймворков, обработчиках событий GUI. Ключевые компоненты: абстрактный класс `Handler` (определяет интерфейс и связь с следующим обработчиком), конкретные обработчики (реализуют логику обработки запросов), клиент (инициирует запрос и передаёт его первому обработчику в цепочке). Для удобства создания цепочек можно реализовать fluent interface через метод `set_next()`, возвращающий установленный обработчик."
    },
    {
        "id": 35,
        "title": "Обработчики событий и паттерн Наблюдатель",
        "tag": "Шаблоны",
        "shortDesc": "Реализация системы событий и паттерна Наблюдатель (Observer) для отслеживания изменений",
        "code": `# Паттерн "Наблюдатель" (Observer) определяет зависимость "один-ко-многим" между объектами.
# При изменении состояния одного объекта все зависящие от него объекты уведомляются и обновляются.

print("=== БАЗОВАЯ РЕАЛИЗАЦИЯ ПАТТЕРНА НАБЛЮДАТЕЛЬ ===")

class Subject:
    """
    Субъект (Observable) - объект, за которым наблюдают.
    Содержит список наблюдателей и уведомляет их об изменениях.
    """
    
    def __init__(self):
        self._observers = []  # Список наблюдателей
        self._state = None    # Состояние субъекта
    
    def attach(self, observer):
        """Добавляет наблюдателя."""
        if observer not in self._observers:
            self._observers.append(observer)
            print(f"[Subject] Наблюдатель {observer.name} добавлен")
    
    def detach(self, observer):
        """Удаляет наблюдателя."""
        if observer in self._observers:
            self._observers.remove(observer)
            print(f"[Subject] Наблюдатель {observer.name} удален")
    
    def notify(self):
        """Уведомляет всех наблюдателей об изменении состояния."""
        print(f"[Subject] Уведомляю {len(self._observers)} наблюдателей...")
        for observer in self._observers:
            observer.update(self)
    
    @property
    def state(self):
        """Геттер для состояния."""
        return self._state
    
    @state.setter
    def state(self, value):
        """Сеттер для состояния. При изменении уведомляет наблюдателей."""
        if self._state != value:
            print(f"[Subject] Состояние изменяется: {self._state} -> {value}")
            self._state = value
            self.notify()  # Автоматическое уведомление при изменении

class Observer:
    """
    Абстрактный наблюдатель (Observer).
    Определяет интерфейс для объектов, которые должны уведомляться об изменениях.
    """
    
    def __init__(self, name):
        self.name = name
    
    def update(self, subject):
        """Получает уведомление об изменении субъекта."""
        raise NotImplementedError("Подклассы должны реализовать этот метод")

class ConcreteObserverA(Observer):
    """Конкретный наблюдатель типа A."""
    
    def update(self, subject):
        print(f"[ObserverA {self.name}] Получено обновление от Subject")
        print(f"[ObserverA {self.name}] Новое состояние: {subject.state}")
        # Может выполнять действия в ответ на изменение
        if subject.state == "error":
            print(f"[ObserverA {self.name}] Ошибка обнаружена! Выполняю действие...")

class ConcreteObserverB(Observer):
    """Конкретный наблюдатель типа B."""
    
    def __init__(self, name, threshold=10):
        super().__init__(name)
        self.threshold = threshold
    
    def update(self, subject):
        print(f"[ObserverB {self.name}] Получено обновление от Subject")
        
        # Проверяем значение состояния
        if isinstance(subject.state, (int, float)):
            if subject.state > self.threshold:
                print(f"[ObserverB {self.name}] Превышен порог {self.threshold}! Текущее значение: {subject.state}")
            else:
                print(f"[ObserverB {self.name}] Значение в пределах нормы: {subject.state}")

# Демонстрация работы паттерна
print("Демонстрация паттерна Наблюдатель:")
subject = Subject()

# Создаем наблюдателей
observer1 = ConcreteObserverA("Наблюдатель-1")
observer2 = ConcreteObserverA("Наблюдатель-2")
observer3 = ConcreteObserverB("Числовой-наблюдатель", threshold=5)

# Подписываем наблюдателей на субъект
subject.attach(observer1)
subject.attach(observer2)
subject.attach(observer3)

print("\nИзменяем состояние субъекта (строковое):")
subject.state = "hello"  # Автоматически уведомляет всех наблюдателей

print("\nИзменяем состояние субъекта (числовое):")
subject.state = 7  # Автоматически уведомляет всех наблюдателей

print("\nИзменяем состояние субъекта (превышение порога):")
subject.state = 15  # ObserverB среагирует на превышение порога

print("\nУдаляем одного наблюдателя и снова изменяем состояние:")
subject.detach(observer2)
subject.state = "error"  # Уведомит только оставшихся наблюдателей

print("\n=== РАСШИРЕННАЯ СИСТЕМА СОБЫТИЙ ===")

class Event:
    """Класс для представления события с данными."""
    
    def __init__(self, event_type, data=None, source=None):
        self.type = event_type      # Тип события (например, 'click', 'data_updated')
        self.data = data or {}      # Данные события
        self.source = source        # Источник события
        self.timestamp = self._get_timestamp()
    
    def _get_timestamp(self):
        import time
        return time.time()
    
    def __str__(self):
        return f"Event(type={self.type}, data={self.data}, source={self.source})"

class EventManager:
    """
    Менеджер событий - централизованная система для управления событиями и обработчиками.
    Реализует паттерн "Медиатор" вместе с "Наблюдателем".
    """
    
    def __init__(self):
        self._handlers = {}  # Словарь: тип события -> список обработчиков
    
    def subscribe(self, event_type, handler):
        """Подписывает обработчик на определенный тип события."""
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        
        if handler not in self._handlers[event_type]:
            self._handlers[event_type].append(handler)
            print(f"[EventManager] Обработчик подписан на события типа '{event_type}'")
    
    def unsubscribe(self, event_type, handler):
        """Отписывает обработчик от определенного типа события."""
        if event_type in self._handlers and handler in self._handlers[event_type]:
            self._handlers[event_type].remove(handler)
            print(f"[EventManager] Обработчик отписан от событий типа '{event_type}'")
    
    def publish(self, event):
        """Публикует событие - уведомляет всех подписанных обработчиков."""
        event_type = event.type
        print(f"\n[EventManager] Публикую событие: {event}")
        
        if event_type in self._handlers:
            for handler in self._handlers[event_type]:
                try:
                    handler(event)
                except Exception as e:
                    print(f"[EventManager] Ошибка в обработчике {handler}: {e}")
        else:
            print(f"[EventManager] Нет обработчиков для события типа '{event_type}'")
    
    def get_subscription_count(self, event_type=None):
        """Возвращает количество подписок."""
        if event_type:
            return len(self._handlers.get(event_type, []))
        else:
            return sum(len(handlers) for handlers in self._handlers.values())

# Примеры обработчиков событий
def log_handler(event):
    """Обработчик для логирования всех событий."""
    import datetime
    dt = datetime.datetime.fromtimestamp(event.timestamp)
    print(f"[LogHandler] [{dt.strftime('%H:%M:%S')}] Событие: {event.type}, Данные: {event.data}")

def email_notification_handler(event):
    """Обработчик для отправки email-уведомлений."""
    if event.type == "user_registered":
        user_email = event.data.get("email")
        print(f"[EmailHandler] Отправляем приветственное письмо на {user_email}")
        # Здесь был бы реальный код отправки email
    
    elif event.type == "order_placed":
        order_id = event.data.get("order_id")
        print(f"[EmailHandler] Отправляем подтверждение заказа #{order_id}")

def analytics_handler(event):
    """Обработчик для аналитики."""
    print(f"[AnalyticsHandler] Отслеживаю событие '{event.type}' для аналитики")
    
    # В реальной системе здесь было бы сохранение в базу данных аналитики
    if event.type == "button_click":
        print(f"[AnalyticsHandler] Кнопка '{event.data.get('button_id')}' нажата")
    elif event.type == "page_view":
        print(f"[AnalyticsHandler] Просмотр страницы '{event.data.get('page')}'")

# Демонстрация системы событий
print("\nДемонстрация системы событий:")
event_manager = EventManager()

# Подписываем обработчики на разные типы событий
event_manager.subscribe("*", log_handler)  # Обрабатывает все события
event_manager.subscribe("user_registered", email_notification_handler)
event_manager.subscribe("order_placed", email_notification_handler)
event_manager.subscribe("button_click", analytics_handler)
event_manager.subscribe("page_view", analytics_handler)

print(f"\nВсего подписок: {event_manager.get_subscription_count()}")
print(f"Подписок на 'user_registered': {event_manager.get_subscription_count('user_registered')}")

# Публикуем события
print("\nПубликация событий:")
event_manager.publish(Event("user_registered", {"email": "user@example.com", "name": "Иван"}))
event_manager.publish(Event("button_click", {"button_id": "login_button", "page": "/login"}))
event_manager.publish(Event("order_placed", {"order_id": 12345, "amount": 1000}))
event_manager.publish(Event("page_view", {"page": "/products", "user_id": 42}))
event_manager.publish(Event("unknown_event", {"test": "data"}))  # Нет подписчиков

print("\n=== ПРИМЕНЕНИЕ В GUI (упрощенный пример) ===")

class UIButton:
    """Кнопка пользовательского интерфейса, генерирующая события."""
    
    def __init__(self, text, button_id):
        self.text = text
        self.id = button_id
        self._click_handlers = []  # Список обработчиков клика
    
    def on_click(self, handler):
        """Добавляет обработчик события клика."""
        self._click_handlers.append(handler)
    
    def click(self):
        """Имитирует клик по кнопке."""
        print(f"\n[UIButton '{self.id}'] Кнопка '{self.text}' нажата")
        
        # Создаем событие клика
        event = Event("button_click", {
            "button_id": self.id,
            "button_text": self.text,
            "timestamp": self._get_timestamp()
        })
        
        # Вызываем все обработчики
        for handler in self._click_handlers:
            try:
                handler(event)
            except Exception as e:
                print(f"Ошибка в обработчике кнопки: {e}")
    
    def _get_timestamp(self):
        import time
        return time.time()

class UserInterface:
    """Пользовательский интерфейс с обработчиками событий."""
    
    def __init__(self):
        self.buttons = {}
        self.message = ""
    
    def create_button(self, text, button_id):
        button = UIButton(text, button_id)
        self.buttons[button_id] = button
        
        # Подписываем обработчики на кнопку
        button.on_click(self._on_button_click)
        button.on_click(self._update_ui)
        
        return button
    
    def _on_button_click(self, event):
        """Обработчик клика по кнопке."""
        button_id = event.data["button_id"]
        print(f"[UI] Кнопка '{button_id}' была нажата")
        
        # Бизнес-логика в ответ на клик
        if button_id == "login":
            self.message = "Выполняется вход в систему..."
        elif button_id == "logout":
            self.message = "Выход из системы..."
        elif button_id == "save":
            self.message = "Данные сохранены!"
    
    def _update_ui(self, event):
        """Обновление интерфейса после события."""
        print(f"[UI] Обновляю интерфейс. Сообщение: {self.message}")

print("\nСоздаем пользовательский интерфейс с кнопками:")
ui = UserInterface()

# Создаем кнопки
login_button = ui.create_button("Войти", "login")
logout_button = ui.create_button("Выйти", "logout")
save_button = ui.create_button("Сохранить", "save")

# Имитируем клики по кнопкам
login_button.click()
logout_button.click()
save_button.click()

print("\n=== ПАТТЕРН НАБЛЮДАТЕЛЬ С ПИТОНОВСКИМИ ДЕСКРИПТОРАМИ ===")

class ObservableProperty:
    """
    Дескриптор, который делает свойство наблюдаемым.
    При изменении значения свойства уведомляет наблюдателей.
    """
    
    def __init__(self, initial_value=None):
        self.value = initial_value
        self.observers = []
    
    def __get__(self, obj, objtype=None):
        return self.value
    
    def __set__(self, obj, value):
        if self.value != value:
            old_value = self.value
            self.value = value
            print(f"[ObservableProperty] Значение изменено: {old_value} -> {value}")
            self._notify_observers(obj, old_value, value)
    
    def add_observer(self, observer):
        """Добавляет наблюдателя для этого свойства."""
        self.observers.append(observer)
    
    def _notify_observers(self, obj, old_value, new_value):
        """Уведомляет всех наблюдателей об изменении."""
        for observer in self.observers:
            observer(obj, self, old_value, new_value)

class UserModel:
    """Модель пользователя с наблюдаемыми свойствами."""
    
    name = ObservableProperty("")
    email = ObservableProperty("")
    age = ObservableProperty(0)
    
    def __init__(self, name, email, age):
        self.name = name
        self.email = email
        self.age = age

def user_property_changed(user, property_desc, old_value, new_value):
    """Обработчик изменений свойств пользователя."""
    property_name = None
    for key, value in user.__class__.__dict__.items():
        if value is property_desc:
            property_name = key
            break
    
    print(f"[Observer] Свойство '{property_name}' пользователя изменено: {old_value} -> {new_value}")
    
    # Можно выполнять дополнительные действия
    if property_name == "email" and "@" in new_value:
        print(f"[Observer] Новый email пользователя валиден")

print("\nДемонстрация наблюдаемых свойств:")
user = UserModel("Иван", "ivan@example.com", 25)

# Подписываем обработчик на изменения свойств
UserModel.name.add_observer(user_property_changed)
UserModel.email.add_observer(user_property_changed)
UserModel.age.add_observer(user_property_changed)

print("Изменяем свойства пользователя:")
user.name = "Петр"
user.email = "petr@example.org"
user.age = 30`,
        "description": "Паттерн 'Наблюдатель' (Observer) создает механизм подписки для уведомления объектов об изменениях. Основные компоненты: 1) `Subject` (субъект, издатель) — содержит состояние и список наблюдателей, уведомляет их при изменениях; 2) `Observer` (наблюдатель, подписчик) — интерфейс для объектов, получающих уведомления; 3) `ConcreteObserver` — конкретные реализации наблюдателей. Паттерн позволяет слабо связать объекты: субъект ничего не знает о конкретных наблюдателях. Система событий (Event Manager) расширяет этот паттерн, позволяя подписываться на конкретные типы событий и передавать данные в событиях. Паттерн широко используется в GUI (обработка действий пользователя), системах уведомлений, реактивном программировании. В Python можно реализовать наблюдаемые свойства через дескрипторы (`ObservableProperty`), что делает код более декларативным. Для сложных систем стоит рассмотреть готовые решения (PyPubSub, blinker) или асинхронные реализации с asyncio."
    },
    {
        "id": 36,
        "title": "Хендлеры в веб-фреймворках и middleware",
        "tag": "Шаблоны",
        "shortDesc": "Реализация middleware и обработчиков запросов на примере упрощенного веб-фреймворка",
        "code": `# Middleware (промежуточное ПО) и хендлеры - ключевые концепции веб-фреймворков.
# Middleware обрабатывает запросы и ответы в цепочке, подобно паттерну "Цепочка обязанностей".

print("=== УПРОЩЕННЫЙ ВЕБ-ФРЕЙМВОРК С MIDDLEWARE И ХЕНДЛЕРАМИ ===")

class HttpRequest:
    """Класс, представляющий HTTP-запрос."""
    
    def __init__(self, method, path, headers=None, body=None, query_params=None):
        self.method = method  # GET, POST, etc.
        self.path = path      # /users/123
        self.headers = headers or {}
        self.body = body or {}
        self.query_params = query_params or {}
        self.user = None  # Будет установлено аутентификационным middleware
    
    def __str__(self):
        return f"{self.method} {self.path}"

class HttpResponse:
    """Класс, представляющий HTTP-ответ."""
    
    def __init__(self, body="", status_code=200, headers=None):
        self.body = body
        self.status_code = status_code
        self.headers = headers or {"Content-Type": "text/html; charset=utf-8"}
    
    def __str__(self):
        return f"HTTP {self.status_code}"

class Middleware:
    """
    Базовый класс для middleware.
    Middleware обрабатывает запросы и/или ответы в цепочке.
    """
    
    def __init__(self):
        self.next_handler = None
    
    def set_next(self, handler):
        self.next_handler = handler
        return handler
    
    def process_request(self, request):
        """
        Обрабатывает входящий запрос.
        Может модифицировать запрос или вернуть ответ напрямую.
        """
        if self.next_handler:
            return self.next_handler.process_request(request)
        return None  # Если нет следующего обработчика
    
    def process_response(self, request, response):
        """
        Обрабатывает исходящий ответ.
        Может модифицировать ответ.
        """
        if self.next_handler:
            return self.next_handler.process_response(request, response)
        return response

class RequestHandler:
    """
    Базовый класс для обработчиков запросов.
    Обрабатывает конкретные маршруты и HTTP-методы.
    """
    
    def handle(self, request):
        """Обрабатывает запрос и возвращает ответ."""
        raise NotImplementedError("Подклассы должны реализовать этот метод")

print("\n=== РЕАЛИЗАЦИЯ MIDDLEWARE ===")

class LoggingMiddleware(Middleware):
    """Middleware для логирования запросов и ответов."""
    
    def process_request(self, request):
        print(f"[LoggingMiddleware] Входящий запрос: {request.method} {request.path}")
        print(f"[LoggingMiddleware] Заголовки: {request.headers}")
        
        # Передаем запрос следующему middleware/handler
        response = super().process_request(request)
        
        return response
    
    def process_response(self, request, response):
        print(f"[LoggingMiddleware] Исходящий ответ: {response.status_code}")
        
        # Передаем ответ следующему middleware
        return super().process_response(request, response)

class AuthenticationMiddleware(Middleware):
    """Middleware для аутентификации пользователей."""
    
    # В реальной системе здесь была бы проверка токена или сессии
    VALID_TOKENS = {
        "user123": {"id": 1, "name": "Иван", "role": "user"},
        "admin456": {"id": 2, "name": "Админ", "role": "admin"}
    }
    
    def process_request(self, request):
        # Проверяем заголовок Authorization
        auth_header = request.headers.get("Authorization", "")
        
        if auth_header.startswith("Bearer "):
            token = auth_header[7:]  # Убираем "Bearer "
            
            if token in self.VALID_TOKENS:
                request.user = self.VALID_TOKENS[token]
                print(f"[AuthenticationMiddleware] Пользователь аутентифицирован: {request.user['name']}")
            else:
                print(f"[AuthenticationMiddleware] Неверный токен")
                # Если токен неверный, сразу возвращаем ошибку
                return HttpResponse("Не авторизован", status_code=401)
        else:
            # Нет заголовка Authorization - анонимный доступ
            request.user = {"id": None, "name": "Гость", "role": "guest"}
            print(f"[AuthenticationMiddleware] Анонимный доступ")
        
        return super().process_request(request)

class CorsMiddleware(Middleware):
    """Middleware для добавления CORS-заголовков."""
    
    def process_response(self, request, response):
        # Добавляем CORS-заголовки
        response.headers["Access-Control-Allow-Origin"] = "*"
        response.headers["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS"
        response.headers["Access-Control-Allow-Headers"] = "Content-Type, Authorization"
        
        return super().process_response(request, response)

class ErrorHandlingMiddleware(Middleware):
    """Middleware для обработки ошибок."""
    
    def process_request(self, request):
        try:
            return super().process_request(request)
        except Exception as e:
            print(f"[ErrorHandlingMiddleware] Ошибка при обработке запроса: {e}")
            # Возвращаем красивую страницу ошибки
            error_html = f"""
            <html>
                <head><title>Ошибка 500</title></head>
                <body>
                    <h1>Внутренняя ошибка сервера</h1>
                    <p>{str(e)}</p>
                </body>
            </html>
            """
            return HttpResponse(error_html, status_code=500)
    
    def process_response(self, request, response):
        # Можно логировать ошибки 4xx и 5xx
        if response.status_code >= 400:
            print(f"[ErrorHandlingMiddleware] Ошибка {response.status_code} для {request}")
        
        return super().process_response(request, response)

print("\n=== РЕАЛИЗАЦИЯ ОБРАБОТЧИКОВ ЗАПРОСОВ ===")

class HomeHandler(RequestHandler):
    """Обработчик для главной страницы."""
    
    def handle(self, request):
        if request.method == "GET" and request.path == "/":
            html = """
            <html>
                <head><title>Главная</title></head>
                <body>
                    <h1>Добро пожаловать!</h1>
                    <p>Это главная страница.</p>
                </body>
            </html>
            """
            return HttpResponse(html)
        
        # Если путь или метод не подходят - возвращаем None
        # Это сигнал, что нужно попробовать следующий обработчик
        return None

class UserHandler(RequestHandler):
    """Обработчик для работы с пользователями."""
    
    # Имитация базы данных пользователей
    USERS = {
        1: {"id": 1, "name": "Иван", "email": "ivan@example.com"},
        2: {"id": 2, "name": "Мария", "email": "maria@example.com"},
        3: {"id": 3, "name": "Петр", "email": "petr@example.com"}
    }
    
    def handle(self, request):
        # GET /users - список всех пользователей
        if request.method == "GET" and request.path == "/users":
            user_list = "<ul>"
            for user in self.USERS.values():
                user_list += f"<li>{user['name']} ({user['email']})</li>"
            user_list += "</ul>"
            
            html = f"""
            <html>
                <head><title>Пользователи</title></head>
                <body>
                    <h1>Список пользователей</h1>
                    {user_list}
                </body>
            </html>
            """
            return HttpResponse(html)
        
        # GET /users/{id} - информация о конкретном пользователе
        elif request.method == "GET" and request.path.startswith("/users/"):
            try:
                user_id = int(request.path.split("/")[-1])
                user = self.USERS.get(user_id)
                
                if user:
                    html = f"""
                    <html>
                        <head><title>Пользователь {user['name']}</title></head>
                        <body>
                            <h1>{user['name']}</h1>
                            <p>Email: {user['email']}</p>
                        </body>
                    </html>
                    """
                    return HttpResponse(html)
                else:
                    return HttpResponse("Пользователь не найден", status_code=404)
            except ValueError:
                return HttpResponse("Неверный ID пользователя", status_code=400)
        
        # POST /users - создание нового пользователя
        elif request.method == "POST" and request.path == "/users":
            # В реальной системе здесь была бы валидация и сохранение в БД
            name = request.body.get("name", "Неизвестно")
            email = request.body.get("email", "нет@email.com")
            
            new_id = max(self.USERS.keys()) + 1
            self.USERS[new_id] = {"id": new_id, "name": name, "email": email}
            
            html = f"""
            <html>
                <head><title>Пользователь создан</title></head>
                <body>
                    <h1>Пользователь создан!</h1>
                    <p>ID: {new_id}</p>
                    <p>Имя: {name}</p>
                    <p>Email: {email}</p>
                </body>
            </html>
            """
            return HttpResponse(html, status_code=201)
        
        return None

class AdminHandler(RequestHandler):
    """Обработчик для административных функций (требует аутентификации)."""
    
    def handle(self, request):
        # Проверяем, что пользователь аутентифицирован и имеет роль admin
        if not request.user:
            return HttpResponse("Требуется аутентификация", status_code=401)
        
        if request.user.get("role") != "admin":
            return HttpResponse("Доступ запрещен", status_code=403)
        
        # GET /admin - админ-панель
        if request.method == "GET" and request.path == "/admin":
            html = f"""
            <html>
                <head><title>Админ-панель</title></head>
                <body>
                    <h1>Админ-панель</h1>
                    <p>Добро пожаловать, {request.user['name']}!</p>
                    <p>Вы вошли как администратор.</p>
                </body>
            </html>
            """
            return HttpResponse(html)
        
        return None

class NotFoundHandler(RequestHandler):
    """Обработчик для несуществующих маршрутов (404)."""
    
    def handle(self, request):
        html = f"""
        <html>
            <head><title>Страница не найдена</title></head>
            <body>
                <h1>404 - Страница не найдена</h1>
                <p>Запрашиваемая страница {request.path} не существует.</p>
            </body>
        </html>
        """
        return HttpResponse(html, status_code=404)

print("\n=== ДИСПЕТЧЕР ЗАПРОСОВ ===")

class RequestDispatcher(Middleware):
    """
    Диспетчер запросов - специальный middleware, который выбирает
    подходящий обработчик для запроса.
    """
    
    def __init__(self, handlers):
        super().__init__()
        self.handlers = handlers  # Список обработчиков для попытки
    
    def process_request(self, request):
        """Пытается найти подходящий обработчик для запроса."""
        print(f"[RequestDispatcher] Ищу обработчик для {request.method} {request.path}")
        
        # Пробуем каждый обработчик по порядку
        for handler in self.handlers:
            response = handler.handle(request)
            if response is not None:
                print(f"[RequestDispatcher] Найден обработчик: {handler.__class__.__name__}")
                return response
        
        # Если ни один обработчик не подошел
        print(f"[RequestDispatcher] Обработчик не найден, возвращаем 404")
        not_found_handler = NotFoundHandler()
        return not_found_handler.handle(request)

print("\n=== СОЗДАНИЕ И ТЕСТИРОВАНИЕ ВЕБ-СЕРВЕРА ===")

class WebFramework:
    """Упрощенный веб-фреймворк."""
    
    def __init__(self):
        # Создаем цепочку middleware
        self.middleware_chain = self._create_middleware_chain()
        
        # Создаем диспетчер с обработчиками
        handlers = [
            HomeHandler(),
            UserHandler(),
            AdminHandler()
        ]
        self.dispatcher = RequestDispatcher(handlers)
        
        # Добавляем диспетчер в конец цепочки middleware
        self._add_dispatcher_to_chain()
    
    def _create_middleware_chain(self):
        """Создает цепочку middleware."""
        logging = LoggingMiddleware()
        error_handling = ErrorHandlingMiddleware()
        auth = AuthenticationMiddleware()
        cors = CorsMiddleware()
        
        # Собираем цепочку: логирование -> обработка ошибок -> аутентификация -> CORS
        logging.set_next(error_handling).set_next(auth).set_next(cors)
        
        return logging
    
    def _add_dispatcher_to_chain(self):
        """Добавляет диспетчер в конец цепочки middleware."""
        # Находим последний middleware в цепочке
        current = self.middleware_chain
        while current.next_handler:
            current = current.next_handler
        
        # Добавляем диспетчер после последнего middleware
        current.set_next(self.dispatcher)
    
    def handle_request(self, request):
        """Обрабатывает HTTP-запрос через цепочку middleware и диспетчер."""
        print(f"\n{'='*60}")
        print(f"ОБРАБОТКА ЗАПРОСА: {request}")
        
        # Запускаем обработку запроса через цепочку middleware
        response = self.middleware_chain.process_request(request)
        
        # Если middleware вернул ответ (например, ошибка аутентификации)
        if response:
            # Пропускаем ответ обратно через цепочку middleware
            response = self.middleware_chain.process_response(request, response)
            return response
        
        # Если middleware не вернул ответ, значит его вернул диспетчер
        # (но это не должно случиться, т.к. диспетчер всегда возвращает ответ)
        return HttpResponse("Внутренняя ошибка сервера", status_code=500)

# Создаем экземпляр фреймворка
app = WebFramework()

# Тестовые запросы
test_requests = [
    # Анонимный доступ к главной странице
    HttpRequest("GET", "/", {"User-Agent": "TestBrowser"}),
    
    # Запрос с валидным токеном
    HttpRequest("GET", "/admin", {
        "User-Agent": "TestBrowser",
        "Authorization": "Bearer admin456"
    }),
    
    # Запрос с невалидным токеном
    HttpRequest("GET", "/admin", {
        "User-Agent": "TestBrowser",
        "Authorization": "Bearer wrongtoken"
    }),
    
    # Анонимный доступ к админке (без токена)
    HttpRequest("GET", "/admin", {"User-Agent": "TestBrowser"}),
    
    # Получение списка пользователей
    HttpRequest("GET", "/users", {"User-Agent": "TestBrowser"}),
    
    # Получение конкретного пользователя
    HttpRequest("GET", "/users/2", {"User-Agent": "TestBrowser"}),
    
    # Создание нового пользователя
    HttpRequest("POST", "/users", 
                {"User-Agent": "TestBrowser", "Content-Type": "application/json"},
                {"name": "Алексей", "email": "alex@example.com"}),
    
    # Несуществующий маршрут
    HttpRequest("GET", "/unknown", {"User-Agent": "TestBrowser"}),
    
    # Запрос, который вызовет ошибку (неправильный ID пользователя)
    HttpRequest("GET", "/users/not_a_number", {"User-Agent": "TestBrowser"}),
]

# Обрабатываем тестовые запросы
for i, req in enumerate(test_requests, 1):
    print(f"\nТЕСТ {i}:")
    response = app.handle_request(req)
    print(f"Ответ: {response.status_code}, Тело: {response.body[:100]}...")

print("\n=== ДОБАВЛЕНИЕ НОВОГО MIDDLEWARE ДИНАМИЧЕСКИ ===")

class RateLimitingMiddleware(Middleware):
    """Middleware для ограничения частоты запросов."""
    
    def __init__(self, max_requests_per_minute=10):
        super().__init__()
        self.max_requests = max_requests_per_minute
        self.request_counts = {}  # IP -> количество запросов
        self.reset_times = {}     # IP -> время сброса счетчика
    
    def process_request(self, request):
        # В реальной системе IP брался бы из request
        client_ip = "127.0.0.1"  # Заглушка
        
        import time
        current_time = time.time()
        
        # Сбрасываем счетчик, если прошла минута
        if client_ip in self.reset_times and current_time - self.reset_times[client_ip] > 60:
            self.request_counts[client_ip] = 0
            self.reset_times[client_ip] = current_time
        
        # Инициализируем счетчик, если нужно
        if client_ip not in self.request_counts:
            self.request_counts[client_ip] = 0
            self.reset_times[client_ip] = current_time
        
        # Увеличиваем счетчик
        self.request_counts[client_ip] += 1
        
        # Проверяем лимит
        if self.request_counts[client_ip] > self.max_requests:
            print(f"[RateLimitingMiddleware] Превышен лимит запросов для {client_ip}")
            return HttpResponse("Слишком много запросов. Попробуйте позже.", status_code=429)
        
        print(f"[RateLimitingMiddleware] Запрос {self.request_counts[client_ip]}/{self.max_requests} от {client_ip}")
        return super().process_request(request)

# Динамически добавляем rate limiting в цепочку middleware
print("\nДобавляем RateLimitingMiddleware в цепочку:")
rate_limiter = RateLimitingMiddleware(max_requests_per_minute=3)

# Вставляем rate limiter после логирования в существующую цепочку
rate_limiter.set_next(app.middleware_chain.next_handler)
app.middleware_chain.set_next(rate_limiter)

# Тестируем rate limiting
print("\nТестируем rate limiting (лимит 3 запроса в минуту):")
for i in range(5):
    req = HttpRequest("GET", f"/test-rate-limit-{i}", {"User-Agent": "TestBrowser"})
    response = app.handle_request(req)
    print(f"Запрос {i+1}: {response.status_code}")`,
        "description": "Веб-фреймворки используют паттерны 'Цепочка обязанностей' и 'Middleware' для обработки HTTP-запросов. Middleware — это компоненты, которые обрабатывают запросы и ответы в определенном порядке. Каждый middleware может: 1) модифицировать запрос (`process_request`), 2) модифицировать ответ (`process_response`), 3) прервать обработку (например, вернуть ошибку аутентификации). Основные типы middleware: логирование, аутентификация, CORS, обработка ошибок, ограничение запросов. Диспетчер запросов (Router) — специальный middleware, который выбирает подходящий обработчик (Handler) на основе пути и метода запроса. Обработчики реализуют бизнес-логику для конкретных маршрутов. Такая архитектура обеспечивает гибкость: middleware можно добавлять, удалять или менять местами без изменения обработчиков. В реальных фреймворках (Django, Flask, FastAPI) эти концепции реализованы более сложно, но принципы остаются теми же."
    },
    {
        "id": 37,
        "title": "Кодировки текста в Python: Unicode, str, bytes",
        "tag": "Текста",
        "shortDesc": "Работа с кодировками текста, преобразование между str и bytes, решение проблем с кодировками",
        "code": `# Понимание кодировок текста критически важно для работы с текстовыми данными в Python.
# Python 3 использует Unicode для строк (str), что упрощает работу с текстом на разных языках.

print("=== ОСНОВНЫЕ ТИПЫ: str И bytes ===")

# str - строка Unicode (текст)
text = "Привет, мир! Hello, world! 😊"
print(f"Тип text: {type(text)}")
print(f"Длина текста (символов): {len(text)}")
print(f"Текст: {text}")

# bytes - последовательность байтов (бинарные данные)
binary_data = b"Hello, world!"  # Байтовая строка
print(f"\nТип binary_data: {type(binary_data)}")
print(f"Длина байтовой строки: {len(binary_data)}")
print(f"Байты: {binary_data}")

# Попытка создать bytes с не-ASCII символами напрямую вызывает ошибку
try:
    wrong_bytes = b"Привет"  # Ошибка! Можно только ASCII
except SyntaxError:
    print("\nОшибка: нельзя создать bytes с не-ASCII символами напрямую")

print("\n=== КОДИРОВКА И ДЕКОДИРОВКА ===")
# Кодирование (encoding): str -> bytes
# Декодирование (decoding): bytes -> str

# Кодируем строку в байты с указанием кодировки
text_to_encode = "Привет, мир! Café 🎉"
encoded_utf8 = text_to_encode.encode("utf-8")      # UTF-8 (самая распространенная)
encoded_cp1251 = text_to_encode.encode("cp1251")   # Windows-1251 (кириллица)
encoded_koi8r = text_to_encode.encode("koi8-r")    # KOI8-R (кириллица)

print(f"Исходный текст: {text_to_encode}")
print(f"UTF-8 байты: {encoded_utf8}")
print(f"Длина в UTF-8: {len(encoded_utf8)} байт")
print(f"CP1251 байты: {encoded_cp1251}")
print(f"KOI8-R байты: {encoded_koi8r}")

# Декодируем байты обратно в строку
decoded_utf8 = encoded_utf8.decode("utf-8")
decoded_cp1251 = encoded_cp1251.decode("cp1251")
decoded_koi8r = encoded_koi8r.decode("koi8-r")

print(f"\nДекодировано из UTF-8: {decoded_utf8}")
print(f"Декодировано из CP1251: {decoded_cp1251}")
print(f"Декодировано из KOI8-R: {decoded_koi8r}")

print("\n=== РАБОТА С РАЗНЫМИ КОДИРОВКАМИ ===")
# Проблема: попытка декодировать байты не в той кодировке
wrong_decoding = b'\xcf\xf0\xe8\xe2\xe5\xf2'  # "Привет" в CP1251

try:
    result = wrong_decoding.decode("utf-8")  # Пробуем декодировать как UTF-8
except UnicodeDecodeError as e:
    print(f"UnicodeDecodeError: {e}")
    print("Проблема: неверная кодировка при декодировании")

# Правильное декодирование
correct_decoding = wrong_decoding.decode("cp1251")
print(f"Правильное декодирование (cp1251): {correct_decoding}")

print("\n=== АВТООПРЕДЕЛЕНИЕ КОДИРОВКИ (с помощью библиотеки chardet) ===")
# Установка: pip install chardet

try:
    import chardet
    
    # Тестовые данные в разных кодировках
    test_data_utf8 = "Привет, мир!".encode("utf-8")
    test_data_cp1251 = "Привет, мир!".encode("cp1251")
    test_data_koi8r = "Привет, мир!".encode("koi8-r")
    
    for data, name in [(test_data_utf8, "UTF-8"), 
                       (test_data_cp1251, "CP1251"), 
                       (test_data_koi8r, "KOI8-R")]:
        result = chardet.detect(data)
        print(f"\n{name} байты: {data[:10]}...")
        print(f"  Определенная кодировка: {result['encoding']}")
        print(f"  Уверенность: {result['confidence']:.2%}")
        
        if result['encoding']:
            try:
                decoded = data.decode(result['encoding'])
                print(f"  Декодированный текст: {decoded}")
            except:
                print(f"  Не удалось декодировать как {result['encoding']}")
except ImportError:
    print("Установите chardet: pip install chardet")

print("\n=== КОДИРОВКИ ПРИ РАБОТЕ С ФАЙЛАМИ ===")
# При работе с файлами всегда указывайте кодировку!

# Запись в файл с указанием кодировки
file_content = "Привет из файла! Café 🎉"

with open("test_utf8.txt", "w", encoding="utf-8") as f:
    f.write(file_content)
    print(f"Файл записан в UTF-8")

with open("test_cp1251.txt", "w", encoding="cp1251") as f:
    f.write(file_content)
    print(f"Файл записан в CP1251")

# Чтение файлов с правильной кодировкой
with open("test_utf8.txt", "r", encoding="utf-8") as f:
    content_utf8 = f.read()
    print(f"Прочитано из UTF-8 файла: {content_utf8}")

with open("test_cp1251.txt", "r", encoding="cp1251") as f:
    content_cp1251 = f.read()
    print(f"Прочитано из CP1251 файла: {content_cp1251}")

# Проблема: чтение с неправильной кодировкой
try:
    with open("test_cp1251.txt", "r", encoding="utf-8") as f:
        content = f.read()
except UnicodeDecodeError as e:
    print(f"\nОшибка при чтении CP1251 файла как UTF-8: {e}")

print("\n=== UNICODE И ЭМОЦИИ ===")
# Python 3 полностью поддерживает Unicode, включая эмодзи
emojis = "😀 😃 😄 😁 😆 😅 😂 🤣 🥲 🥹 😊 😇 🙂 🙃 😉 😌 😍 🥰 😘 😗 😙 😚 😋 😛 😝 😜 🤪 🤨 🧐 🤓 😎 🥸 🤩 🥳 😏 😒 😞 😔 😟 😕 🙁 ☹️ 😣 😖 😫 😩 🥺 😢 😭 😤 😠 😡 🤬 🤯 😳 🥵 🥶 😱 😨 😰 😥 😓 🤗 🤔 🤭 🤫 🤥 😶 😐 😑 😬 🙄 😯 😦 😧 😮 😲 🥱 😴 🤤 😪 😵 🤐 🥴 🤢 🤮 🤧 😷 🤒 🤕 🤑 🤠 😈 👿 👹 👺 🤡 💩 👻 💀 ☠️ 👽 👾 🤖 🎃 😺 😸 😹 😻 😼 😽 🙀 😿 😾"
print(f"Эмодзи в строке: {emojis[:50]}...")
print(f"Количество символов (включая пробелы): {len(emojis)}")

# Каждый эмодзи - это один символ Unicode
print(f"\nПервый эмодзи: '{emojis[0]}'")
print(f"Кодовая точка (hex): {hex(ord(emojis[0]))}")
print(f"Кодовая точка (dec): {ord(emojis[0])}")

# Использование Unicode-символов по их кодовым точкам
heart = "\u2764\uFE0F"  # ❤️
print(f"\nСердце через кодовые точки: {heart}")

# Или по названию
import unicodedata
print(f"Имя символа '😀': {unicodedata.name('😀')}")

print("\n=== НОРМАЛИЗАЦИЯ UNICODE ===")
# Unicode может представлять один символ разными способами

# Пример: буква 'é' может быть представлена как:
# 1. Один символ: 'é' (U+00E9)
# 2. Комбинация: 'e' + ' ́' (U+0065 + U+0301)

char1 = "é"  # Один символ
char2 = "e\u0301"  # Комбинация e + acute accent
print(f"char1: '{char1}', длина: {len(char1)}")
print(f"char2: '{char2}', длина: {len(char2)}")
print(f"char1 == char2: {char1 == char2}")  # False!
print(f"Визуально одинаковы: '{char1}' vs '{char2}'")

# Нормализация Unicode
normalized1 = unicodedata.normalize("NFC", char1)  # Каноническая композиция
normalized2 = unicodedata.normalize("NFC", char2)
print(f"\nПосле нормализации NFC:")
print(f"char1 нормализован: '{normalized1}', длина: {len(normalized1)}")
print(f"char2 нормализован: '{normalized2}', длина: {len(normalized2)}")
print(f"Нормализованные равны: {normalized1 == normalized2}")

print("\n=== РЕШЕНИЕ ПРОБЛЕМ С КОДИРОВКАМИ НА ПРАКТИКЕ ===")

# 1. Всегда явно указывайте кодировку при работе с файлами
# 2. Используйте UTF-8 везде, где возможно
# 3. Для обработки текста с неизвестной кодировкой используйте chardet
# 4. Для веб-страниц проверяйте заголовок Content-Type или meta-теги

# Пример обработки текста с неизвестной кодировкой
def safe_decode(data, default_encoding="utf-8", fallback_encodings=["cp1251", "koi8-r", "iso-8859-5"]):
    """Безопасное декодирование байтов в строку."""
    # Сначала пробуем указанную кодировку по умолчанию
    try:
        return data.decode(default_encoding)
    except UnicodeDecodeError:
        # Пробуем другие кодировки
        for encoding in fallback_encodings:
            try:
                return data.decode(encoding)
            except UnicodeDecodeError:
                continue
        
        # Если ничего не помогло, заменяем недекодируемые символы
        return data.decode(default_encoding, errors="replace")

# Тестируем
test_bytes = "Привет".encode("cp1251")
decoded_text = safe_decode(test_bytes)
print(f"\nБезопасное декодирование: {decoded_text}")

# Пример: замена "битых" символов
broken_bytes = b"Hello, \xff\xfe world!"
replaced = broken_bytes.decode("utf-8", errors="replace")  # Заменяет недекодируемые символы на �
ignore = broken_bytes.decode("utf-8", errors="ignore")     # Игнорирует недекодируемые символы
print(f"\nБитые байты: {broken_bytes}")
print(f"С заменой (replace): {replaced}")
print(f"С игнорированием (ignore): {ignore}")`,
        "description": "В Python 3 строки (str) представляют собой последовательности символов Unicode, что позволяет работать с текстом на любых языках и с эмодзи. Байтовые строки (bytes) представляют сырые байтовые данные. Кодирование (encode) преобразует str в bytes, декодирование (decode) преобразует bytes в str. UTF-8 — рекомендованная кодировка, которая поддерживает все символы Unicode и является обратно совместимой с ASCII. При работе с файлами всегда указывайте кодировку явно. Проблемы с кодировками возникают при несоответствии кодировки при декодировании. Библиотека chardet помогает определить кодировку неизвестных данных. Unicode допускает разные представления одного символа (например, буква 'é' может быть одним символом или комбинацией 'e' + диакритический знак), для нормализации используйте unicodedata.normalize(). Всегда обрабатывайте исключения UnicodeDecodeError при работе с текстом из ненадежных источников."
    },
    {
        "id": 38,
        "title": "Парсинг текстовых форматов: CSV, TSV, фиксированной ширины",
        "tag": "Текста",
        "shortDesc": "Обработка структурированных текстовых данных без использования специализированных библиотек",
        "code": `# Текстовые форматы данных (CSV, TSV, фиксированной ширины) часто используются для обмена данными.
# Python имеет встроенные модули для работы с ними, но иногда полезно понимать, как парсить их вручную.

print("=== ПАРСИНГ CSV (Comma-Separated Values) ===")

# CSV - данные, разделенные запятыми (или другими разделителями)
csv_data = """Имя,Возраст,Город,Зарплата
Иван Петров,30,Москва,100000
Мария Сидорова,25,Санкт-Петербург,90000
Алексей Иванов,35,Казань,120000
Ольга Смирнова,28,Екатеринбург,85000"""

print("Исходные CSV данные:")
print(csv_data)

def parse_csv(text, delimiter=",", has_header=True):
    """
    Парсит CSV-текст в список словарей или списков.
    
    Args:
        text: CSV-текст
        delimiter: разделитель (по умолчанию ',')
        has_header: есть ли заголовок
    
    Returns:
        Если has_header=True: список словарей
        Если has_header=False: список списков
    """
    lines = text.strip().split("\n")
    
    if not lines:
        return []
    
    if has_header:
        headers = lines[0].split(delimiter)
        data = []
        
        for line in lines[1:]:
            if not line.strip():  # Пропускаем пустые строки
                continue
                
            values = line.split(delimiter)
            # Создаем словарь, сопоставляя заголовки со значениями
            # Обрабатываем кавычки, если они есть
            row = {}
            for i, header in enumerate(headers):
                if i < len(values):
                    value = values[i].strip()
                    # Убираем кавычки, если они есть
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    row[header.strip()] = value
                else:
                    row[header.strip()] = ""
            data.append(row)
        
        return data
    else:
        # Без заголовка - возвращаем список списков
        data = []
        for line in lines:
            if not line.strip():
                continue
            values = line.split(delimiter)
            # Очищаем значения
            cleaned_values = [v.strip().strip('"') for v in values]
            data.append(cleaned_values)
        
        return data

print("\nПарсинг CSV с заголовком:")
csv_parsed = parse_csv(csv_data, delimiter=",", has_header=True)
for row in csv_parsed:
    print(f"  {row}")

# CSV с кавычками и запятыми внутри значений
csv_with_quotes = '''Имя,Должность,Город
"Иванов, Иван",Менеджер,"Москва, Россия"
"Петрова, Мария",Разработчик,"Санкт-Петербург, Россия"'''

print("\n\nCSV с кавычками и запятыми внутри значений:")
print(csv_with_quotes)

def parse_csv_advanced(text, delimiter=","):
    """Улучшенный парсер CSV, обрабатывающий кавычки и экранированные символы."""
    lines = text.strip().split("\n")
    
    if not lines:
        return []
    
    headers = lines[0].split(delimiter)
    data = []
    
    for line_num, line in enumerate(lines[1:], 1):
        if not line.strip():
            continue
        
        values = []
        current_value = ""
        in_quotes = False
        
        i = 0
        while i < len(line):
            char = line[i]
            
            if char == '"':
                if in_quotes and i + 1 < len(line) and line[i + 1] == '"':
                    # Двойные кавычки внутри кавычек - экранирование
                    current_value += '"'
                    i += 2
                    continue
                else:
                    in_quotes = not in_quotes
            elif char == delimiter and not in_quotes:
                # Разделитель вне кавычек - заканчиваем значение
                values.append(current_value)
                current_value = ""
            else:
                current_value += char
            
            i += 1
        
        # Добавляем последнее значение
        values.append(current_value)
        
        # Создаем словарь
        if len(values) == len(headers):
            row = {}
            for j, header in enumerate(headers):
                row[header.strip()] = values[j].strip()
            data.append(row)
        else:
            print(f"Предупреждение: строка {line_num} имеет {len(values)} значений, ожидается {len(headers)}")
    
    return data

print("\nПарсинг CSV с кавычками:")
parsed_advanced = parse_csv_advanced(csv_with_quotes)
for row in parsed_advanced:
    print(f"  {row}")

print("\n=== ПАРСИНГ TSV (Tab-Separated Values) ===")

# TSV - данные, разделенные табуляцией
tsv_data = """Имя\tВозраст\tГород\tЗарплата
Иван Петров\t30\tМосква\t100000
Мария Сидорова\t25\tСанкт-Петербург\t90000
Алексей Иванов\t35\tКазань\t120000
Ольга Смирнова\t28\tЕкатеринбург\t85000"""

print("Исходные TSV данные:")
print(tsv_data.replace('\t', '|'))  # Заменяем табуляцию для наглядности

# Используем ту же функцию parse_csv, но с разделителем табуляции
tsv_parsed = parse_csv(tsv_data, delimiter="\t", has_header=True)
print("\nПарсинг TSV:")
for row in tsv_parsed:
    print(f"  {row}")

print("\n=== ПАРСИНГ ФАЙЛОВ ФИКСИРОВАННОЙ ШИРИНЫ ===")

# Формат фиксированной ширины: каждое поле занимает определенное количество символов
# Пример: первые 20 символов - имя, следующие 5 - возраст, следующие 15 - город
fixed_width_data = """Иван Петров       30   Москва          
Мария Сидорова    25   Санкт-Петербург
Алексей Иванов    35   Казань          
Ольга Смирнова    28   Екатеринбург    
Дмитрий Кузнецов  42   Новосибирск     """

print("Данные фиксированной ширины:")
print(fixed_width_data)

def parse_fixed_width(text, column_widths, headers=None):
    """
    Парсит текст фиксированной ширины.
    
    Args:
        text: текст для парсинга
        column_widths: список ширин колонок (например, [20, 5, 15])
        headers: список заголовков (опционально)
    
    Returns:
        Если headers предоставлен: список словарей
        Иначе: список списков
    """
    lines = text.strip().split("\n")
    data = []
    
    for line in lines:
        if not line.strip():
            continue
        
        # Разбиваем строку на колонки по фиксированной ширине
        values = []
        start = 0
        
        for width in column_widths:
            # Берем подстроку нужной ширины
            if start < len(line):
                value = line[start:start + width].strip()
            else:
                value = ""
            
            values.append(value)
            start += width
        
        # Добавляем в данные
        if headers and len(values) == len(headers):
            # Создаем словарь
            row = {}
            for i, header in enumerate(headers):
                row[header] = values[i]
            data.append(row)
        else:
            # Добавляем как список
            data.append(values)
    
    return data

# Определяем ширины колонок: имя (20 символов), возраст (5), город (15)
column_widths = [20, 5, 15]
headers = ["Имя", "Возраст", "Город"]

print("\nПарсинг данных фиксированной ширины:")
fixed_parsed = parse_fixed_width(fixed_width_data, column_widths, headers)
for row in fixed_parsed:
    print(f"  {row}")

print("\n=== ОБРАБОТКА СЛОЖНЫХ СЛУЧАЕВ ===")

# Пример с пропущенными значениями и разными форматами
complex_csv = """ID,Имя,Возраст,Город,Баланс
1,Иван,30,Москва,1000.50
2,Мария,,Санкт-Петербург,750.00
3,,35,Казань,1250.75
4,Ольга,28,,500.25
5,Алексей,не указан,Екатеринбург,0"""

print("Сложный CSV с пропущенными значениями:")
print(complex_csv)

def parse_csv_with_types(text, delimiter=",", has_header=True):
    """Парсит CSV с попыткой определения типов данных."""
    lines = text.strip().split("\n")
    
    if not lines:
        return []
    
    if has_header:
        headers = lines[0].split(delimiter)
        data = []
        
        for line in lines[1:]:
            if not line.strip():
                continue
                
            values = line.split(delimiter)
            row = {}
            
            for i, header in enumerate(headers):
                header_clean = header.strip()
                
                if i < len(values):
                    value = values[i].strip()
                    
                    # Пытаемся определить тип
                    if value == "":
                        # Пустое значение
                        typed_value = None
                    elif value.isdigit():
                        # Целое число
                        typed_value = int(value)
                    elif value.replace('.', '', 1).isdigit() and value.count('.') == 1:
                        # Дробное число
                        typed_value = float(value)
                    elif value.lower() in ('да', 'нет', 'true', 'false', 'yes', 'no'):
                        # Логическое значение
                        typed_value = value.lower() in ('да', 'true', 'yes')
                    else:
                        # Строка
                        typed_value = value
                    
                    row[header_clean] = typed_value
                else:
                    row[header_clean] = None
            
            data.append(row)
        
        return data
    else:
        return parse_csv(text, delimiter, has_header=False)

print("\nПарсинг CSV с определением типов:")
typed_data = parse_csv_with_types(complex_csv)
for row in typed_data:
    print(f"  {row}")

print("\n=== ЭКСПОРТ ДАННЫХ В ТЕКСТОВЫЕ ФОРМАТЫ ===")

def export_to_csv(data, headers=None, delimiter=","):
    """Экспортирует данные в CSV формат."""
    if not data:
        return ""
    
    lines = []
    
    # Добавляем заголовок
    if headers:
        lines.append(delimiter.join(headers))
    elif isinstance(data[0], dict):
        # Берем заголовки из ключей первого словаря
        headers = list(data[0].keys())
        lines.append(delimiter.join(headers))
    
    # Добавляем данные
    for row in data:
        if isinstance(row, dict):
            # Словарь
            values = []
            for header in headers:
                value = row.get(header, "")
                # Экранируем значения, если нужно
                if delimiter in str(value) or '"' in str(value):
                    value = f'"{str(value).replace(\'"\', \'""\')}"'
                values.append(str(value))
            lines.append(delimiter.join(values))
        elif isinstance(row, (list, tuple)):
            # Список или кортеж
            values = []
            for value in row:
                # Экранируем значения, если нужно
                if delimiter in str(value) or '"' in str(value):
                    value = f'"{str(value).replace(\'"\', \'""\')}"'
                values.append(str(value))
            lines.append(delimiter.join(values))
    
    return "\n".join(lines)

def export_to_fixed_width(data, column_widths, headers=None):
    """Экспортирует данные в формат фиксированной ширины."""
    if not data:
        return ""
    
    lines = []
    
    # Добавляем заголовок
    if headers:
        header_line = ""
        for i, header in enumerate(headers):
            width = column_widths[i] if i < len(column_widths) else 10
            header_line += f"{header:<{width}}"
        lines.append(header_line)
    
    # Добавляем данные
    for row in data:
        if isinstance(row, dict) and headers:
            # Словарь с заголовками
            line = ""
            for i, header in enumerate(headers):
                width = column_widths[i] if i < len(column_widths) else 10
                value = str(row.get(header, ""))
                line += f"{value:<{width}}"
        elif isinstance(row, (list, tuple)):
            # Список или кортеж
            line = ""
            for i, value in enumerate(row):
                width = column_widths[i] if i < len(column_widths) else 10
                line += f"{str(value):<{width}}"
        else:
            continue
        
        lines.append(line)
    
    return "\n".join(lines)

# Пример экспорта
sample_data = [
    {"Имя": "Иван", "Возраст": 30, "Город": "Москва"},
    {"Имя": "Мария", "Возраст": 25, "Город": "Санкт-Петербург"},
    {"Имя": "Алексей, Петрович", "Возраст": 35, "Город": "Казань"}
]

print("Экспорт в CSV:")
csv_exported = export_to_csv(sample_data, ["Имя", "Возраст", "Город"])
print(csv_exported)

print("\nЭкспорт в фиксированную ширину:")
fixed_exported = export_to_fixed_width(sample_data, [20, 10, 15], ["Имя", "Возраст", "Город"])
print(fixed_exported)

print("\n=== СРАВНЕНИЕ С ВСТРОЕННЫМИ СРЕДСТВАМИ PYTHON ===")
# Python имеет встроенные модули для работы с CSV

import csv

print("Использование встроенного модуля csv:")

# Чтение CSV
csv_content = """Имя,Возраст,Город
Иван,30,Москва
Мария,25,Санкт-Петербург"""

print("Чтение CSV через csv.reader:")
reader = csv.reader(csv_content.splitlines())
for row in reader:
    print(f"  {row}")

print("\nЧтение CSV через csv.DictReader:")
dict_reader = csv.DictReader(csv_content.splitlines())
for row in dict_reader:
    print(f"  {row}")

# Запись CSV
print("\nЗапись CSV через csv.writer:")
output = []
writer = csv.writer(output)
writer.writerow(["Имя", "Возраст", "Город"])
writer.writerow(["Иван", 30, "Москва"])
writer.writerow(["Мария", 25, "Санкт-Петербург"])
print("\n".join([",".join(map(str, row)) for row in output]))`,
        "description": "CSV (Comma-Separated Values), TSV (Tab-Separated Values) и формат фиксированной ширины — распространенные текстовые форматы для структурированных данных. CSV использует запятые (или другие символы) как разделители, TSV — табуляцию, а формат фиксированной ширины задает точное количество символов для каждого поля. При парсинге CSV важно обрабатывать кавычки и экранированные символы. Парсинг вручную помогает понять внутреннюю работу, но для производственного кода рекомендуется использовать встроенный модуль `csv`, который корректно обрабатывает все сложные случаи. При работе с форматом фиксированной ширины необходимо точно знать ширину каждой колонки. Всегда проверяйте данные на целостность и обрабатывайте пропущенные значения. При экспорте данных в текстовые форматы правильно экранируйте специальные символы и указывайте кодировку."
    },
    {
        "id": 39,
        "title": "Очистка и нормализация текста: подготовка к анализу",
        "tag": "Текста",
        "shortDesc": "Техники предобработки текста: удаление лишних пробелов, знаков препинания, стоп-слов, лемматизация",
        "code": `# Предобработка текста — важный этап перед анализом (NLP, машинное обучение, поиск).
# Включает очистку, нормализацию и преобразование текста.

print("=== БАЗОВАЯ ОЧИСТКА ТЕКСТА ===")

sample_text = """
  Привет,   мир! Это  пример   текста  для обработки.
  Текст содержит: знаки препинания, лишние пробелы и ДРУГИЕ "проблемы".
  Также числа 123 и спец. символы #@!%... 
  И ещё МНОГО разных РеГИСТРов букв.
"""

print("Исходный текст:")
print(sample_text)

def clean_text_basic(text):
    """Базовая очистка текста."""
    # Удаляем лишние пробелы (включая табуляции и переносы строк)
    text = " ".join(text.split())
    
    # Приводим к нижнему регистру
    text = text.lower()
    
    # Удаляем цифры
    import re
    text = re.sub(r'\d+', '', text)
    
    # Удаляем некоторые спецсимволы (оставляем буквы, пробелы и основные знаки препинания)
    text = re.sub(r'[^\w\s.,!?-]', '', text)
    
    # Убираем множественные точки и другие знаки препинания
    text = re.sub(r'[.,!?-]{2,}', '', text)
    
    return text.strip()

cleaned = clean_text_basic(sample_text)
print("\nПосле базовой очистки:")
print(cleaned)

print("\n=== УДАЛЕНИЕ ЗНАКОВ ПРЕПИНАНИЯ ===")

def remove_punctuation(text, keep_some=True):
    """Удаляет знаки препинания из текста."""
    import string
    
    if keep_some:
        # Оставляем некоторые знаки препинания для смысла
        punctuation_to_remove = string.punctuation.replace('.', '').replace('?', '').replace('!', '')
    else:
        punctuation_to_remove = string.punctuation
    
    # Создаем таблицу перевода для str.translate
    translator = str.maketrans('', '', punctuation_to_remove)
    text = text.translate(translator)
    
    return text

text_with_punct = "Привет, мир! Это - пример. А это? Вот так!"
print(f"Исходный текст с пунктуацией: {text_with_punct}")
print(f"Без пунктуации: {remove_punctuation(text_with_punct, keep_some=False)}")
print(f"С сохранением .?!: {remove_punctuation(text_with_punct, keep_some=True)}")

print("\n=== УДАЛЕНИЕ СТОП-СЛОВ ===")
# Стоп-слова — частые слова, не несущие смысловой нагрузки (предлоги, союзы и т.д.)

# Базовый список стоп-слов для русского языка
russian_stopwords = {
    'и', 'в', 'во', 'не', 'что', 'он', 'на', 'я', 'с', 'со', 'как', 'а',
    'то', 'все', 'она', 'так', 'его', 'но', 'да', 'ты', 'к', 'у', 'же',
    'вы', 'за', 'бы', 'по', 'только', 'ее', 'мне', 'было', 'вот', 'от',
    'меня', 'еще', 'нет', 'о', 'из', 'ему', 'теперь', 'когда', 'даже',
    'ну', 'вдруг', 'ли', 'если', 'уже', 'или', 'ни', 'быть', 'был', 'него',
    'до', 'вас', 'нибудь', 'опять', 'уж', 'вам', 'ведь', 'там', 'потом',
    'себя', 'ничего', 'ей', 'может', 'они', 'тут', 'где', 'есть', 'надо',
    'ней', 'для', 'мы', 'тебя', 'их', 'чем', 'была', 'сам', 'чтоб', 'без',
    'будто', 'чего', 'раз', 'тоже', 'себе', 'под', 'будет', 'ж', 'тогда',
    'кто', 'этот', 'того', 'потому', 'этого', 'какой', 'совсем', 'ним',
    'здесь', 'этом', 'один', 'почти', 'мой', 'тем', 'чтобы', 'нее', 'сейчас',
    'были', 'куда', 'зачем', 'всех', 'никогда', 'можно', 'при', 'наконец',
    'два', 'об', 'другой', 'хоть', 'после', 'над', 'больше', 'тот', 'через',
    'эти', 'нас', 'про', 'всего', 'них', 'какая', 'много', 'разве', 'три',
    'эту', 'моя', 'впрочем', 'хорошо', 'свою', 'этой', 'перед', 'иногда',
    'лучше', 'чуть', 'том', 'нельзя', 'такой', 'им', 'более', 'всегда',
    'конечно', 'всю', 'между'
}

def remove_stopwords(text, stopwords=None, language='russian'):
    """Удаляет стоп-слова из текста."""
    if stopwords is None:
        if language == 'russian':
            stopwords = russian_stopwords
        elif language == 'english':
            # Базовые английские стоп-слова
            stopwords = {
                'a', 'an', 'the', 'and', 'or', 'but', 'in', 'on', 'at', 
                'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were',
                'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does',
                'did', 'will', 'would', 'shall', 'should', 'may', 'might',
                'must', 'can', 'could', 'i', 'you', 'he', 'she', 'it', 'we', 'they'
            }
        else:
            stopwords = set()
    
    words = text.split()
    filtered_words = [word for word in words if word.lower() not in stopwords]
    
    return " ".join(filtered_words)

text_with_stopwords = "Это пример текста с некоторыми стоп-словами и он должен быть очищен"
print(f"Исходный текст: {text_with_stopwords}")
cleaned_stopwords = remove_stopwords(text_with_stopwords, language='russian')
print(f"Без стоп-слов: {cleaned_stopwords}")

print("\n=== ЛЕММАТИЗАЦИЯ И СТЕММИНГ ===")
# Лемматизация — приведение слова к его нормальной форме (лемме)
# Стемминг — отсечение окончаний (более агрессивно, быстрее)

# Для русского языка используем pymorphy2
# Установка: pip install pymorphy2

try:
    import pymorphy2
    
    morph = pymorphy2.MorphAnalyzer()
    
    def lemmatize_russian(text):
        """Лемматизация русского текста."""
        words = text.split()
        lemmas = []
        
        for word in words:
            # Анализируем слово
            parsed = morph.parse(word)[0]
            # Получаем нормальную форму
            lemma = parsed.normal_form
            lemmas.append(lemma)
        
        return " ".join(lemmas)
    
    def stem_russian(text):
        """Стемминг русского текста (упрощенный)."""
        words = text.split()
        stems = []
        
        # Упрощенный стеммер для русского языка
        # В реальности лучше использовать pymystem3 или nltk
        endings = ['ый', 'ий', 'ая', 'яя', 'ое', 'ее', 'ые', 'ие', 'ов', 'ев',
                   'ам', 'ям', 'ами', 'ями', 'ах', 'ях', 'ом', 'ем', 'ой', 'ей']
        
        for word in words:
            stem = word
            # Пытаемся удалить окончания
            for ending in endings:
                if word.endswith(ending) and len(word) > len(ending) + 1:
                    stem = word[:-len(ending)]
                    break
            
            stems.append(stem)
        
        return " ".join(stems)
    
    test_text_lemma = "бегущие собаки видели красивых кошек"
    print(f"Исходный текст: {test_text_lemma}")
    print(f"Лемматизация: {lemmatize_russian(test_text_lemma)}")
    print(f"Стемминг: {stem_russian(test_text_lemma)}")
    
except ImportError:
    print("Установите pymorphy2 для лемматизации русского языка: pip install pymorphy2")
    
    # Альтернатива: простой стеммер на регулярных выражениях
    print("\nПростая замена окончаний (без pymorphy2):")
    import re
    
    def simple_stemmer(text):
        """Простой стеммер для русского текста."""
        # Паттерны для удаления окончаний
        patterns = [
            (r'(ый|ий|ая|яя|ое|ее|ые|ие|ов|ев|ам|ям|ами|ями|ах|ях|ом|ем|ой|ей)$', ''),
            (r'ся$', ''),  # Возвратные глаголы
            (r'ть$', ''),  # Инфинитивы глаголов
        ]
        
        words = text.split()
        stemmed_words = []
        
        for word in words:
            stemmed = word
            for pattern, replacement in patterns:
                stemmed = re.sub(pattern, replacement, stemmed)
            stemmed_words.append(stemmed)
        
        return " ".join(stemmed_words)
    
    test_text = "бегущие собаки видели красивых кошек"
    print(f"Исходный: {test_text}")
    print(f"После простого стемминга: {simple_stemmer(test_text)}")

print("\n=== НОРМАЛИЗАЦИЯ ТЕКСТА (ПОЛНЫЙ ПАЙПЛАЙН) ===")

def normalize_text(text, language='russian', remove_stopwords_flag=True, lemmatize_flag=True):
    """
    Полная нормализация текста.
    
    Args:
        text: исходный текст
        language: язык текста
        remove_stopwords_flag: удалять ли стоп-слова
        lemmatize_flag: выполнять ли лемматизацию
    
    Returns:
        Нормализованный текст
    """
    import re
    
    # 1. Приведение к нижнему регистру
    text = text.lower()
    
    # 2. Удаление лишних пробелов
    text = " ".join(text.split())
    
    # 3. Удаление цифр
    text = re.sub(r'\d+', '', text)
    
    # 4. Удаление знаков препинания (кроме дефиса для составных слов)
    text = re.sub(r'[^\w\s-]', '', text)
    
    # 5. Удаление одиночных символов (обычно не несут смысла)
    text = re.sub(r'\b\w\b', '', text)
    
    # 6. Удаление лишних дефисов
    text = re.sub(r'-{2,}', '', text)
    
    # 7. Удаление стоп-слов
    if remove_stopwords_flag:
        if language == 'russian':
            stopwords = russian_stopwords
        elif language == 'english':
            stopwords = {
                'a', 'an', 'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to',
                'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be',
                'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did'
            }
        else:
            stopwords = set()
        
        words = text.split()
        words = [word for word in words if word not in stopwords]
        text = " ".join(words)
    
    # 8. Лемматизация/стемминг
    if lemmatize_flag and language == 'russian':
        try:
            import pymorphy2
            morph = pymorphy2.MorphAnalyzer()
            words = text.split()
            lemmas = []
            
            for word in words:
                parsed = morph.parse(word)[0]
                lemmas.append(parsed.normal_form)
            
            text = " ".join(lemmas)
        except ImportError:
            # Если pymorphy2 не установлен, используем простой стеммер
            text = simple_stemmer(text) if 'simple_stemmer' in globals() else text
    
    # 9. Финальная очистка от лишних пробелов
    text = " ".join(text.split())
    
    return text.strip()

# Пример полной нормализации
dirty_text = """
  Вчера я купил 3 яблока, 2 апельсина и 1 кг бананов в магазине!
  Цена составила 150 рублей, что довольно ДЁШЕВО. 
  Однако, качество фруктов было на ВЫСОТЕ - рекомендую!
"""

print("Исходный 'грязный' текст:")
print(dirty_text)

normalized = normalize_text(dirty_text, language='russian', 
                           remove_stopwords_flag=True, 
                           lemmatize_flag=True)

print("\nПосле полной нормализации:")
print(normalized)

print("\n=== ОБРАБОТКА ТЕКСТА ДЛЯ КОНКРЕТНЫХ ЗАДАЧ ===")

# 1. Для поиска (поисковые запросы)
def prepare_for_search(query, language='russian'):
    """Подготовка текста для поиска."""
    query = query.lower()
    query = re.sub(r'[^\w\s]', '', query)  # Удаляем знаки препинания
    
    # Удаляем стоп-слова (для поиска лучше не удалять!)
    # query = remove_stopwords(query, language=language)
    
    # Лемматизация для поиска
    if language == 'russian':
        try:
            import pymorphy2
            morph = pymorphy2.MorphAnalyzer()
            words = query.split()
            lemmas = [morph.parse(word)[0].normal_form for word in words]
            query = " ".join(lemmas)
        except:
            pass
    
    return query.strip()

search_query = "купить яблоки и апельсины недорого"
print(f"Поисковый запрос: '{search_query}'")
print(f"Обработанный для поиска: '{prepare_for_search(search_query)}'")

# 2. Для классификации текста
def prepare_for_classification(text, language='russian'):
    """Подготовка текста для классификации или машинного обучения."""
    # Более агрессивная очистка
    text = text.lower()
    text = re.sub(r'[^\w\s]', ' ', text)  # Заменяем знаки препинания на пробелы
    text = re.sub(r'\s+', ' ', text)      # Удаляем лишние пробелы
    
    # Удаляем стоп-слова
    text = remove_stopwords(text, language=language)
    
    # Лемматизация
    if language == 'russian':
        try:
            import pymorphy2
            morph = pymorphy2.MorphAnalyzer()
            words = text.split()
            lemmas = [morph.parse(word)[0].normal_form for word in words if len(word) > 2]
            text = " ".join(lemmas)
        except:
            # Простой стемминг
            words = text.split()
            words = [word for word in words if len(word) > 2]
            text = " ".join(words)
    
    return text.strip()

classification_text = "Отличный товар! Рекомендую всем. Качество на высоте, доставка быстрая."
print(f"\nТекст для классификации: '{classification_text}'")
print(f"Обработанный: '{prepare_for_classification(classification_text)}'")

# 3. Для анализа тональности (сентимент-анализ)
def prepare_for_sentiment(text, language='russian'):
    """Подготовка текста для анализа тональности."""
    # Для анализа тональности важно сохранить эмоциональную окраску
    # Не удаляем восклицательные и вопросительные знаки
    text = text.lower()
    text = re.sub(r'[^\w\s!?]', '', text)  # Оставляем ! и ?
    
    # Удаляем цифры
    text = re.sub(r'\d+', '', text)
    
    # Удаляем лишние пробелы
    text = " ".join(text.split())
    
    # Для сентимент-анализа обычно НЕ удаляют стоп-слова и НЕ лемматизируют
    # так как это может изменить эмоциональную окраску
    
    return text.strip()

sentiment_text = "Ужасный сервис! Ждал доставку 2 недели, товар пришел сломанным."
print(f"\nТекст для анализа тональности: '{sentiment_text}'")
print(f"Обработанный: '{prepare_for_sentiment(sentiment_text)}'")

print("\n=== ИЗВЛЕЧЕНИЕ N-ГРАММ ===")
# N-граммы — последовательности из N слов, полезны для анализа

def extract_ngrams(text, n=2):
    """Извлекает n-граммы из текста."""
    words = text.split()
    
    if len(words) < n:
        return []
    
    ngrams = []
    for i in range(len(words) - n + 1):
        ngram = " ".join(words[i:i + n])
        ngrams.append(ngram)
    
    return ngrams

def extract_ngrams_with_freq(text, n=2, top_n=10):
    """Извлекает n-граммы и подсчитывает их частоту."""
    from collections import Counter
    
    ngrams = extract_ngrams(text, n)
    freq = Counter(ngrams)
    
    return freq.most_common(top_n)

sample_for_ngrams = "быстрая коричневая лиса прыгает через ленивую собаку"
print(f"Текст: {sample_for_ngrams}")
print(f"Биграммы (2-граммы): {extract_ngrams(sample_for_ngrams, 2)}")
print(f"Триграммы (3-граммы): {extract_ngrams(sample_for_ngrams, 3)}")

# Пример с русским текстом
russian_text = "мама мыла раму мылом а папа мыл машину водой"
print(f"\nРусский текст: {russian_text}")
print(f"Частые биграммы: {extract_ngrams_with_freq(russian_text, 2, 5)}")`,
        "description": "Предобработка текста — необходимый этап перед анализом. Основные шаги: 1) приведение к нижнему регистру, 2) удаление лишних пробелов, 3) удаление цифр и специальных символов, 4) удаление стоп-слов (частых слов без смысловой нагрузки), 5) лемматизация (приведение слов к нормальной форме) или стемминг (отсечение окончаний). Для русского языка эффективна библиотека pymorphy2. Разные задачи требуют разной степени очистки: для поиска важна лемматизация, для классификации — удаление стоп-слов, для анализа тональности — сохранение эмоциональных маркеров (восклицательных знаков). N-граммы (последовательности из N слов) полезны для выявления часто встречающихся словосочетаний. Всегда адаптируйте пайплайн предобработки под конкретную задачу и язык текста. Качество предобработки существенно влияет на результаты последующего анализа."
    },
    {
        "id": 40,
        "title": "Продвинутые техники регулярных выражений",
        "tag": "Другое",
        "shortDesc": "Жадные/ленивые квантификаторы, обратные ссылки, условные выражения, рекурсивные и балансирующие группы",
        "code": `# Регулярные выражения имеют много продвинутых возможностей, которые редко используются,
# но могут решать сложные задачи парсинга текста.

print("=== ЖАДНЫЕ (GREEDY) VS ЛЕНИВЫЕ (LAZY) КВАНТИФИКАТОРЫ ===")

# По умолчанию квантификаторы *, +, ?, {n,m} являются ЖАДНЫМИ (greedy) - 
# они захватывают максимально возможное количество символов.

text = "<div>Первый</div> <div>Второй</div> <div>Третий</div>"

print(f"Текст: {text}")

# Жадный квантификатор (по умолчанию)
import re
greedy_pattern = r'<div>.*</div>'  # Жадный - захватит ВСЁ от первого <div> до последнего </div>
match_greedy = re.search(greedy_pattern, text)
print(f"\nЖадный паттерн '{greedy_pattern}':")
print(f"  Найдено: '{match_greedy.group()}'")
print(f"  Длина: {len(match_greedy.group())} символов")

# Ленивый (нежадный) квантификатор - добавляем ? после квантификатора
lazy_pattern = r'<div>.*?</div>'  # Ленивый - захватит минимально возможное
match_lazy = re.search(lazy_pattern, text)
print(f"\nЛенивый паттерн '{lazy_pattern}':")
print(f"  Найдено: '{match_lazy.group()}'")
print(f"  Длина: {len(match_lazy.group())} символов")

# Разница при использовании findall
print("\n--- Разница при поиске всех совпадений ---")
all_greedy = re.findall(greedy_pattern, text)
all_lazy = re.findall(lazy_pattern, text)
print(f"Жадный findall: {all_greedy} (найдено: {len(all_greedy)})")
print(f"Ленивый findall: {all_lazy} (найдено: {len(all_lazy)})")

# Ещё пример
html = "<b>жирный</b> и <i>курсив</i> текст"
print(f"\nПример с HTML тегами: {html}")
print(f"Жадный <.*>: {re.findall(r'<.*>', html)}")
print(f"Ленивый <.*?>: {re.findall(r'<.*?>', html)}")

print("\n=== ОБРАТНЫЕ ССЫЛКИ (BACKREFERENCES) ===")

# Обратные ссылки \\\u200c1, \\\u200c2, \\\u200c3 ссылаются на ранее захваченные группы

# Поиск повторяющихся слов
text_with_repeats = "Это это пример примера с повторяющимися повторяющимися словами"
pattern_repeat = r'\\\u200cb(\\\u200cw+)\\\u200cs+\\\u200c1\\\u200cb'  # \\\u200c1 ссылается на первую группу захвата
repeats = re.findall(pattern_repeat, text_with_repeats, flags=re.IGNORECASE)
print(f"Текст: {text_with_repeats}")
print(f"Повторяющиеся слова: {repeats}")

# Более сложный пример: поиск палиндромов из 3 букв
palindrome_text = "нашел слова: level, radar, rotator, madam, noon, abccba"
palindrome_pattern = r'\\\u200cb(\\\u200cw)(\\\u200cw)\\\u200c2\\\u200c1\\\u200cb'  # Первая буква, вторая, та же вторая, та же первая
palindromes = re.findall(palindrome_pattern, palindrome_text, flags=re.IGNORECASE)
print(f"\nТекст: {palindrome_text}")
print(f"Палиндромы из 4 букв: {[''.join(p) for p in palindromes]}")

# Замена с использованием обратных ссылок
phone_text = "Номера: 123-456-7890, 987-654-3210"
# Меняем формат с 123-456-7890 на (123) 456-7890
formatted = re.sub(r'(\\\u200cd{3})-(\\\u200cd{3})-(\\\u200cd{4})', r'(\\\u200c1) \\\u200c2-\\\u200c3', phone_text)
print(f"\nИсходный текст: {phone_text}")
print(f"После форматирования: {formatted}")

print("\n=== УСЛОВНЫЕ ВЫРАЖЕНИЯ (CONDITIONAL PATTERNS) ===")

# Синтаксис: (?(id/name)yes-pattern|no-pattern)
# Если группа с id/name захвачена - ищем yes-pattern, иначе no-pattern

# Пример: проверка правильности открывающих и закрывающих тегов
html_tags = "<div>текст</div> <p>текст</span> <span>текст</span>"

# Паттерн проверяет, что если открывающий тег <div> или <p>, то закрывающий должен быть таким же
# (?(1) должен быть </div>|(?(2) должен быть </p>|</span>))
tag_pattern = r'<(div|p|span)>(.*?)</(?(1)\\\u200c\\\u200c1|(?(2)\\\u200c\\\u200c2|span))>'
# Этот паттерн сложен для чтения, давайте разберем его:
# 1. <(div|p|span)> - открывающий тег, захватываем его в группу 1
# 2. (.*?) - содержимое тега (ленивый захват)
# 3. </(?(1)\\\u200c\\\u200c1|(?(2)\\\u200c\\\u200c2|span))> - условное выражение:
#    - Если группа 1 захвачена (тег div), то должен быть </div> (\\\u200c1 ссылается на div)
#    - Иначе если группа 2? (у нас нет группы 2) - на самом деле паттерн сложнее

# Более понятный пример с условными выражениями
# Проверка, что если есть код страны, то он в правильном формате
phone_pattern = r'(\((\d+)\)\s*)?(\d{3}-\d{4})'
test_numbers = ["555-1234", "(123) 555-1234", "(123)555-1234", "(12) 555-1234"]

print("Проверка телефонных номеров:")
for num in test_numbers:
    match = re.match(phone_pattern, num)
    if match:
        print(f"  {num}: OK, группы: {match.groups()}")
    else:
        print(f"  {num}: Не соответствует")

print("\n=== РЕКУРСИВНЫЕ И БАЛАНСИРУЮЩИЕ ГРУППЫ ===")

# Python не поддерживает рекурсивные шаблоны напрямую, но можно использовать (?R) или (?0)
# для рекурсивного поиска (например, для парсинга вложенных скобок)

# Простой пример с вложенными скобками (ограниченная вложенность)
nested_brackets = "Пример (вложенные (скобки (и еще)) вот так)"
# Паттерн для поиска текста в скобках с одним уровнем вложенности
simple_nested = r'\([^()]*(?:\([^()]*\)[^()]*)*\)'
matches = re.findall(simple_nested, nested_brackets)
print(f"Текст: {nested_brackets}")
print(f"Найдены вложенные скобки (1 уровень): {matches}")

# Для произвольной вложенности в Python обычно используют не регулярки, а парсеры
# Но можно попробовать с использованием модуля regex (не re), который поддерживает рекурсию

try:
    import regex  # Установка: pip install regex
    
    text_with_nesting = "a(b(c(d)e)f)g"
    recursive_pattern = r'\\(([^()]|(?R))*\\)'  # Рекурсивный паттерн для поиска парных скобок
    match_recursive = regex.search(recursive_pattern, text_with_nesting)
    print(f"\nТекст с глубокой вложенностью: {text_with_nesting}")
    print(f"Найдено с помощью рекурсивного паттерна: {match_recursive.group()}")
except ImportError:
    print("\nУстановите модуль regex для рекурсивных паттернов: pip install regex")

print("\n=== ЗАХВАТ БЕЗ СОЗДАНИЯ ГРУППЫ (NON-CAPTURING GROUPS) ===")

# Иногда нужно сгруппировать часть паттерна, но не захватывать её в отдельную группу
# Используется синтаксис (?:pattern)

text_with_dates = "Даты: 2023-01-15, 2022-12-31, 2024-05-20"
# Мы хотим найти даты, но захватить только год и день, пропуская месяц
pattern_non_capturing = r'(\d{4})-(?:\d{2})-(\d{2})'
matches = re.findall(pattern_non_capturing, text_with_dates)
print(f"Текст: {text_with_dates}")
print(f"Найдены года и дни (месяц пропущен): {matches}")

# Сравним с обычной группой
pattern_capturing = r'(\d{4})-(\d{2})-(\d{2})'
matches_capturing = re.findall(pattern_capturing, text_with_dates)
print(f"Все три группы: {matches_capturing}")

print("\n=== ПОЗИТИВНЫЕ И НЕГАТИВНЫЕ ОПЕРЕЖАЮЩИЕ ПРОВЕРКИ ===")

# Опережающие (lookahead) и ретроспективные (lookbehind) проверки

# Позитивная опережающая проверка: (?=pattern) - ищем X, за которым следует pattern
text = "Яблоко стоит 100 руб, апельсин 200 руб, банан 50 руб"
# Найдем все числа, за которыми следует " руб"
positive_lookahead = r'\d+(?=\s*руб)'
matches = re.findall(positive_lookahead, text)
print(f"Текст: {text}")
print(f"Цены (позитивная опережающая): {matches}")

# Негативная опережающая проверка: (?!pattern) - ищем X, за которым НЕ следует pattern
# Найдем числа, за которыми НЕ следует " руб"
negative_lookahead = r'\d+(?!\s*руб)'
matches = re.findall(negative_lookahead, text)
print(f"Числа не в ценах (негативная опережающая): {matches}")

# Позитивная ретроспективная проверка: (?<=pattern) - ищем X, перед которым идет pattern
# Найдем слово после "стоит"
positive_lookbehind = r'(?<=стоит\s)\w+'
matches = re.findall(positive_lookbehind, text)
print(f"Слова после 'стоит' (позитивная ретроспективная): {matches}")

# Негативная ретроспективная проверка: (?<!pattern) - ищем X, перед которым НЕ идет pattern
# Найдем "руб", перед которым НЕ стоит цифра 50
negative_lookbehind = r'(?<!50\s)руб'
matches = re.findall(negative_lookbehind, text)
print(f"'руб' не после 50 (негативная ретроспективная): {matches}")

print("\n=== АТОМАРНЫЕ ГРУППЫ (ATOMIC GROUPS) ===")

# Атомарные группы (?>...) - отката назад не происходит
# Полезны для оптимизации и предотвращения катастрофического backtracking

# Пример катастрофического backtracking
evil_pattern = r'(a+)+b'  # Много 'a' и затем 'b'
evil_text = 'a' * 100 + 'c'  # 100 букв 'a' и затем 'c' (нет 'b')

print("Тест катастрофического backtracking...")
try:
    # Этот поиск может занять очень много времени
    # match = re.match(evil_pattern, evil_text)  # Раскомментируйте на свой страх и риск
    # print(f"Найдено: {match}")
    print("  (пропущено для безопасности)")
except:
    print("  Ошибка или слишком долго")

# Использование атомарной группы для оптимизации
atomic_pattern = r'(?>a+)+b'  # Атомарная группа предотвращает backtracking внутри (?>...)
print("С атомарной группой поиск будет быстрее и безопаснее")

print("\n=== МОДИФИКАТОРЫ ВНУТРИ ПАТТЕРНА ===")

# Модификаторы можно применять к части паттерна: (?i) - ignore case, (?s) - dotall и т.д.

case_sensitive_text = "Apple apple APPLE"
# Без модификатора
matches1 = re.findall(r'apple', case_sensitive_text)
print(f"Текст: {case_sensitive_text}")
print(f"Без модификатора: {matches1}")

# С модификатором внутри паттерна (только для части паттерна)
matches2 = re.findall(r'(?i)apple', case_sensitive_text)
print(f"С (?i) в паттерне: {matches2}")

# Модификатор можно отключать: (?-i)
mixed_pattern = r'(?i)APPLE(?-i) и яблоко'
test_text = "APPLE и яблоко, apple и Яблоко"
matches3 = re.findall(mixed_pattern, test_text)
print(f"\nПаттерн '(?i)APPLE(?-i) и яблоко' в тексте '{test_text}': {matches3}")

print("\n=== ПРИМЕР СЛОЖНОГО ПАТТЕРНА: ПАРСИНГ SQL ЗАПРОСОВ ===")

# Создадим паттерн для извлечения SELECT запросов с их алиасами
sql_query = """
SELECT 
    users.id AS user_id,
    users.name AS user_name,
    orders.total AS order_total,
    DATE(orders.created_at) AS order_date
FROM users
LEFT JOIN orders ON users.id = orders.user_id
WHERE orders.status = 'completed'
GROUP BY users.id, DATE(orders.created_at)
"""

# Паттерн для извлечения колонок с алиасами из SELECT части
select_pattern = r'SELECT\s+(.*?)\s+FROM'  # Базовый паттерн
match = re.search(select_pattern, sql_query, re.DOTALL | re.IGNORECASE)
if match:
    select_clause = match.group(1)
    # Теперь извлекаем отдельные колонки с алиасами
    column_pattern = r'(\w+(?:\.\w+)?)\s+AS\s+(\w+)'
    columns = re.findall(column_pattern, select_clause, re.IGNORECASE)
    print("Извлеченные колонки с алиасами:")
    for col, alias in columns:
        print(f"  {col} -> {alias}")

# Парсинг JOIN условий
join_pattern = r'(?:LEFT|RIGHT|INNER|OUTER)?\s*JOIN\s+(\w+)\s+ON\s+(.*?)(?=(?:LEFT|RIGHT|INNER|OUTER\s+JOIN|WHERE|GROUP|ORDER|$))'
joins = re.findall(join_pattern, sql_query, re.IGNORECASE | re.DOTALL)
print("\nИзвлеченные JOIN условия:")
for table, condition in joins:
    print(f"  Таблица: {table}, Условие: {condition.strip()}")`,
        "description": "Продвинутые техники регулярных выражений включают: 1) жадные (greedy) и ленивые (lazy) квантификаторы (? после квантификатора делает его ленивым), 2) обратные ссылки (\\1, \\2) для ссылки на ранее захваченные группы, 3) условные выражения ((?(id)yes|no)), 4) незахватывающие группы (?:pattern), 5) опережающие (lookahead: (?=), (?!) ) и ретроспективные (lookbehind: (?<=), (?<!) ) проверки, 6) атомарные группы (?>pattern) для оптимизации и предотвращения катастрофического backtracking, 7) модификаторы внутри паттерна ((?i), (?s) и т.д.). Эти техники позволяют решать сложные задачи парсинга, но требуют осторожности — сложные регулярные выражения могут стать нечитаемыми и неэффективными. Для парсинга вложенных структур (скобки, HTML/XML) часто лучше использовать специализированные парсеры, а не регулярные выражения."
    },
    {
        "id": 41,
        "title": "Практическое применение регулярных выражений",
        "tag": "Другое",
        "shortDesc": "Реальные кейсы использования regex: парсинг логов, валидация данных, текстовый анализ, работа с кодами",
        "code": `# Регулярные выражения широко применяются в реальных задачах: логи, валидация, парсинг, анализ текста.
# Рассмотрим практические примеры из реальной разработки.

print("=== ПАРСИНГ ЛОГ-ФАЙЛОВ ===")

# Типичные логи веб-сервера (Nginx/Apache)
log_entries = [
    '192.168.1.1 - - [10/Dec/2023:14:12:34 +0300] "GET /index.html HTTP/1.1" 200 1234',
    '192.168.1.2 - - [10/Dec/2023:14:12:35 +0300] "POST /api/login HTTP/1.1" 401 567',
    '192.168.1.3 - - [10/Dec/2023:14:12:36 +0300] "GET /products?id=123 HTTP/1.1" 200 8901',
    '192.168.1.1 - - [10/Dec/2023:14:12:37 +0300] "GET /robots.txt HTTP/1.1" 404 342',
]

print("Пример лог-файла веб-сервера:")
for entry in log_entries:
    print(f"  {entry}")

# Парсинг логов с помощью регулярного выражения
log_pattern = r'(\d+\.\d+\.\d+\.\d+) - - \[([^\]]+)\] "(\w+) ([^ ]+) HTTP/[^"]+" (\d+) (\d+)'

print("\nПарсинг логов:")
for entry in log_entries:
    match = re.match(log_pattern, entry)
    if match:
        ip, timestamp, method, url, status_code, size = match.groups()
        print(f"  IP: {ip}, Время: {timestamp}, Метод: {method}, URL: {url}, Статус: {status_code}, Размер: {size}")

# Анализ логов: подсчет статусов
print("\nАнализ логов - подсчет статусных кодов:")
status_counts = {}
for entry in log_entries:
    match = re.match(log_pattern, entry)
    if match:
        status = match.group(5)
        status_counts[status] = status_counts.get(status, 0) + 1

for status, count in status_counts.items():
    print(f"  Статус {status}: {count} запросов")

print("\n=== ВАЛИДАЦИЯ ДАННЫХ ===")

def validate_email(email):
    """Валидация email адреса."""
    # Базовый паттерн для email (упрощенный, для реального использования нужен более сложный)
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

def validate_phone(phone):
    """Валидация российского телефонного номера."""
    # Поддерживает форматы: +7XXX..., 8XXX..., 7XXX...
    pattern = r'^(\+7|7|8)?[\s\-]?\(?[489][0-9]{2}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$'
    return bool(re.match(pattern, phone))

def validate_password(password):
    """
    Валидация пароля:
    - минимум 8 символов
    - хотя бы одна заглавная буква
    - хотя бы одна строчная буква  
    - хотя бы одна цифра
    - хотя бы один специальный символ
    """
    if len(password) < 8:
        return False, "Пароль должен содержать минимум 8 символов"
    
    checks = [
        (r'[A-ZА-Я]', "Пароль должен содержать хотя бы одну заглавную букву"),
        (r'[a-zа-я]', "Пароль должен содержать хотя бы одну строчную букву"),
        (r'\d', "Пароль должен содержать хотя бы одну цифру"),
        (r'[!@#$%^&*(),.?":{}|<>]', "Пароль должен содержать хотя бы один специальный символ"),
    ]
    
    for pattern, message in checks:
        if not re.search(pattern, password):
            return False, message
    
    return True, "Пароль валиден"

def validate_inn(inn):
    """Валидация ИНН (для физлиц - 12 цифр, для юрлиц - 10 цифр)."""
    if re.match(r'^\d{10}$', inn):
        # Проверка контрольной цифры для 10-значного ИНН
        weights = [2, 4, 10, 3, 5, 9, 4, 6, 8]
        checksum = sum(int(inn[i]) * weights[i] for i in range(9)) % 11 % 10
        return int(inn[9]) == checksum
    elif re.match(r'^\d{12}$', inn):
        # Проверка контрольных цифр для 12-значного ИНН
        weights1 = [7, 2, 4, 10, 3, 5, 9, 4, 6, 8]
        weights2 = [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8]
        
        checksum1 = sum(int(inn[i]) * weights1[i] for i in range(10)) % 11 % 10
        checksum2 = sum(int(inn[i]) * weights2[i] for i in range(11)) % 11 % 10
        
        return int(inn[10]) == checksum1 and int(inn[11]) == checksum2
    
    return False

# Тестирование валидации
print("Валидация данных:")

test_emails = ["user@example.com", "invalid.email", "name@domain", "user@com"]
print("\nEmail валидация:")
for email in test_emails:
    print(f"  {email}: {'✓' if validate_email(email) else '✗'}")

test_phones = ["+7 999 123-45-67", "8(999)1234567", "79991234567", "123-45-67", "+1-234-567-8900"]
print("\nТелефон валидация:")
for phone in test_phones:
    print(f"  {phone}: {'✓' if validate_phone(phone) else '✗'}")

test_passwords = ["Simple123!", "weak", "NoSpecial1", "NOLOWER1!", "noupper1!", "GoodPass123!"]
print("\nПароль валидация:")
for pwd in test_passwords:
    valid, message = validate_password(pwd)
    print(f"  {pwd}: {'✓' if valid else '✗'} ({message})")

test_inns = ["7707083893", "1234567890", "500100732259", "123456789012"]
print("\nИНН валидация:")
for inn in test_inns:
    print(f"  {inn}: {'✓' if validate_inn(inn) else '✗'}")

print("\n=== АНАЛИЗ И ИЗВЛЕЧЕНИЕ ДАННЫХ ИЗ ТЕКСТА ===")

def extract_hashtags(text):
    """Извлечение хештегов из текста."""
    # Хештеги начинаются с # и содержат буквы, цифры и подчеркивания
    return re.findall(r'#(\w+)', text)

def extract_mentions(text):
    """Извлечение упоминаний пользователей (@username)."""
    return re.findall(r'@(\w+)', text)

def extract_urls(text):
    """Извлечение URL из текста."""
    # Упрощенный паттерн для URL
    pattern = r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[/\w .?=&%-]*'
    return re.findall(pattern, text)

def extract_emails_from_text(text):
    """Извлечение email адресов из текста."""
    pattern = r'\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b'
    return re.findall(pattern, text)

# Пример текста для анализа
social_text = """
Привет @ivan! Посмотри этот проект #python #regex.
Ссылка: https://github.com/user/repo
Свяжись со мной: my.email@example.com или backup_email@domain.co.uk
#программирование #учимpython
"""

print(f"Текст для анализа:\n{social_text}")

print("Извлеченные данные:")
print(f"  Хештеги: {extract_hashtags(social_text)}")
print(f"  Упоминания: {extract_mentions(social_text)}")
print(f"  URL: {extract_urls(social_text)}")
print(f"  Email: {extract_emails_from_text(social_text)}")

print("\n=== ОБРАБОТКА КОДОВ И ИДЕНТИФИКАТОРОВ ===")

def normalize_phone(phone):
    """Нормализация телефонного номера к формату +7XXXXXXXXXX."""
    # Удаляем все нецифровые символы
    digits = re.sub(r'\D', '', phone)
    
    if digits.startswith('8'):
        # Заменяем ведущую 8 на +7
        return '+7' + digits[1:]
    elif digits.startswith('7'):
        return '+' + digits
    elif len(digits) == 10:
        return '+7' + digits
    else:
        return phone  # Возвращаем как есть, если формат не распознан

test_phones_to_normalize = [
    "+7 999 123-45-67",
    "8(999)1234567", 
    "79991234567",
    "9991234567"
]

print("Нормализация телефонных номеров:")
for phone in test_phones_to_normalize:
    print(f"  {phone} -> {normalize_phone(phone)}")

def extract_credit_card_info(text):
    """Извлечение и маскирование номеров кредитных карт."""
    # Паттерн для номеров карт (упрощенный)
    pattern = r'\b(?:\d[ -]*?){13,16}\b'
    
    def mask_card(match):
        card = re.sub(r'\D', '', match.group(0))
        if 13 <= len(card) <= 16:
            # Оставляем первые 4 и последние 4 цифры
            return card[:4] + '*' * (len(card) - 8) + card[-4:]
        return match.group(0)
    
    return re.sub(pattern, mask_card, text)

text_with_cards = """
Моя карта: 4111 1111 1111 1111, срок 12/25.
Резервная: 5500 0000 0000 0004.
И еще одна: 378282246310005.
"""

print("Маскирование номеров карт:")
print(f"До: {text_with_cards}")
print(f"После: {extract_credit_card_info(text_with_cards)}")

print("\n=== РАБОТА С HTML/XML ===")

def extract_html_tags(html):
    """Извлечение всех HTML тегов с атрибутами."""
    pattern = r'<(\w+)(\s+[^>]*)?>'
    return re.findall(pattern, html)

def remove_html_tags(html):
    """Удаление HTML тегов из текста."""
    return re.sub(r'<[^>]+>', '', html)

def extract_html_links(html):
    """Извлечение всех ссылок из HTML."""
    # Ищем href в тегах <a>
    pattern = r'<a\s+(?:[^>]*?\s+)?href="([^"]*)"'
    return re.findall(pattern, html, re.IGNORECASE)

sample_html = """
<html>
<body>
  <h1 class="title">Заголовок</h1>
  <p>Текст с <a href="https://example.com">ссылкой</a> и <b>жирным</b> текстом.</p>
  <a href="/about" id="about-link">О нас</a>
  <img src="image.jpg" alt="Изображение">
</body>
</html>
"""

print("Анализ HTML:")
print(f"Теги: {[tag[0] for tag in extract_html_tags(sample_html)]}")
print(f"Ссылки: {extract_html_links(sample_html)}")
print(f"Текст без тегов:\n{remove_html_tags(sample_html)}")

print("\n=== АВТОМАТИЧЕСКОЕ ФОРМАТИРОВАНИЕ ===")

def format_number_with_spaces(number_str):
    """Форматирование числа с пробелами между тысячами."""
    # Добавляем пробелы каждые 3 цифры с конца
    return re.sub(r'(\\\u200cd)(?=(\\\u200cd{3})+$)', r'\\\u200c1 ', number_str[::-1])[::-1]

def format_russian_phone(phone):
    """Форматирование российского телефона в единый формат."""
    digits = re.sub(r'\\\u200cD', '', phone)
    
    if len(digits) == 11 and digits.startswith(('7', '8')):
        # Формат: +7 (XXX) XXX-XX-XX
        return f"+7 ({digits[1:4]}) {digits[4:7]}-{digits[7:9]}-{digits[9:]}"
    elif len(digits) == 10:
        return f"+7 ({digits[0:3]}) {digits[3:6]}-{digits[6:8]}-{digits[8:]}"
    
    return phone

numbers_to_format = ["1000000", "123456789", "9876543210"]
print("Форматирование чисел:")
for num in numbers_to_format:
    print(f"  {num} -> {format_number_with_spaces(num)}")

phones_to_format = ["89991234567", "+79161234567", "9161234567"]
print("\nФорматирование телефонов:")
for phone in phones_to_format:
    print(f"  {phone} -> {format_russian_phone(phone)}")

print("\n=== РЕАЛЬНЫЙ КЕЙС: ПАРСИНГ КОНФИГУРАЦИОННЫХ ФАЙЛОВ ===")

# Парсинг .env файлов
env_content = """
# Настройки базы данных
DB_HOST=localhost
DB_PORT=5432
DB_NAME=mydb
DB_USER=admin
DB_PASSWORD=secret123

# Настройки приложения
DEBUG=true
API_KEY=abc123-def456-ghi789
ALLOWED_HOSTS=localhost,127.0.0.1,example.com
"""

def parse_env_file(content):
    """Парсинг .env файла."""
    pattern = r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*?)\s*$'
    config = {}
    
    for line in content.split('\n'):
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        
        match = re.match(pattern, line)
        if match:
            key, value = match.groups()
            
            # Обработка значений
            if value.lower() in ('true', 'false'):
                value = value.lower() == 'true'
            elif value.isdigit():
                value = int(value)
            elif re.match(r'^\d+\.\d+$', value):
                value = float(value)
            elif ',' in value and not re.search(r'[\[\]\{\}]', value):
                # Разделение списков (простой случай)
                value = [item.strip() for item in value.split(',')]
            
            config[key] = value
    
    return config

print("Парсинг .env файла:")
config = parse_env_file(env_content)
for key, value in config.items():
    print(f"  {key} = {value} (тип: {type(value).__name__})")

print("\n=== СОВЕТЫ ДЛЯ РЕАЛЬНОЙ РАБОТЫ С REGEX ===")

advice = """
1. Всегда тестируйте регулярные выражения на краевых случаях
2. Используйте сырые строки (r'...') для избежания проблем с обратными слешами
3. Комментируйте сложные регулярные выражения или разбивайте их на части
4. Для сложного парсинга (HTML, XML, JSON) используйте специализированные парсеры
5. Учитывайте производительность: некоторые паттерны могут вызывать катастрофический backtracking
6. Используйте онлайн-тестеры регулярных выражений для отладки
7. В Python используйте re.VERBOSE для написания многострочных, комментируемых регулярных выражений
8. Для часто используемых паттернов компилируйте их с re.compile()
9. Помните о локали и кодировке при работе с Unicode
10. Регулярные выражения - мощный инструмент, но не серебряная пуля для всех задач парсинга
"""

print(advice)

print("\n=== ПРИМЕР С re.VERBOSE ===")

# Создание читаемого регулярного выражения с комментариями
verbose_pattern = re.compile(r"""
    ^                 # Начало строки
    (\d{3})           # Код города (3 цифры)
    [-.\s]?           # Разделитель (необязательный)
    (\d{3})           # Первые 3 цифры номера
    [-.\s]?           # Разделитель (необязательный)
    (\d{4})           # Последние 4 цифры номера
    $                 # Конец строки
""", re.VERBOSE)

test_numbers = ["123-456-7890", "123.456.7890", "1234567890", "123 456 7890"]
print("Проверка телефонных номеров с verbose паттерном:")
for num in test_numbers:
    match = verbose_pattern.match(num)
    if match:
        print(f"  {num}: OK - {match.groups()}")
    else:
        print(f"  {num}: Не соответствует")`,
        "description": "Регулярные выражения имеют множество практических применений: 1) парсинг логов веб-серверов для анализа трафика и ошибок, 2) валидация данных (email, телефоны, пароли, ИНН), 3) извлечение информации из текста (хештеги, упоминания, URL, email), 4) работа с HTML/XML (извлечение тегов, ссылок, очистка от разметки), 5) нормализация данных (телефоны, числа), 6) парсинг конфигурационных файлов (.env, ini). При работе с regex в реальных проектах важно тестировать на краевых случаях, учитывать производительность (избегать катастрофического backtracking), использовать re.VERBOSE для сложных паттернов и re.compile() для часто используемых выражений. Для парсинга сложных структур (вложенные скобки, HTML) часто лучше использовать специализированные парсеры, а не регулярные выражения."
    },
    {
        "id": 42,
        "title": "Git: Основы контроля версий (Часть 1)",
        "tag": "Другое",
        "shortDesc": "Установка, настройка, базовые команды и основные концепции Git: репозиторий, коммиты, история",
        "code": `# ========== ЧАСТЬ 1: ОСНОВЫ GIT ==========
# Git — распределённая система контроля версий.
# Позволяет отслеживать изменения в коде, работать в команде и откатываться к предыдущим версиям.

print("=== УСТАНОВКА И НАСТРОЙКА GIT ===")

# Команды выполняются в терминале (Command Line)

# 1. Установка Git (зависит от ОС)
"""
Для Linux (Debian/Ubuntu):
    sudo apt-get install git

Для Linux (Fedora):
    sudo dnf install git

Для Mac (через Homebrew):
    brew install git

Для Windows:
    Скачать с https://git-scm.com/
"""

# 2. Проверка установки
# git --version
# Должна вывести что-то вроде: git version 2.39.0

# 3. Настройка пользователя (ВАЖНО: сделать перед первым коммитом!)
"""
git config --global user.name "Ваше Имя"
git config --global user.email "ваш.email@example.com"

# Проверка настроек:
git config --list
"""

print("=== СОЗДАНИЕ И НАСТРОЙКА РЕПОЗИТОРИЯ ===")

# Репозиторий — папка, в которой Git отслеживает изменения

# 1. Создание нового репозитория
"""
# Перейдите в папку вашего проекта
cd /путь/к/вашему/проекту

# Инициализация репозитория
git init
# Создаёт скрытую папку .git с настройками и историей

# Проверка состояния репозитория
git status
"""

# 2. Клонирование существующего репозитория
"""
# Клонирование с GitHub/GitLab/Bitbucket
git clone https://github.com/username/repository.git

# Клонирование в конкретную папку
git clone https://github.com/username/repository.git имя_папки
"""

print("\n=== ОСНОВНЫЕ КОНЦЕПЦИИ GIT ===")

"""
Рабочая директория (Working Directory)   - Файлы на вашем компьютере
Область подготовки (Staging Area/Index)  - Файлы, готовые к коммиту
Репозиторий (Repository)                 - История всех коммитов (.git папка)

Рабочий процесс:
    1. Изменяем файлы в рабочей директории
    2. Добавляем изменения в staging area (git add)
    3. Фиксируем изменения в репозитории (git commit)
"""

print("\n=== БАЗОВЫЙ WORKFLOW: ОТ ИЗМЕНЕНИЙ ДО КОММИТА ===")

# 1. Проверка состояния файлов
"""
git status
# Показывает:
# - Изменённые файлы
# - Новые файлы (untracked)
# - Файлы в staging area
"""

# 2. Добавление файлов в staging area
"""
# Добавить конкретный файл
git add index.html

# Добавить все изменённые файлы (кроме untracked)
git add -u

# Добавить ВСЕ файлы (включая новые)
git add .

# Добавить файлы по шаблону
git add *.py
git add src/*.js

# Интерактивное добавление (выбор частей файлов)
git add -p
"""

# 3. Отмена добавления в staging area
"""
# Убрать файл из staging area (но сохранить изменения)
git reset HEAD файл.py

# Убрать ВСЕ файлы из staging area
git reset
"""

# 4. Создание коммита
"""
# Коммит с сообщением
git commit -m "Добавил главную страницу"

# Коммит с открытием редактора для сообщения
git commit

# Коммит, автоматически добавляя изменённые файлы (кроме новых)
git commit -a -m "Сообщение коммита"
# Внимание: новые файлы (untracked) не будут добавлены!

# Редактирование последнего коммита (если ещё не отправили на сервер)
git commit --amend -m "Новое сообщение"
"""

print("\n=== ПРИМЕР ПОЛНОГО ЦИКЛА РАБОТЫ ===")

# Симуляция работы с репозиторием
example_code = """
# 1. Начинаем новый проект
mkdir my-project
cd my-project
git init

# 2. Создаём и редактируем файлы
echo "# Мой проект" > README.md
echo "print('Hello')" > main.py

# 3. Проверяем состояние
git status
# Вывод:
#   Untracked files: (файлы, которые Git ещё не отслеживает)
#     README.md
#     main.py

# 4. Добавляем файлы в staging area
git add README.md main.py
# или git add .

# 5. Проверяем состояние снова
git status
# Вывод:
#   Changes to be committed: (файлы готовы к коммиту)
#     new file: README.md
#     new file: main.py

# 6. Создаём коммит
git commit -m "Initial commit: добавил README и основной файл"

# 7. Вносим изменения в существующий файл
echo "print('World')" >> main.py

# 8. Проверяем разницу
git diff
# Покажет изменения с момента последнего коммита

# 9. Добавляем и коммитим изменения
git add main.py
git commit -m "Добавил вывод 'World'"

# 10. История коммитов
git log
"""
print(example_code)

print("=== РАБОТА С ИСТОРИЕЙ И ИЗМЕНЕНИЯМИ ===")

# 1. Просмотр истории коммитов
"""
# Полная история
git log

# Краткая история (одна строка на коммит)
git log --oneline

# История с графиком ветвлений
git log --graph --oneline --all

# История с конкретным количеством коммитов
git log -5
git log -5 --oneline

# История с деталями изменений
git log -p
git log -p -2  # Последние 2 коммита с diff

# История по автору
git log --author="Имя"

# История по дате
git log --since="2024-01-01"
git log --until="2024-12-31"
"""

# 2. Просмотр изменений
"""
# Разница между рабочей директорией и последним коммитом
git diff

# Разница между staging area и последним коммитом
git diff --staged
git diff --cached  # То же самое

# Разница между двумя коммитами
git diff хэш1 хэш2

# Разница между ветками
git diff main..feature
"""

# 3. Отмена изменений
"""
# Отменить изменения в рабочей директории (вернуть к последнему коммиту)
git checkout -- файл.py
# Внимание: изменения будут безвозвратно удалены!

# Более безопасная альтернатива (Git 2.23+)
git restore файл.py

# Отменить изменения в staging area (вытащить обратно в рабочую директорию)
git reset HEAD файл.py

# Восстановить файл из другого коммита
git checkout хэш_коммита -- файл.py
"""

print("\n=== ХЭШИ И ТЕГИ ===")

# Хэш коммита — уникальный идентификатор (например, a1b2c3d4...)

# 1. Работа с хэшами
"""
# Просмотр полного хэша
git log --pretty=fuller

# Короткий хэш (первые 7 символов)
git log --abbrev-commit --pretty=oneline

# Использование короткого хэша в командах
git show a1b2c3d
git diff a1b2c3d..e5f6g7h
"""

# 2. Создание и работа с тегами
"""
# Тег — именованная метка для определённого коммита

# Создать легковесный тег (указывает на коммит)
git tag v1.0.0

# Создать аннотированный тег (с сообщением)
git tag -a v1.0.0 -m "Версия 1.0.0"

# Создать тег для определённого коммита
git tag v0.9.0 a1b2c3d

# Просмотр тегов
git tag
git tag -l "v1.*"  # Поиск по шаблону

# Просмотр информации о теге
git show v1.0.0

# Удалить тег
git tag -d v0.9.0

# Отправка тегов на удалённый репозиторий
git push origin v1.0.0
git push origin --tags  # Все теги
"""

print("\n=== ФАЙЛ .gitignore ===")

# .gitignore — файл, указывающий Git, какие файлы/папки игнорировать

gitignore_example = """
# Пример .gitignore файла

# Системные файлы
.DS_Store           # Mac
Thumbs.db           # Windows
desktop.ini         # Windows

# IDE и редакторы кода
.vscode/
.idea/
*.swp
*.swo

# Логи и временные файлы
*.log
*.tmp
*.temp

# Зависимости (пакеты)
node_modules/
__pycache__/
*.pyc
*.pyo
.pytest_cache/

# Скомпилированные файлы
*.class            # Java
*.exe              # Windows
*.dll              # Windows
*.so               # Linux

# Файлы окружения (секреты!)
.env
.env.local
.env.*.local
secrets.yml

# Файлы сборки/дистрибутивы
dist/
build/
*.egg-info/

# Исключения (вопреки правилам выше)
!important.log     # Не игнорировать этот файл
"""
print(gitignore_example)

print("\n=== КРАТКАЯ ШПАРГАЛКА НА КАЖДЫЙ ДЕНЬ ===")

cheatsheet = """
# СТАТУС И ИСТОРИЯ
git status                    # Что изменилось?
git log --oneline -10        # Последние 10 коммитов
git diff                     # Что именно изменилось?

# ДОБАВЛЕНИЕ И КОММИТ
git add файл.py              # Добавить конкретный файл
git add .                    # Добавить всё
git commit -m "Сообщение"    # Закоммитить изменения
git commit -a -m "Сообщение" # Добавить и закоммитить (кроме новых файлов)

# ОТМЕНА
git checkout -- файл.py      # Откатить изменения в файле (Git < 2.23)
git restore файл.py          # Откатить изменения в файле (Git 2.23+)
git reset HEAD файл.py       # Убрать из staging area

# ТЕГИ
git tag v1.0.0               # Создать тег
git tag -a v1.0.0 -m "Описание" # Тег с описанием

# ОБЩИЕ СОВЕТЫ
1. Частые мелкие коммиты лучше редких больших
2. Пишите понятные сообщения коммитов
3. Создавайте .gitignore сразу при инициализации репозитория
4. Не коммитьте пароли, ключи API, личные данные
"""
print(cheatsheet)`,
        "description": "Git — распределённая система контроля версий, позволяющая отслеживать изменения в коде. Основные концепции: рабочая директория (working directory), область подготовки (staging area/index), репозиторий (repository). Базовый workflow: 1) Вносим изменения в файлы, 2) Добавляем их в staging area командой `git add`, 3) Фиксируем изменения командой `git commit`. Важные команды: `git status` (проверка состояния), `git diff` (просмотр изменений), `git log` (история коммитов). Файл `.gitignore` определяет, какие файлы Git должен игнорировать. Важно настроить имя и email перед первым коммитом (`git config --global user.name` и `user.email`). Коммиты идентифицируются уникальными хэшами, можно создавать теги для маркировки важных версий."
    },
    {
        "id": 43,
        "title": "Git: Ветвление, слияние и работа с удалёнными репозиториями (Часть 2)",
        "tag": "Другое",
        "shortDesc": "Работа с ветками, стратегии слияния, разрешение конфликтов, работа с GitHub/GitLab и продвинутые команды",
        "code": `# ========== ЧАСТЬ 2: ПРОДВИНУТЫЙ GIT ==========
# Ветвление, слияние, работа с удалёнными репозиториями и решение конфликтов.

print("=== РАБОТА С ВЕТКАМИ (BRANCHES) ===")

# Ветка — указатель на определённый коммит. Позволяет вести параллельную разработку.

# 1. Создание и переключение веток
"""
# Посмотреть все ветки
git branch          # Локальные ветки
git branch -a       # Все ветки (локальные + удалённые)
git branch -v       # Ветки с последним коммитом

# Создать новую ветку
git branch feature/new-button

# Создать ветку и сразу переключиться на неё
git checkout -b feature/new-button
# Альтернатива (Git 2.23+)
git switch -c feature/new-button

# Переключиться на существующую ветку
git checkout main
git switch main     # Git 2.23+

# Переключиться на предыдущую ветку
git checkout -
git switch -        # Git 2.23+
"""

# 2. Удаление и переименование веток
"""
# Удалить локальную ветку (если она слита)
git branch -d feature/old

# Принудительное удаление (даже если не слита)
git branch -D feature/experimental

# Удалить удалённую ветку
git push origin --delete feature/old
# или
git push origin :feature/old

# Переименовать текущую ветку
git branch -m new-feature-name

# Переименовать другую ветку
git branch -m old-name new-name
"""

print("\n=== СЛИЯНИЕ ВЕТОК (MERGING) ===")

# Слияние — интеграция изменений из одной ветки в другую

# 1. Базовое слияние
"""
# Переходим в ветку, КУДА хотим влить изменения
git checkout main
git switch main

# Вливаем изменения из другой ветки
git merge feature/new-button

# Если слияние прошло без конфликтов, Git создаст новый коммит слияния
"""

# 2. Типы слияния
merge_types = """
Fast-forward merge (быстрая перемотка):
    Возможна, когда в целевой ветке (main) не было новых коммитов
    после создания ветки (feature).
    Git просто перемещает указатель ветки вперёд.

3-way merge (трёхстороннее слияние):
    Используется, когда в обеих ветках были изменения.
    Git создаёт новый коммит слияния с двумя родителями.

Squash merge (объединение в один коммит):
    Все коммиты из ветки объединяются в один новый коммит.
    git merge --squash feature/branch
    git commit -m "Все изменения из feature/branch"

Rebase (перебазирование):
    Альтернатива слиянию, "перемещает" коммиты ветки на верх целевой ветки.
    git checkout feature/branch
    git rebase main
"""
print(merge_types)

# 3. Стратегии слияния
"""
# Слияние без fast-forward (всегда создаёт коммит слияния)
git merge --no-ff feature/branch

# Слияние с squash (объединяет все коммиты ветки в один)
git merge --squash feature/branch
git commit -m "Все изменения из feature/branch"

# Отмена слияния (если ещё не отправили на сервер)
git merge --abort
"""

print("\n=== РАЗРЕШЕНИЕ КОНФЛИКТОВ СЛИЯНИЯ ===")

# Конфликт возникает, когда Git не может автоматически объединить изменения

conflict_example = """
# Симуляция конфликта:
# 1. В ветке main изменили строку 5 в файле app.py
# 2. В ветке feature тоже изменили строку 5 в файле app.py
# 3. При слиянии Git сообщит о конфликте

# Сообщение Git при конфликте:
"""
print("Auto-merging app.py")
print("CONFLICT (content): Merge conflict in app.py")
print("Automatic merge failed; fix conflicts and then commit the result.")

resolution_guide = """
# Как разрешить конфликт:

1. Проверьте статус:
   git status
   # Вы увидите файлы с конфликтами: "both modified: app.py"

2. Откройте файл с конфликтом. Git пометил конфликтующие участки:
   
   <<<<<<< HEAD
   Это изменение из текущей ветки (main)
   =======
   Это изменение из сливаемой ветки (feature)
   >>>>>>> feature/branch
   
   Между <<<<<<< HEAD и ======= - ваши изменения.
   Между ======= и >>>>>>> - изменения из сливаемой ветки.

3. Вручную отредактируйте файл, оставив нужный вариант или объединив оба:
   
   # Вариант 1: Оставить изменения из main
   Удалить строки с <<<<<<<, =======, >>>>>>> и изменения из feature
   
   # Вариант 2: Оставить изменения из feature  
   Удалить строки с <<<<<<<, =======, >>>>>>> и изменения из main
   
   # Вариант 3: Объединить оба варианта
   Оставить нужные части из обоих изменений, удалить маркеры

4. После редактирования:
   
   # Добавьте исправленный файл
   git add app.py
   
   # Завершите слияние
   git commit
   # Git предложит сообщение по умолчанию, можно изменить
   
   # Или если передумали сливать:
   git merge --abort
"""
print(resolution_guide)

print("\n=== ПЕРЕБАЗИРОВАНИЕ (REBASE) ===")

# Rebase — альтернатива merge, которая "перемещает" историю

"""
# Перебазирование текущей ветки на main
git checkout feature/branch
git rebase main

# Интерактивное перебазирование (можно редактировать, объединять, удалять коммиты)
git rebase -i main
# или для последних N коммитов
git rebase -i HEAD~3

# Продолжить перебазирование после разрешения конфликтов
git rebase --continue

# Пропустить текущий коммит (если конфликт)
git rebase --skip

# Отменить перебазирование
git rebase --abort
"""

print("\n=== РАБОТА С УДАЛЁННЫМИ РЕПОЗИТОРИЯМИ ===")

# Удалённый репозиторий — версия проекта, хранящаяся на сервере (GitHub, GitLab и т.д.)

# 1. Настройка удалённых репозиториев
"""
# Просмотр удалённых репозиториев
git remote
git remote -v  # С URL

# Добавление удалённого репозитория
git remote add origin https://github.com/username/repo.git

# Изменение URL удалённого репозитория
git remote set-url origin https://github.com/username/new-repo.git

# Удаление удалённого репозитория
git remote remove origin
"""

# 2. Отправка изменений на сервер (push)
"""
# Отправить изменения в ветку main
git push origin main

# Отправить ветку и установить отслеживание (upstream)
git push -u origin feature/branch
# После этого можно просто: git push

# Отправить все ветки
git push --all origin

# Принудительная отправка (перезапись истории)
git push --force origin main
# Внимание: --force может удалить чужие коммиты!
# Безопасная альтернатива:
git push --force-with-lease origin main
"""

# 3. Получение изменений с сервера
"""
# Загрузить изменения с удалённого репозитория
git fetch origin

# Загрузить изменения и сразу слить с текущей веткой
git pull origin main

# То же, что git fetch + git merge
git pull

# Pull с rebase вместо merge
git pull --rebase origin main
"""

print("\n=== РАБОТА С FORK НА GITHUB/GITLAB ===")

fork_workflow = """
# Типичный workflow при работе с чужими проектами:

1. Fork репозитория на GitHub/GitLab
   (Кнопка "Fork" на сайте → создаётся ваша копия)

2. Клонируете СВОЙ fork:
   git clone https://github.com/YOUR-USERNAME/repository.git

3. Добавляете оригинальный репозиторий как upstream:
   git remote add upstream https://github.com/ORIGINAL-USER/repository.git

4. Работаете в своей копии:
   git checkout -b feature/my-feature
   # Делаете изменения, коммиты
   git push origin feature/my-feature

5. Синхронизируетесь с оригиналом:
   git fetch upstream
   git merge upstream/main
   # Или: git rebase upstream/main

6. Создаёте Pull Request (GitHub) или Merge Request (GitLab)
   на сайте к оригинальному репозиторию
"""
print(fork_workflow)

print("\n=== ПРОДВИНУТЫЕ ТЕХНИКИ ===")

# 1. Сравнение веток
"""
# Что есть в feature, но нет в main?
git log main..feature
git log feature --not main

# Что изменилось между ветками?
git diff main...feature  # Три точки: изменения в feature с момента расхождения
"""

# 2. Поиск в истории
"""
# Поиск по сообщению коммита
git log --grep="исправление"

# Поиск по содержимому файлов (когда добавили строку)
git log -S "functionName"  # Кто добавил functionName?
git log -p -S "TODO"       # Где добавляли "TODO"?

# Поиск коммита, где сломался функционал (бинарный поиск)
git bisect start
git bisect bad             # Текущее состояние плохое
git bisect good v1.0.0     # В версии 1.0.0 было хорошо
# Git будет предлагать проверять промежуточные коммиты
# Вы говорите git bisect good или git bisect bad
# В конце: git bisect reset
"""

# 3. Сохранение незавершённой работы (stash)
"""
# Сохранить незакоммиченные изменения во временное хранилище
git stash
git stash push -m "Сообщение"  # С сообщением

# Просмотр stash
git stash list

# Вернуть сохранённые изменения
git stash pop    # Вернуть и удалить из stash
git stash apply  # Вернуть, но оставить в stash

# Удалить stash
git stash drop stash@{0}  # Удалить конкретный stash
git stash clear           # Удалить всё

# Создать ветку из stash
git stash branch new-branch stash@{0}
"""

# 4. Восстановление потерянных коммитов
"""
# Просмотр истории всех действий (включая удалённые коммиты)
git reflog

# Восстановить удалённую ветку или коммит
git checkout -b restored-branch hash_from_reflog
"""

print("\n=== РАБОЧИЕ ПРОЦЕССЫ (WORKFLOW) ===")

workflows = """
Git Flow (классический):
    main          - стабильная версия
    develop       - разработка
    feature/*     - новые функции
    release/*     - подготовка релиза
    hotfix/*     - срочные исправления

GitHub Flow (простой):
    main          - всегда стабильная, готовая к деплою
    feature/*     - ветки для новых функций
    Pull Request → Code Review → Merge → Deploy

Trunk-Based Development:
    Одна основная ветка (main/trunk)
    Короткоживущие feature-ветки (1-2 дня)
    Частые мелкие коммиты в main
"""

print(workflows)

print("\n=== ПРАКТИЧЕСКИЙ ПРИМЕР: ПОЛНЫЙ ЦИКЛ РАБОТЫ ===")

full_example = """
# 1. Начало работы над новой функцией
git checkout main
git pull origin main                    # Синхронизируемся
git checkout -b feature/user-profile    # Создаём ветку

# 2. Работа над функцией
# ... редактируем файлы ...
git add .
git commit -m "Добавил базовую структуру профиля"
# ... продолжаем работу ...
git add .
git commit -m "Добавил аватар и контактную информацию"

# 3. Синхронизация с актуальным main (чтобы уменьшить конфликты)
git checkout main
git pull origin main
git checkout feature/user-profile
git rebase main                         # или git merge main

# 4. Если были конфликты, разрешаем их, затем:
git add .
git rebase --continue

# 5. Тестирование и финальные правки
git add .
git commit -m "Исправил баг с отображением аватара"

# 6. Отправка на code review
git push -u origin feature/user-profile
# На GitHub/GitLab создаём Pull/Merge Request

# 7. После approval сливаем в main
git checkout main
git pull origin main
git merge --no-ff feature/user-profile
git push origin main

# 8. Уборка
git branch -d feature/user-profile      # Удалить локальную ветку
git push origin --delete feature/user-profile  # Удалить удалённую
"""
print(full_example)

print("\n=== ОПАСНЫЕ КОМАНДЫ (ИСПОЛЬЗОВАТЬ С ОСТОРОЖНОСТЬЮ) ===")

dangerous_commands = """
# 1. --force push (может удалить чужие коммиты)
git push --force origin main
# Лучше использовать:
git push --force-with-lease origin main

# 2. Восстановление старых версий (потеря новых коммитов)
git reset --hard старый_коммит
# Вместо этого создайте новую ветку:
git checkout старый_коммит -b восстановление

# 3. Очистка неотслеживаемых файлов (нельзя отменить!)
git clean -fd
# Сначала проверьте, что удалится:
git clean -fd -n

# 4. Изменение истории (после того, как отправили на сервер)
git rebase -i main  # Если уже отправили ветку, не делайте это!
# Это вызовет проблемы у всех, кто склонировал репозиторий
"""

print(dangerous_commands)

print("\n=== ШПАРГАЛКА ДЛЯ ПОВСЕДНЕВНОЙ РАБОТЫ ===")

daily_cheatsheet = """
# СОЗДАНИЕ И РАБОТА С ВЕТКАМИ
git branch                          # Список веток
git checkout -b feature/name        # Создать и переключиться
git switch -c feature/name          # То же (Git 2.23+)
git branch -d feature/name          # Удалить (если слита)
git branch -D feature/name          # Принудительно удалить

# СЛИЯНИЕ И КОНФЛИКТЫ
git merge feature/name              # Слить ветку
git merge --abort                   # Отменить слияние
git status                          # Проверить конфликты
# Редактируем файлы, затем:
git add .
git commit

# РАБОТА С УДАЛЁННЫМИ РЕПОЗИТОРИЯМИ
git push -u origin feature/name     # Отправить и установить upstream
git push                            # Отправить (после -u)
git fetch                           # Загрузить изменения
git pull                            # Загрузить и слить
git pull --rebase                   # Загрузить и перебазировать

# ВРЕМЕННОЕ СОХРАНЕНИЕ
git stash                           # Сохранить незавершённую работу
git stash pop                       # Вернуть сохранённое
git stash list                      # Показать stash

# ИСТОРИЯ И ПОИСК
git log --oneline --graph --all     # Красивая история
git log --grep="текст"              # Поиск по сообщению
git reflog                          # История всех действий

# ПРИНЦИПЫ:
1. Часто делайте коммиты
2. Одна ветка = одна задача/фича
3. Перед слиянием синхронизируйтесь с main
4. Всегда делайте pull перед push
5. Не force push в общие ветки
6. Пишите понятные сообщения коммитов
"""
print(daily_cheatsheet)`,
        "description": "Продвинутая работа с Git включает ветвление (создание, переключение, удаление веток), слияние изменений (merge, rebase) и разрешение конфликтов. Ключевые команды: `git branch`, `git checkout`/`git switch`, `git merge`, `git rebase`. При конфликтах Git помечает проблемные участки в файлах (`<<<<<<<`, `=======`, `>>>>>>>`), которые нужно разрешить вручную. Работа с удалёнными репозиториями: `git remote` (управление), `git push` (отправка), `git fetch`/`git pull` (получение). Полезные техники: `git stash` (временное сохранение изменений), `git reflog` (просмотр истории действий), `git bisect` (поиск коммита с багом). Популярные workflow: Git Flow (с ветками develop, feature, release, hotfix) и GitHub Flow (простой подход с ветками от main и pull requests). Осторожность требуется с `--force push` и изменением опубликованной истории."
    }
]


// Состояние приложения (светлая тема по умолчанию)
const state = {
    currentTheme: 'light',
    fontSize: 16,
    currentFilter: 'all',
    searchQuery: '',
    allTags: ['Все', 'Цикл', 'Функции', 'Класс', 'Списки', 'Словари', 'Текста', 'Числа', 'Модули', 'Встроенные модули', 'Обработка ошибок', 'Шаблоны', 'Декораторы', 'Генераторы', 'Асинхронность', 'Неопределено', 'Другое']
};

// DOM элементы
const elements = {
    cardsContainer: document.getElementById('cardsContainer'),
    loadingIndicator: document.getElementById('loadingIndicator'),
    codeModal: document.getElementById('codeModal'),
    modalTitle: document.getElementById('modalTitle'),
    modalTag: document.getElementById('modalTag'),
    modalCode: document.getElementById('modalCode'),
    modalDescription: document.getElementById('modalDescription'),
    closeModal: document.getElementById('closeModal'),
    themeToggle: document.getElementById('themeToggle'),
    fontDecrease: document.getElementById('fontDecrease'),
    fontReset: document.getElementById('fontReset'),
    fontIncrease: document.getElementById('fontIncrease'),
    searchInput: document.getElementById('searchInput'),
    tagFilters: document.querySelector('.tag-filters'),
    cardsCount: document.getElementById('cardsCount'),
    copyCodeBtn: document.getElementById('copyCodeBtn')
};

// Инициализация приложения
function initApp() {
    // Загрузка сохраненных настроек из localStorage
    const savedTheme = localStorage.getItem('pythonCodeLibTheme');
    if (savedTheme) {
        state.currentTheme = savedTheme;
    } else {
        // По умолчанию светлая тема
        state.currentTheme = 'light';
        localStorage.setItem('pythonCodeLibTheme', 'light');
    }
    
    const savedFontSize = localStorage.getItem('pythonCodeLibFontSize');
    if (savedFontSize) {
        state.fontSize = parseInt(savedFontSize);
    }
    
    // Инициализация темы (должна быть до инициализации Prism)
    initTheme();
    
    // Инициализация фильтров по тегам
    initTagFilters();
    
    // Инициализация карточек
    renderCards();
    
    // Инициализация событий
    initEvents();
    
    // Скрываем индикатор загрузки
    elements.loadingIndicator.style.display = 'none';
}

// Инициализация темы
function initTheme() {
    document.documentElement.setAttribute('data-theme', state.currentTheme);
    updatePrismTheme();
    updateFontSize();
    
    // Обновляем иконку кнопки переключения темы
    const icon = elements.themeToggle.querySelector('i');
    icon.className = state.currentTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
}

// Обновление темы Prism
function updatePrismTheme() {
    const prismLight = document.getElementById('prism-light');
    const prismDark = document.getElementById('prism-dark');
    
    if (state.currentTheme === 'dark') {
        prismLight.disabled = true;
        prismDark.disabled = false;
    } else {
        prismLight.disabled = false;
        prismDark.disabled = true;
    }
    
    // Переподсвечиваем код, если он уже был подсвечен
    if (typeof Prism !== 'undefined') {
        Prism.highlightAll();
    }
}

// Инициализация фильтров по тегам
function initTagFilters() {
    // Очищаем контейнер фильтров
    elements.tagFilters.innerHTML = '';
    
    // Добавляем фильтры для каждого тега
    state.allTags.forEach(tag => {
        const button = document.createElement('button');
        button.className = tag === 'Все' ? 'tag-filter active' : 'tag-filter';
        button.textContent = tag;
        button.setAttribute('data-tag', tag);
        elements.tagFilters.appendChild(button);
    });
}

// Инициализация событий
function initEvents() {
    // Переключение темы
    elements.themeToggle.addEventListener('click', toggleTheme);
    
    // Управление размером шрифта
    elements.fontDecrease.addEventListener('click', () => changeFontSize(-1));
    elements.fontReset.addEventListener('click', resetFontSize);
    elements.fontIncrease.addEventListener('click', () => changeFontSize(1));
    
    // Модальное окно с кодом
    elements.closeModal.addEventListener('click', () => {
        elements.codeModal.classList.remove('active');
    });
    
    // Поиск
    elements.searchInput.addEventListener('input', (e) => {
        state.searchQuery = e.target.value.toLowerCase();
        renderCards();
    });
    
    // Фильтры по тегам
    elements.tagFilters.addEventListener('click', (e) => {
        if (e.target.classList.contains('tag-filter')) {
            // Убираем активный класс у всех кнопок
            document.querySelectorAll('.tag-filter').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Добавляем активный класс нажатой кнопке
            e.target.classList.add('active');
            
            // Устанавливаем текущий фильтр
            state.currentFilter = e.target.getAttribute('data-tag');
            renderCards();
        }
    });
    
    // Копирование кода
    elements.copyCodeBtn.addEventListener('click', copyCodeToClipboard);
    
    // Закрытие модальных окон при клике вне их
    window.addEventListener('click', (e) => {
        if (e.target === elements.codeModal) {
            elements.codeModal.classList.remove('active');
        }
    });
    
    // Закрытие модального окна при нажатии Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && elements.codeModal.classList.contains('active')) {
            elements.codeModal.classList.remove('active');
        }
    });
}

// Отображение карточек
function renderCards() {
    // Фильтрация карточек
    let filteredCards = cardsData.filter(card => {
        // Фильтр по тегу
        if (state.currentFilter !== 'Все' && state.currentFilter !== 'all' && card.tag !== state.currentFilter) {
            return false;
        }
        
        // Фильтр по поисковому запросу
        if (state.searchQuery) {
            const searchLower = state.searchQuery.toLowerCase();
            return card.title.toLowerCase().includes(searchLower) ||
                   card.shortDesc.toLowerCase().includes(searchLower) ||
                   card.tag.toLowerCase().includes(searchLower) ||
                   card.description.toLowerCase().includes(searchLower) ||
                   card.code.toLowerCase().includes(searchLower);
        }
        
        return true;
    });
    
    // Очищаем контейнер
    elements.cardsContainer.innerHTML = '';
    
    // Обновляем счетчик карточек
    elements.cardsCount.textContent = filteredCards.length;
    
    // Если нет карточек после фильтрации
    if (filteredCards.length === 0) {
        const noResults = document.createElement('div');
        noResults.className = 'no-results';
        noResults.innerHTML = `
            <i class="fas fa-search"></i>
            <h3>Карточки не найдены</h3>
            <p>Попробуйте изменить параметры поиска или выберите другой тег</p>
        `;
        elements.cardsContainer.appendChild(noResults);
        return;
    }
    
    // Создаем карточки
    filteredCards.forEach(card => {
        const cardElement = createCardElement(card);
        elements.cardsContainer.appendChild(cardElement);
    });
    
    // Инициализируем Prism для подсветки синтаксиса в предпросмотре
    if (typeof Prism !== 'undefined') {
        Prism.highlightAll();
    }
}

// Создание элемента карточки
function createCardElement(card) {
    const cardElement = document.createElement('div');
    cardElement.className = 'card';
    cardElement.setAttribute('data-id', card.id);
    
    // Обрезаем код для предпросмотра (первые 5 строк)
    const previewLines = card.code.split('\n');
    const previewCode = previewLines.slice(0, 5).join('\n');
    
    cardElement.innerHTML = `
        <div class="card-tag">${card.tag}</div>
        <div class="card-header">
            <h3 class="card-title">${card.title}</h3>
            <p class="card-short-desc">${card.shortDesc}</p>
        </div>
        <div class="card-preview">
            <pre><code class="language-python">${previewCode}${previewLines.length > 5 ? '\n...' : ''}</code></pre>
        </div>
    `;
    
    // Добавляем обработчик клика
    cardElement.addEventListener('click', () => openCardModal(card));
    
    return cardElement;
}

// Открытие модального окна с карточкой
function openCardModal(card) {
    elements.modalTitle.textContent = card.title;
    elements.modalTag.textContent = card.tag;
    elements.modalCode.textContent = card.code;
    elements.modalDescription.textContent = card.description;
    
    // Подсветка синтаксиса
    if (typeof Prism !== 'undefined') {
        Prism.highlightElement(elements.modalCode);
    }
    
    // Открываем модальное окно
    elements.codeModal.classList.add('active');
}

// Копирование кода в буфер обмена
function copyCodeToClipboard() {
    const codeText = elements.modalCode.textContent;
    
    navigator.clipboard.writeText(codeText).then(() => {
        // Визуальная обратная связь
        const originalText = elements.copyCodeBtn.innerHTML;
        elements.copyCodeBtn.innerHTML = '<i class="fas fa-check"></i> Скопировано!';
        elements.copyCodeBtn.style.backgroundColor = 'var(--accent-success)';
        
        setTimeout(() => {
            elements.copyCodeBtn.innerHTML = originalText;
            elements.copyCodeBtn.style.backgroundColor = '';
        }, 2000);
    }).catch(err => {
        console.error('Ошибка копирования: ', err);
        // Fallback для старых браузеров
        const textArea = document.createElement('textarea');
        textArea.value = codeText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        const originalText = elements.copyCodeBtn.innerHTML;
        elements.copyCodeBtn.innerHTML = '<i class="fas fa-check"></i> Скопировано!';
        elements.copyCodeBtn.style.backgroundColor = 'var(--accent-success)';
        
        setTimeout(() => {
            elements.copyCodeBtn.innerHTML = originalText;
            elements.copyCodeBtn.style.backgroundColor = '';
        }, 2000);
    });
}

// Переключение темы
function toggleTheme() {
    state.currentTheme = state.currentTheme === 'light' ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', state.currentTheme);
    
    // Обновляем иконку
    const icon = elements.themeToggle.querySelector('i');
    icon.className = state.currentTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
    
    // Обновляем тему Prism
    updatePrismTheme();
    
    // Сохраняем в localStorage
    localStorage.setItem('pythonCodeLibTheme', state.currentTheme);
}

// Изменение размера шрифта
function changeFontSize(delta) {
    state.fontSize += delta;
    
    // Ограничиваем размер шрифта
    if (state.fontSize < 12) state.fontSize = 12;
    if (state.fontSize > 24) state.fontSize = 24;
    
    updateFontSize();
    localStorage.setItem('pythonCodeLibFontSize', state.fontSize.toString());
}

// Сброс размера шрифта
function resetFontSize() {
    state.fontSize = 16;
    updateFontSize();
    localStorage.setItem('pythonCodeLibFontSize', state.fontSize.toString());
}

// Обновление размера шрифта
function updateFontSize() {
    document.documentElement.style.setProperty('--font-size-base', `${state.fontSize}px`);
    document.documentElement.style.setProperty('--font-size-small', `${state.fontSize * 0.875}px`);
    document.documentElement.style.setProperty('--font-size-large', `${state.fontSize * 1.125}px`);
    document.documentElement.style.setProperty('--font-size-xlarge', `${state.fontSize * 1.25}px`);
    document.documentElement.style.setProperty('--font-size-xxlarge', `${state.fontSize * 1.5}px`);
}

// Инициализация приложения после загрузки DOM
document.addEventListener('DOMContentLoaded', initApp);